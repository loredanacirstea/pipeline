{"version":3,"file":"index.js","sources":["../../pipejs/dist/index.es.js","../src/index.js"],"sourcesContent":["import util from 'util';\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\n/* eslint-disable */\nvar Sanct = require('sanctuary');\n\nvar SDef = require('sanctuary-def');\n\nvar bigInt = require(\"big-integer\");\n\nfunction pipe(rtypes) {\n  window.S = Sanct;\n  var pipejs = {\n    types: rtypes.reduce((accum, types) => Object.assign(accum, types), {}),\n    settings: {\n      id: \"5bc59e192817116e84bdd831\",\n      baseurl: \"http://example.com/my-package#\"\n    }\n  };\n\n  var PFUNC_IO = (step_out, typing) => {\n    // typing might contain other attributes, like payable\n    return {\n      \"_id\": pipejs.settings.id + step_out,\n      \"pclassid\": \"5c95397d4212cc40afeec914\",\n      \"pfunction\": {\n        \"signature\": \"io\",\n        \"sources\": {\n          \"javascript\": \"f=>f\"\n        },\n        \"graph\": {},\n        \"gapi\": {\n          \"constant\": true,\n          \"inputs\": [typing],\n          \"name\": \"io\",\n          \"outputs\": [typing],\n          \"payable\": false,\n          \"stateMutability\": \"view\",\n          \"type\": \"function\"\n        }\n      },\n      \"timestamp\": \"2019-03-22T14:38:36.112Z\",\n      \"pclass\": {\n        _id: \"0x0\",\n        name: \"pipejs_identity\",\n        type: 'javascript',\n        deployment: 'unknown'\n      }\n    };\n  };\n\n  var COMMON_INPUT = (id, output) => {\n    // typing might contain other attributes, like payable\n    return {\n      \"_id\": id,\n      \"pclassid\": \"5dbaa731f18ff7488e9b108b\",\n      \"pfunction\": {\n        \"signature\": \"id(x)\",\n        \"gapi\": {\n          \"constant\": true,\n          \"inputs\": [],\n          \"name\": \"id\",\n          \"outputs\": [output],\n          \"payable\": false,\n          \"stateMutability\": \"pure\",\n          \"type\": \"function\"\n        },\n        \"graph\": {},\n        \"sources\": {\n          \"javascript.rust\": \"() => rust.id()\",\n          \"javascript\": \"(x)=>x\"\n        }\n      },\n      \"timestamp\": \"2019-11-06T19:22:53.807Z\",\n      pclass: {\n        _id: \"0x0\",\n        name: \"pipejs_common_input\",\n        type: 'javascript',\n        deployment: 'unknown'\n      }\n    };\n  };\n\n  var env = SDef.env;\n  var def = SDef.create({\n    checkTypes: true,\n    env\n  });\n  var pl = {};\n  pl[\"mongoid\"] = SDef.NullaryType('mongoid')(pipejs.settings.baseurl + 'mongoid')([])(x => Sanct.is(SDef.String)(x) // && bigInt(x, 16).geq(0) && bigInt(x, 16).lesser(two.pow(12*8))\n  );\n  pl[\"node\"] = SDef.RecordType({\n    \"i\": SDef.Number,\n    \"id\": pl[\"mongoid\"]\n  });\n  pl[\"rich_node\"] = SDef.RecordType({\n    \"i\": SDef.Number,\n    \"svg_id\": SDef.String,\n    \"id\": pl[\"mongoid\"],\n    \"out\": SDef.StrMap(SDef.Array(SDef.Array(SDef.Number))),\n    \"in\": SDef.StrMap(SDef.Array(SDef.Number)),\n    \"position\": SDef.RecordType({\n      \"x\": SDef.Number,\n      \"y\": SDef.Number\n    }),\n    \"edges\": SDef.Array(SDef.String)\n  });\n  pl[\"edge\"] = SDef.NullaryType('edge')(pipejs.settings.baseurl + 'edge')([])(x => Sanct.is(SDef.Array(SDef.Number))(x) && Sanct.equals(4)(x.length));\n  pl[\"rich_edge\"] = SDef.NullaryType('edge')(pipejs.settings.baseurl + 'edge')([])(x => Sanct.is(SDef.RecordType({\n    \"e\": pl[\"edge\"],\n    \"svg_id\": SDef.String,\n    \"type\": SDef.String\n  }))(x) && Sanct.is(SDef.Type)(pipejs.types[x.type])); // pl[\"rich_edge\"] = SDef.NullaryType  ('edge') (baseurl+'edge') ([])\n  //   (x => Sanct.is (SDef.Array (SDef.Number)) (x) && Sanct.equals (5) (x.length) )\n\n  pl[\"nodes\"] = SDef.StrMap(pl[\"node\"]);\n  pl[\"rich_nodes\"] = SDef.StrMap(pl[\"rich_node\"]);\n  pl[\"edges\"] = SDef.Array(pl[\"edge\"]);\n  pl[\"runtime\"] = SDef.Array(SDef.Any);\n  pl[\"graph\"] = SDef.NullaryType('graph')(pipejs.settings.baseurl + 'graph')([])(x => Sanct.is(SDef.RecordType({\n    \"n\": pl[\"nodes\"],\n    \"e\": pl[\"edges\"],\n    r: pl[\"runtime\"]\n  }))(x) //&& Sanct.map (edge => (x.n[edge[0]] || x.r[edge[0]]) && (x.n[edge[2]] || x.r[edge[2]]) (x.e) )\n  );\n  pl[\"rich_graph\"] = SDef.NullaryType('rich_graph')(pipejs.settings.baseurl + 'rich_graph')([])(x => Sanct.is(SDef.RecordType({\n    \"n\": pl[\"rich_nodes\"],\n    \"e\": pl[\"edges\"],\n    \"r\": pl[\"runtime\"],\n    init: pl[\"graph\"]\n  }))(x));\n  pl[\"runnable_graph_step\"] = SDef.NullaryType('runnable_graph_step')(pipejs.settings.baseurl + 'runnable_graph_step')([])(x => Sanct.is(SDef.Array(SDef.Number))(x) || Sanct.is(SDef.Array0)(x));\n  pl[\"runnable_graph\"] = SDef.Array(pl[\"runnable_graph_step\"]);\n  pl[\"graph_history\"] = SDef.Array(pl[\"graph\"]);\n  pl[\"abi_io_function\"] = SDef.NullaryType('abi_io_function')(pipejs.settings.baseurl + 'abi_io_function')([])(x => Sanct.is(SDef.RecordType({\n    \"name\": SDef.String,\n    \"type\": SDef.String // TODO components\n\n  }))(x) && Sanct.is(SDef.Type)(pipejs.types[x.type]));\n  pl[\"abi_io_event\"] = SDef.NullaryType('abi_io_event')(pipejs.settings.baseurl + 'abi_io_event')([])(x => Sanct.is(SDef.RecordType({\n    \"name\": SDef.String,\n    \"type\": SDef.String,\n    // TODO components\n    \"indexed\": SDef.Boolean\n  }))(x) && Sanct.is(SDef.Type)(pipejs.types[x.type]));\n  pl['abi_ios_function'] = SDef.NullaryType('abi_ios_function')(pipejs.settings.baseurl + 'abi_ios_function')([])(x => Sanct.is(SDef.Array(pl[\"abi_io_function\"]))(x) || Sanct.is(SDef.Array0)(x));\n  pl['abi_ios_events'] = SDef.NullaryType('abi_io_event')(pipejs.settings.baseurl + 'abi_io_event')([])(x => Sanct.is(SDef.Array(pl[\"abi_io_event\"]))(x) || Sanct.is(SDef.Array0)(x));\n  pl[\"abi_type\"] = SDef.EnumType('abi_type')(pipejs.settings.baseurl + 'abi_type')([\"function\", \"constructor\", \"fallback\", \"event\", \"receive\", \"string\"]);\n  pl[\"abi_mutability\"] = SDef.EnumType('abi_mutability')(pipejs.settings.baseurl + 'abi_mutability')([\"pure\", \"view\", \"nonpayable\", \"payable\"]);\n  pl[\"func_abi\"] = SDef.RecordType({\n    \"type\": pl[\"abi_type\"],\n    // might be missing; default 'function'\n    \"name\": SDef.String,\n    \"inputs\": pl['abi_ios_function'],\n    \"outputs\": pl['abi_ios_function'],\n    \"constant\": SDef.Boolean,\n    // will be deprecated\n    \"payable\": SDef.Boolean,\n    // will be deprecated\n    \"stateMutability\": pl[\"abi_mutability\"]\n  });\n  pl[\"event_abi\"] = SDef.RecordType({\n    \"type\": pl[\"abi_type\"],\n    \"name\": SDef.String,\n    \"inputs\": SDef.Array0,\n    \"outputs\": pl['abi_ios_events'],\n    \"anonymous\": SDef.Boolean\n  });\n  pl[\"gapi\"] = SDef.NullaryType('gapi')(pipejs.settings.baseurl + 'gapi')([])(x => Sanct.is(pl[\"func_abi\"])(x) || Sanct.is(pl[\"event_abi\"])(x));\n  pl[\"cont_abi\"] = SDef.Array(pl[\"func_abi\"]);\n  pl[\"pclass\"] = SDef.RecordType({\n    _id: SDef.String,\n    name: SDef.String,\n    type: SDef.String,\n    deployment: SDef.String\n  });\n  pl[\"db_func\"] = SDef.RecordType({\n    \"_id\": pl[\"mongoid\"],\n    \"pclassid\": pl[\"mongoid\"],\n    \"pfunction\": SDef.RecordType({\n      \"signature\": SDef.String,\n      \"gapi\": pl[\"gapi\"],\n      \"graph\": SDef.Any,\n      \"sources\": SDef.StrMap(SDef.String)\n    }),\n    \"timestamp\": SDef.String,\n    \"pclass\": pl[\"pclass\"]\n  });\n  pl[\"db_funcs\"] = SDef.Array(pl[\"db_func\"]);\n  pl[\"id_funcs\"] = SDef.StrMap(pl[\"db_func\"]);\n  pl[\"runtime_graph\"] = SDef.RecordType({\n    \"rich_graph\": pl[\"rich_graph\"],\n    \"runnable_graph\": pl[\"runnable_graph\"],\n    \"context\": pl[\"id_funcs\"],\n    \"runtime\": SDef.StrMap(pl[\"runtime\"])\n  });\n  pipejs.pl = pl;\n  pipejs._currentPoint = {\n    x: 0,\n    y: 1\n  };\n  pipejs.indexed_func = {};\n  pipejs.set_indexed_func = def('set_indexed_func')({})([pl[\"id_funcs\"], pl[\"id_funcs\"]])(fcontext => {\n    pipejs.indexed_func = fcontext;\n    return pipejs.indexed_func;\n  });\n  pipejs.get_indexed_func = def('get_indexed_func')({})([pl[\"id_funcs\"]])(() => pipejs.indexed_func);\n  pipejs.add_indexed_func = def('index_funcs')({})([pl[\"db_func\"], pl[\"id_funcs\"]])(added_func => {\n    pipejs.indexed_func[added_func._id] = added_func;\n    return pipejs.indexed_func;\n  });\n  pipejs.index_funcs = def('index_funcs')({})([pl[\"db_funcs\"], pl[\"id_funcs\"]])(db_funcs => {\n    var obj_funcs = {};\n    Sanct.map(x => obj_funcs[x._id] = x)(db_funcs);\n    return obj_funcs;\n  });\n  pipejs.add_const = def('add_const')({})([pl[\"graph\"], SDef.Object, pl[\"graph\"]])(graph => edge => variable => {\n    var graph2 = JSON.parse(JSON.stringify(graph));\n    pipejs.settings.runstep++;\n    graph2.r[pipejs.settings.runstep] = variable;\n    return pipejs.add_edge(graph2)(edge);\n  });\n  pipejs.add_edge = def('add_edge')({})([pl[\"graph\"], pl[\"edge\"], pl[\"graph\"]])(graph => edge => {\n    //if (!(graph.n[edge[0]] && graph.n[edge[2]])) return graph;\n    if (edge in graph.e) return graph;\n    var graph2 = JSON.parse(JSON.stringify(graph));\n    graph2.e.push(edge);\n    return graph2;\n  });\n\n  pipejs.indexInArray = function (array, item) {\n    // console.log(array, item)\n    for (var i = 0; i < array.length; i++) {\n      // This if statement depends on the format of your array\n      if (array[i][0] == item[0] && array[i][1] == item[1] && array[i][2] == item[2] && array[i][3] == item[3]) {\n        return i; // Found it\n      }\n    }\n\n    return -1; // Not found\n  };\n\n  pipejs.remove_edge = def('remove_edge')({})([pl[\"graph\"], pl[\"edge\"], pl[\"graph\"]])(graph => edge => {\n    // console.log(\"ndx\", graph.e)\n    var index = pipejs.indexInArray(graph.e, edge); // console.log(\"ndx\", index)\n\n    if (index > -1) {\n      var graph2 = JSON.parse(JSON.stringify(graph));\n      graph2.e.splice(index, 1);\n      return graph2;\n    }\n\n    return graph;\n  });\n  pipejs.add_node = def('add_node')({})([pl[\"graph\"], pl[\"node\"], pl[\"graph\"]])(graph => node => {\n    var graph2 = JSON.parse(JSON.stringify(graph));\n    graph2.n[node.i] = node;\n    return graph2;\n  });\n  pipejs.remove_node = def('remove_node')({})([pl[\"graph\"], SDef.Number, pl[\"graph\"]])(graph => node_id => {\n    // console.log(!(\"\"+node_id in graph.n))\n    if (!(\"\" + node_id in graph.n)) return graph;\n    var graph2 = JSON.parse(JSON.stringify(graph)); // console.log(graph2)\n\n    var ndx = 0; // delete edges from/to that node first!\n\n    while (graph2.e.length > ndx) {\n      if (graph2.e[ndx][0] == node_id || graph2.e[ndx][2] == node_id) {\n        graph2.e.splice(ndx, 1);\n      } else {\n        ndx++;\n      }\n    }\n\n    delete graph2.n[\"\" + node_id];\n    return graph2;\n  });\n\n  pipejs.enrich = function (na) {\n    //if (na._currentPoint === undefined) na._currentPoint = {x: 0, y: 1}\n    pipejs._currentPoint.y = na.level;\n    if (na.row === 0) pipejs._currentPoint.x = 0;\n    na.node.position = {\n      x: pipejs._currentPoint.x,\n      y: pipejs._currentPoint.y\n    };\n    var max = Math.max(na.context[na.node.id].pfunction.gapi.inputs.length, na.context[na.node.id].pfunction.gapi.outputs.length); //console.log(max, pipejs._currentPoint)\n\n    pipejs._currentPoint.x = pipejs._currentPoint.x + max;\n  };\n\n  pipejs.addEdges = function (g) {\n    //// console.log(\"grfff\",g)\n    Sanct.map(e => {\n      // console.log(\"edge\",e, g)\n      if (g.r[e[0]]) ; else {\n        //g.n[e[0]].out[e[1]] = [[e[2], e[3]]]\n        if (g.n[e[0]].out[e[1]]) {\n          g.n[e[0]].out[e[1]].push([e[2], e[3]]);\n        } else {\n          g.n[e[0]].out[e[1]] = [[e[2], e[3]]];\n        }\n      }\n\n      g.n[e[2]].in[e[3]] = [e[0], e[1]];\n    })(g.e);\n  };\n\n  pipejs.difference = function (first, second) {\n    for (var i = 0; i < second.length; i++) {\n      var index = undefined;\n\n      while ((index = first.indexOf(second[i])) !== -1) {\n        first.splice(index, 1);\n      }\n    }\n\n    return first;\n  };\n\n  pipejs.inputNodesAreVisited = function (node, visited) {\n    // console.log(\"iii\", node,  visited)\n    for (var key in node.in) {\n      if (!visited.includes(\"\" + node.in[key][0])) return false;\n    }\n\n    return true;\n  };\n\n  pipejs.inputNodesAreDefined = function (node, defined, level) {\n    // console.log(\"iii\", node, defined)\n    if (level === 0) return false;\n\n    for (var key in node.in) {\n      // console.log(\"iiikey\", key, node.in[key])\n      var u = defined[node.in[key][0]]; // console.log(\"iiikeyu\", u)\n      //return  true\n\n      if (!u) return false;\n      if (!u[node.in[key][0]]) return false;\n    }\n\n    return true;\n  };\n\n  pipejs.positionNodes = function (gf, unvisited, visited, visitors, level) {\n    if (unvisited.length === 0) return;\n    var row = 0,\n        visitedNow = [];\n    var only_outputs = true;\n    Sanct.map(n => {\n      if (n < 4000) only_outputs = false;\n    })(unvisited);\n    Sanct.map(n => {\n      if ((pipejs.inputNodesAreVisited(gf.n[n], visited) || pipejs.inputNodesAreDefined(gf.n[n], gf.r, level)) && (level > 0 || n > 2000)) {\n        Sanct.flip(visitors)({\n          node: gf.n[n],\n          level: level,\n          row: row,\n          context: pipejs.indexed_func\n        });\n        row = row + 1;\n        if (only_outputs || n < 4000) visitedNow.push(n);\n      }\n    })(unvisited);\n    unvisited = pipejs.difference(unvisited, visitedNow);\n    visited = visited.concat(visitedNow); // console.log(gf, unvisited, visited, visitors, level+1)\n\n    return pipejs.positionNodes(gf, unvisited, visited, visitors, level + 1);\n  };\n\n  pipejs.addNodesEdges = function (grf, context) {\n    var added_nodes = {};\n    var added_edges = [];\n    var step_out = 4000;\n    var step_in = 3000;\n\n    while (grf.n[\"\" + step_out] !== undefined) {\n      step_out++;\n    }\n\n    while (grf.n[\"\" + step_in] !== undefined) {\n      step_in++;\n    }\n\n    Sanct.map(n => {\n      // for inputs with multiple edges, we add a mock node in context\n      if (n.i >= 3000) {\n        var [targetNode, targetPort] = n.out[\"1\"][0];\n        var output = context[grf.n[\"\" + targetNode].id].pfunction.gapi.inputs[targetPort - 1];\n        context[n.id] = COMMON_INPUT(n.id, {\n          type: output.type,\n          name: output.name\n        });\n      }\n\n      for (var i = 1; i <= context[n.id].pfunction.gapi.outputs.length; i++) {\n        if (!(\"\" + i in n.out) && n.id != pipejs.settings.id) {\n          var no = {\n            i: step_out,\n            svg_id: \"\",\n            id: pipejs.settings.id + step_out,\n            in: {\n              \"1\": [n.i, i]\n            },\n            out: {},\n            position: {\n              x: 0,\n              y: 0\n            },\n            edges: []\n          };\n          var typing = context[n.id].pfunction.gapi.outputs[i - 1]; // console.log(context[n.id].pfunction.gapi.outputs, i)\n\n          pipejs.indexed_func[pipejs.settings.id + step_out] = PFUNC_IO(step_out, typing);\n          added_nodes[step_out] = no;\n          added_edges.push([n.i, i, step_out, 1]);\n          n.out[\"\" + i] = [[step_out, 1]];\n          step_out++;\n        }\n      }\n\n      for (var _i = 1; _i <= context[n.id].pfunction.gapi.inputs.length; _i++) {\n        while (grf.n[step_in]) {\n          step_in += 1;\n        }\n\n        if (!(\"\" + _i in n.in) && n.id != pipejs.settings.id) {\n          var on = {\n            edges: [],\n            i: step_in,\n            id: pipejs.settings.id + step_in,\n            in: {},\n            out: {\n              \"1\": [[n.i, _i]]\n            },\n            position: {\n              x: 0,\n              y: 0\n            },\n            svg_id: \"\"\n          };\n          var _typing = context[n.id].pfunction.gapi.inputs[_i - 1]; // console.log(context[n.id].pfunction.gapi.inputs, i)\n\n          pipejs.indexed_func[pipejs.settings.id + step_in] = PFUNC_IO(step_in, _typing);\n          added_nodes[step_in] = on;\n          added_edges.push([step_in, 1, n.i, _i]);\n          n.in[\"\" + _i] = [step_in, 1];\n          step_in++;\n        }\n      }\n    })(grf.n);\n    grf.n = Object.assign(grf.n, added_nodes); // console.log(\"added_edges\", added_edges)\n\n    grf.e = grf.e.concat(added_edges);\n  }; // pipejs.add_common_input_context = def ('add_common_input_context') ({})\n  //   ([pl[\"id_funcs\"], pl[\"graph\"], pl[\"id_funcs\"]])\n  //   (context => graph => {\n  //     Sanct.map (n => {\n  //       const common_input = COMMON_INPUT()\n  //\n  //       context[added_func._id] = added_func;\n  //     }) (graph.n)\n  //     return context;\n  //   });\n\n\n  pipejs.enrich_graph = def('enrich_graph')({})([pl[\"id_funcs\"], pl[\"graph\"], pl[\"rich_graph\"]])(context => graph1 => {\n    var graph2 = JSON.parse(JSON.stringify(graph1)); // context = pipejs.add_common_input_context(context) (graph1);\n\n    Sanct.map(x => {\n      x.out = {};\n      x.in = {};\n      x.position = {\n        x: 0,\n        y: 0\n      };\n      x.svg_id = \"\";\n      x.edges = [];\n    })(graph2.n);\n    pipejs.addEdges(graph2);\n    pipejs.addNodesEdges(graph2, context); // console.log(\"lllll\",graph2)\n\n    var visitors = [pipejs.enrich];\n    var graph3 = pipejs.positionNodes(graph2, Sanct.keys(graph2.n), [\"0\"], visitors, 0); // console.log(\"graph3\",graph3)\n\n    graph2.init = graph1;\n    return graph2;\n  });\n  pipejs.make_runtime = def('make_runtime')({})([pl[\"id_funcs\"], pl[\"rich_graph\"], pl[\"runtime_graph\"]])(context => rich_graph => {\n    var rows = [];\n    var rich_graph2 = JSON.parse(JSON.stringify(rich_graph));\n\n    for (var x of Object.keys(rich_graph2.n)) {\n      if (rows[rich_graph2.n[x].position.y] === undefined) {\n        rows[rich_graph2.n[x].position.y] = [];\n      }\n\n      rows[rich_graph2.n[x].position.y].push(parseInt(x));\n    }\n\n    if (!rows[0]) rows[0] = [];\n    return {\n      \"rich_graph\": rich_graph2,\n      \"runnable_graph\": rows,\n      \"context\": context,\n      \"runtime\": {\n        \"0\": rich_graph2.r\n      }\n    };\n  });\n  pipejs.run_graph = def('run_graph')({})([pl[\"runtime_graph\"], SDef.Any, SDef.Any, SDef.Any])(runtime_graph => resolver =>\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(function* (ins) {\n      var node;\n      var arr_ins = ins instanceof Array ? ins : Object.values(ins);\n      var runnable = JSON.parse(JSON.stringify(runtime_graph.runnable_graph));\n      var rich = JSON.parse(JSON.stringify(runtime_graph.rich_graph));\n      runnable[0].forEach((key, i) => {\n        if (key < 3000) return;\n        var nodeContext = runtime_graph.context[rich.n[\"\" + key].id];\n        resolver.setInput(\"\" + key, [arr_ins[i]], nodeContext.pfunction.gapi.outputs[0]);\n      });\n\n      for (var x of runnable) {\n        var _loop = function* _loop(y) {\n          node = rich.n[\"\" + y];\n          var contxt = runtime_graph.context[node.id];\n          var inputKeys = [];\n\n          if (\"1\" in node.in) {\n            Sanct.map(x1 => {\n              var nodeContext = runtime_graph.context[rich.n[x1[0]].id];\n              var source = nodeContext.pfunction.gapi.outputs[x1[1] - 1];\n              inputKeys.push([\"\" + x1[0], x1[1] - 1, source]);\n            })(node.in);\n          } else {\n            var outs = contxt.pfunction.gapi.outputs;\n            inputKeys = outs.map((io, i) => [\"\" + y, i, io]);\n          }\n\n          if (Object.getOwnPropertyNames(contxt.pfunction.graph).length > 0) ; else {\n            yield resolver.onNodeCall(contxt, inputKeys, contxt.pfunction.gapi.outputs.map((io, i) => [\"\" + y, i, io]));\n          }\n        };\n\n        for (var y of x) {\n          yield* _loop(y);\n        }\n      }\n\n      runnable[runnable.length - 1].map((key, i) => {\n        if (key < 4000) return;\n        var [sourceNode, sourcePort] = rich.n[key].in[1];\n        var nodeContext = runtime_graph.context[rich.n[sourceNode].id];\n        var source = nodeContext.pfunction.gapi.outputs[sourcePort - 1];\n        resolver.setOutput(\"\" + sourceNode, sourcePort - 1, source);\n      });\n      return resolver.getOutput();\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n  pipejs.build_and_run_graph = def('build_and_run_graph')({})([pl[\"id_funcs\"], pl[\"graph\"], SDef.Object, SDef.Any])(context => graph => resolver => ins => {\n    pipejs.set_indexed_func(context);\n    return pipejs.run_graph(pipejs.make_runtime(context)(pipejs.enrich_graph(context)(graph)))(resolver)(ins);\n  });\n\n  pipejs.getFuncsFromGraph = function (gf) {\n    var out = [];\n\n    for (var node in gf.n) {\n      out.push(gf.n[node].id);\n    }\n\n    return out;\n  };\n\n  return pipejs;\n}\n\nvar Sanct$1 = require('sanctuary');\n\nvar SDef$1 = require('sanctuary-def');\n\nvar bigInt$1 = require('big-integer');\n\nvar two = bigInt$1(2);\nvar solidity = {}; // Solidity value types\n\nSanct$1.map(y => {\n  solidity['uint' + y * 8] = SDef$1.NullaryType('uint' + y * 8)('uint' + y * 8)([])(x => bigInt$1.isInstance(x) && x.geq(0) && x.lesser(two.pow(new bigInt$1(y * 8))));\n  solidity['int' + y * 8] = SDef$1.NullaryType('int' + y * 8)('int' + y * 8)([])(x => bigInt$1.isInstance(x) && x.geq(-two.pow(new bigInt$1(y * 8 - 1))) && x.lesser(two.pow(new bigInt$1(y * 8 - 1))));\n  solidity['bytes' + y] = SDef$1.NullaryType('bytes' + y)('bytes' + y)([])(x => bigInt$1.isInstance(x) && x.geq(0) && x.lesser(two.pow(new bigInt$1(y * 8))));\n})(Sanct$1.range(1)(33)); // TODO: fixed, ufixed\n\n[['string', SDef$1.String], ['bytes', SDef$1.String], ['function', SDef$1.Any], ['address', solidity['bytes20']], ['byte', solidity['bytes1']], ['uint', solidity['uint256']], ['int', solidity['int256']], ['bool', solidity['uint8']], ['tuple', SDef$1.Any] // has to be better defined SDef.RecordType\n].map(x => solidity[x[0]] = x[1]);\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar sanctuaryShow = createCommonjsModule(function (module) {\n//. # sanctuary-show\n//.\n//. Haskell has a `show` function which can be applied to a compatible value to\n//. produce a descriptive string representation of that value. The idea is that\n//. the string representation should, if possible, be an expression which would\n//. produce the original value if evaluated.\n//.\n//. This library provides a similar [`show`](#show) function.\n//.\n//. In general, this property should hold: `eval (show (x)) = x`. In some cases\n//. parens are necessary to ensure correct interpretation (`{}`, for example,\n//. is an empty block rather than an empty object in some contexts). Thus the\n//. property is more accurately stated `eval ('(' + show (x) + ')') = x`.\n//.\n//. One can make values of a custom type compatible with [`show`](#show) by\n//. defining a `@@show` method. For example:\n//.\n//. ```javascript\n//. //# Maybe#@@show :: Maybe a ~> () -> String\n//. //.\n//. //. ```javascript\n//. //. > show (Nothing)\n//. //. 'Nothing'\n//. //.\n//. //. > show (Just (['foo', 'bar', 'baz']))\n//. //. 'Just ([\"foo\", \"bar\", \"baz\"])'\n//. //. ```\n//. Maybe.prototype['@@show'] = function() {\n//.   return this.isNothing ? 'Nothing' : 'Just (' + show (this.value) + ')';\n//. };\n//. ```\n\n(function(f) {\n\n  /* istanbul ignore else */\n  {\n    module.exports = f();\n  }\n\n}(function() {\n\n  //  $$show :: String\n  var $$show = '@@show';\n\n  //  seen :: Array Any\n  var seen = [];\n\n  //  entry :: Object -> String -> String\n  function entry(o) {\n    return function(k) {\n      return show(k) + ': ' + show(o[k]);\n    };\n  }\n\n  //# show :: Showable a => a -> String\n  //.\n  //. Returns a useful string representation of the given value.\n  //.\n  //. Dispatches to the value's `@@show` method if present.\n  //.\n  //. Where practical, `show (eval ('(' + show (x) + ')')) = show (x)`.\n  //.\n  //. ```javascript\n  //. > show (null)\n  //. 'null'\n  //.\n  //. > show (undefined)\n  //. 'undefined'\n  //.\n  //. > show (true)\n  //. 'true'\n  //.\n  //. > show (new Boolean (false))\n  //. 'new Boolean (false)'\n  //.\n  //. > show (-0)\n  //. '-0'\n  //.\n  //. > show (NaN)\n  //. 'NaN'\n  //.\n  //. > show (new Number (Infinity))\n  //. 'new Number (Infinity)'\n  //.\n  //. > show ('foo\\n\"bar\"\\nbaz\\n')\n  //. '\"foo\\\\n\\\\\"bar\\\\\"\\\\nbaz\\\\n\"'\n  //.\n  //. > show (new String (''))\n  //. 'new String (\"\")'\n  //.\n  //. > show (['foo', 'bar', 'baz'])\n  //. '[\"foo\", \"bar\", \"baz\"]'\n  //.\n  //. > show ([[[[[0]]]]])\n  //. '[[[[[0]]]]]'\n  //.\n  //. > show ({x: [1, 2], y: [3, 4], z: [5, 6]})\n  //. '{\"x\": [1, 2], \"y\": [3, 4], \"z\": [5, 6]}'\n  //. ```\n  function show(x) {\n    if (seen.indexOf(x) >= 0) return '<Circular>';\n\n    switch (Object.prototype.toString.call(x)) {\n\n      case '[object Boolean]':\n        return typeof x === 'object' ?\n          'new Boolean (' + show(x.valueOf()) + ')' :\n          x.toString();\n\n      case '[object Number]':\n        return typeof x === 'object' ?\n          'new Number (' + show(x.valueOf()) + ')' :\n          1 / x === -Infinity ? '-0' : x.toString(10);\n\n      case '[object String]':\n        return typeof x === 'object' ?\n          'new String (' + show(x.valueOf()) + ')' :\n          JSON.stringify(x);\n\n      case '[object Date]':\n        return 'new Date (' +\n               show(isNaN(x.valueOf()) ? NaN : x.toISOString()) +\n               ')';\n\n      case '[object Error]':\n        return 'new ' + x.name + ' (' + show(x.message) + ')';\n\n      case '[object Arguments]':\n        return 'function () { return arguments; } (' +\n               Array.prototype.map.call(x, show).join(', ') +\n               ')';\n\n      case '[object Array]':\n        seen.push(x);\n        try {\n          return '[' + x.map(show).concat(\n            Object.keys(x)\n            .sort()\n            .filter(function(k) { return !/^\\d+$/.test(k); })\n            .map(entry(x))\n          ).join(', ') + ']';\n        } finally {\n          seen.pop();\n        }\n\n      case '[object Object]':\n        seen.push(x);\n        try {\n          return (\n            $$show in x &&\n            (x.constructor == null || x.constructor.prototype !== x) ?\n              x[$$show]() :\n              '{' + Object.keys(x).sort().map(entry(x)).join(', ') + '}'\n          );\n        } finally {\n          seen.pop();\n        }\n\n      default:\n        return String(x);\n\n    }\n  }\n\n  return show;\n\n}));\n});\n\nvar sanctuaryTypeIdentifiers = createCommonjsModule(function (module) {\n/*\n        @@@@@@@            @@@@@@@         @@\n      @@       @@        @@       @@      @@@\n    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@\n   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@\n    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@\n      @@                 @@                           @@  @@\n        @@@@@@@            @@@@@@@               @@@@@    @@\n                                                          */\n//. # sanctuary-type-identifiers\n//.\n//. A type is a set of values. Boolean, for example, is the type comprising\n//. `true` and `false`. A value may be a member of multiple types (`42` is a\n//. member of Number, PositiveNumber, Integer, and many other types).\n//.\n//. In certain situations it is useful to divide JavaScript values into\n//. non-overlapping types. The language provides two constructs for this\n//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].\n//. Each has pros and cons, but neither supports user-defined types.\n//.\n//. sanctuary-type-identifiers comprises:\n//.\n//.   - an npm and browser -compatible package for deriving the\n//.     _type identifier_ of a JavaScript value; and\n//.   - a specification which authors may follow to specify type\n//.     identifiers for their types.\n//.\n//. ### Specification\n//.\n//. For a type to be compatible with the algorithm:\n//.\n//.   - every member of the type MUST have a `constructor` property\n//.     pointing to an object known as the _type representative_;\n//.\n//.   - the type representative MUST have a `@@type` property\n//.     (the _type identifier_); and\n//.\n//.   - the type identifier MUST be a string primitive and SHOULD have\n//.     format `'<namespace>/<name>[@<version>]'`, where:\n//.\n//.       - `<namespace>` MUST consist of one or more characters, and\n//.         SHOULD equal the name of the npm package which defines the\n//.         type (including [scope][3] where appropriate);\n//.\n//.       - `<name>` MUST consist of one or more characters, and SHOULD\n//.         be the unique name of the type; and\n//.\n//.       - `<version>` MUST consist of one or more digits, and SHOULD\n//.         represent the version of the type.\n//.\n//. If the type identifier does not conform to the format specified above,\n//. it is assumed that the entire string represents the _name_ of the type;\n//. _namespace_ will be `null` and _version_ will be `0`.\n//.\n//. If the _version_ is not given, it is assumed to be `0`.\n//.\n//. For example:\n//.\n//. ```javascript\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   if (!(this instanceof Identity)) return new Identity(x);\n//.   this.value = x;\n//. }\n//.\n//. Identity['@@type'] = 'my-package/Identity';\n//. ```\n//.\n//. Note that by using a constructor function the `constructor` property is set\n//. implicitly for each value created. Constructor functions are convenient for\n//. this reason, but are not required. This definition is also valid:\n//.\n//. ```javascript\n//. //  IdentityTypeRep :: TypeRep Identity\n//. var IdentityTypeRep = {\n//.   '@@type': 'my-package/Identity'\n//. };\n//.\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   return {constructor: IdentityTypeRep, value: x};\n//. }\n//. ```\n\n(function(f) {\n\n  {\n    module.exports = f();\n  }\n\n}(function() {\n\n  //  $$type :: String\n  var $$type = '@@type';\n\n  //  pattern :: RegExp\n  var pattern = new RegExp(\n    '^'\n  + '([\\\\s\\\\S]+)'   //  <namespace>\n  + '/'             //  SOLIDUS (U+002F)\n  + '([\\\\s\\\\S]+?)'  //  <name>\n  + '(?:'           //  optional non-capturing group {\n  +   '@'           //    COMMERCIAL AT (U+0040)\n  +   '([0-9]+)'    //    <version>\n  + ')?'            //  }\n  + '$'\n  );\n\n  //. ### Usage\n  //.\n  //. ```javascript\n  //. const type = require('sanctuary-type-identifiers');\n  //. ```\n  //.\n  //. ```javascript\n  //. > function Identity(x) {\n  //. .   if (!(this instanceof Identity)) return new Identity(x);\n  //. .   this.value = x;\n  //. . }\n  //. . Identity['@@type'] = 'my-package/Identity@1';\n  //.\n  //. > type.parse(type(Identity(0)))\n  //. {namespace: 'my-package', name: 'Identity', version: 1}\n  //. ```\n  //.\n  //. ### API\n  //.\n  //# type :: Any -> String\n  //.\n  //. Takes any value and returns a string which identifies its type. If the\n  //. value conforms to the [specification][4], the custom type identifier is\n  //. returned.\n  //.\n  //. ```javascript\n  //. > type(null)\n  //. 'Null'\n  //.\n  //. > type(true)\n  //. 'Boolean'\n  //.\n  //. > type(Identity(0))\n  //. 'my-package/Identity@1'\n  //. ```\n  function type(x) {\n    return x != null &&\n           x.constructor != null &&\n           x.constructor.prototype !== x &&\n           typeof x.constructor[$$type] === 'string' ?\n      x.constructor[$$type] :\n      Object.prototype.toString.call(x).slice('[object '.length, -']'.length);\n  }\n\n  //# type.parse :: String -> { namespace :: Nullable String, name :: String, version :: Number }\n  //.\n  //. Takes any string and parses it according to the [specification][4],\n  //. returning an object with `namespace`, `name`, and `version` fields.\n  //.\n  //. ```javascript\n  //. > type.parse('my-package/List@2')\n  //. {namespace: 'my-package', name: 'List', version: 2}\n  //.\n  //. > type.parse('nonsense!')\n  //. {namespace: null, name: 'nonsense!', version: 0}\n  //.\n  //. > type.parse(Identity['@@type'])\n  //. {namespace: 'my-package', name: 'Identity', version: 1}\n  //. ```\n  type.parse = function parse(s) {\n    var groups = pattern.exec(s);\n    return {\n      namespace: groups == null || groups[1] == null ? null : groups[1],\n      name:      groups == null                      ? s    : groups[2],\n      version:   groups == null || groups[3] == null ? 0    : Number(groups[3])\n    };\n  };\n\n  return type;\n\n}));\n\n//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n//. [3]: https://docs.npmjs.com/misc/scope\n//. [4]: #specification\n});\n\nvar sanctuaryTypeClasses = createCommonjsModule(function (module) {\n/*\n             ############                  #\n            ############                  ###\n                  #####                  #####\n                #####      ####################\n              #####       ######################\n            #####                     ###########\n          #####         ######################\n        #####          ####################\n      #####                        #####\n     ############                 ###\n    ############                 */\n\n//. # sanctuary-type-classes\n//.\n//. The [Fantasy Land Specification][FL] \"specifies interoperability of common\n//. algebraic structures\" by defining a number of type classes. For each type\n//. class, it states laws which every member of a type must obey in order for\n//. the type to be a member of the type class. In order for the Maybe type to\n//. be considered a [Functor][], for example, every `Maybe a` value must have\n//. a `fantasy-land/map` method which obeys the identity and composition laws.\n//.\n//. This project provides:\n//.\n//.   - [`TypeClass`](#TypeClass), a function for defining type classes;\n//.   - one `TypeClass` value for each Fantasy Land type class;\n//.   - lawful Fantasy Land methods for JavaScript's built-in types;\n//.   - one function for each Fantasy Land method; and\n//.   - several functions derived from these functions.\n//.\n//. ## Type-class hierarchy\n//.\n/* eslint-disable max-len */\n//. <pre>\n//.  Setoid   Semigroupoid  Semigroup   Foldable        Functor      Contravariant  Filterable\n//. (equals)    (compose)    (concat)   (reduce)         (map)        (contramap)    (filter)\n//.     |           |           |           \\         / | | | | \\\n//.     |           |           |            \\       /  | | | |  \\\n//.     |           |           |             \\     /   | | | |   \\\n//.     |           |           |              \\   /    | | | |    \\\n//.     |           |           |               \\ /     | | | |     \\\n//.    Ord      Category     Monoid         Traversable | | | |      \\\n//.   (lte)       (id)       (empty)        (traverse)  / | | \\       \\\n//.                             |                      /  | |  \\       \\\n//.                             |                     /   / \\   \\       \\\n//.                             |             Profunctor /   \\ Bifunctor \\\n//.                             |              (promap) /     \\ (bimap)   \\\n//.                             |                      /       \\           \\\n//.                           Group                   /         \\           \\\n//.                          (invert)               Alt        Apply      Extend\n//.                                                (alt)        (ap)     (extend)\n//.                                                 /           / \\           \\\n//.                                                /           /   \\           \\\n//.                                               /           /     \\           \\\n//.                                              /           /       \\           \\\n//.                                             /           /         \\           \\\n//.                                           Plus    Applicative    Chain      Comonad\n//.                                          (zero)       (of)      (chain)    (extract)\n//.                                             \\         / \\         / \\\n//.                                              \\       /   \\       /   \\\n//.                                               \\     /     \\     /     \\\n//.                                                \\   /       \\   /       \\\n//.                                                 \\ /         \\ /         \\\n//.                                             Alternative    Monad     ChainRec\n//.                                                                     (chainRec)\n//. </pre>\n/* eslint-enable max-len */\n//.\n//. ## API\n\n(function(f) {\n\n  /* istanbul ignore else */\n  {\n    module.exports = f (sanctuaryTypeIdentifiers);\n  }\n\n} (function(type) {\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    /* eslint-disable no-unused-vars */\n    var Identity = __doctest.require ('sanctuary-identity');\n    var List = __doctest.require ('./test/List');\n    var Maybe = __doctest.require ('sanctuary-maybe');\n    var Pair = __doctest.require ('sanctuary-pair');\n    var Sum = __doctest.require ('./test/Sum');\n\n    var Nil = List.Nil, Cons = List.Cons;\n    var Nothing = Maybe.Nothing, Just = Maybe.Just;\n    /* eslint-enable no-unused-vars */\n  }\n\n  //  concat_ :: Array a -> Array a -> Array a\n  function concat_(xs) {\n    return function(ys) {\n      return xs.concat (ys);\n    };\n  }\n\n  //  constant :: a -> b -> a\n  function constant(x) {\n    return function(y) {\n      return x;\n    };\n  }\n\n  //  forEachKey :: (StrMap a, StrMap a ~> String -> Undefined) -> Undefined\n  function forEachKey(strMap, f) {\n    (Object.keys (strMap)).forEach (f, strMap);\n  }\n\n  //  has :: (String, Object) -> Boolean\n  function has(k, o) {\n    return Object.prototype.hasOwnProperty.call (o, k);\n  }\n\n  //  identity :: a -> a\n  function identity(x) { return x; }\n\n  //  pair :: a -> b -> Array2 a b\n  function pair(x) {\n    return function(y) {\n      return [x, y];\n    };\n  }\n\n  //  sameType :: (a, b) -> Boolean\n  function sameType(x, y) {\n    return typeof x === typeof y && type (x) === type (y);\n  }\n\n  //  sortedKeys :: Object -> Array String\n  function sortedKeys(o) {\n    return (Object.keys (o)).sort ();\n  }\n\n  //  thrush :: a -> (a -> b) -> b\n  function thrush(x) {\n    return function(f) {\n      return f (x);\n    };\n  }\n\n  //  unary :: (a -> b) -> (a, Any...) -> b\n  function unary(f) {\n    return function(x) {\n      return f (x);\n    };\n  }\n\n  //  type Iteration a = { value :: a, done :: Boolean }\n\n  //  iterationNext :: a -> Iteration a\n  function iterationNext(x) { return {value: x, done: false}; }\n\n  //  iterationDone :: a -> Iteration a\n  function iterationDone(x) { return {value: x, done: true}; }\n\n  //# TypeClass :: (String, String, Array TypeClass, a -> Boolean) -> TypeClass\n  //.\n  //. The arguments are:\n  //.\n  //.   - the name of the type class, prefixed by its npm package name;\n  //.   - the documentation URL of the type class;\n  //.   - an array of dependencies; and\n  //.   - a predicate which accepts any JavaScript value and returns `true`\n  //.     if the value satisfies the requirements of the type class; `false`\n  //.     otherwise.\n  //.\n  //. Example:\n  //.\n  //. ```javascript\n  //. //    hasMethod :: String -> a -> Boolean\n  //. const hasMethod = name => x => x != null && typeof x[name] == 'function';\n  //.\n  //. //    Foo :: TypeClass\n  //. const Foo = Z.TypeClass (\n  //.   'my-package/Foo',\n  //.   'http://example.com/my-package#Foo',\n  //.   [],\n  //.   hasMethod ('foo')\n  //. );\n  //.\n  //. //    Bar :: TypeClass\n  //. const Bar = Z.TypeClass (\n  //.   'my-package/Bar',\n  //.   'http://example.com/my-package#Bar',\n  //.   [Foo],\n  //.   hasMethod ('bar')\n  //. );\n  //. ```\n  //.\n  //. Types whose values have a `foo` method are members of the Foo type class.\n  //. Members of the Foo type class whose values have a `bar` method are also\n  //. members of the Bar type class.\n  //.\n  //. Each `TypeClass` value has a `test` field: a function which accepts\n  //. any JavaScript value and returns `true` if the value satisfies the\n  //. type class's predicate and the predicates of all the type class's\n  //. dependencies; `false` otherwise.\n  //.\n  //. `TypeClass` values may be used with [sanctuary-def][type-classes]\n  //. to define parametrically polymorphic functions which verify their\n  //. type-class constraints at run time.\n  function TypeClass(name, url, dependencies, test) {\n    if (!(this instanceof TypeClass)) {\n      return new TypeClass (name, url, dependencies, test);\n    }\n    this.name = name;\n    this.url = url;\n    this.test = function(x) {\n      return dependencies.every (function(d) { return d.test (x); }) &&\n             test (x);\n    };\n  }\n\n  TypeClass['@@type'] = 'sanctuary-type-classes/TypeClass@1';\n\n  //  data Location = Constructor | Value\n\n  //  Constructor :: Location\n  var Constructor = 'Constructor';\n\n  //  Value :: Location\n  var Value = 'Value';\n\n  //  _funcPath :: (Boolean, Array String, a) -> Nullable Function\n  function _funcPath(allowInheritedProps, path, _x) {\n    var x = _x;\n    for (var idx = 0; idx < path.length; idx += 1) {\n      var k = path[idx];\n      if (x == null || !(allowInheritedProps || has (k, x))) return null;\n      x = x[k];\n    }\n    return typeof x === 'function' ? x : null;\n  }\n\n  //  funcPath :: (Array String, a) -> Nullable Function\n  function funcPath(path, x) {\n    return _funcPath (true, path, x);\n  }\n\n  //  implPath :: Array String -> Nullable Function\n  function implPath(path) {\n    return _funcPath (false, path, implementations);\n  }\n\n  //  functionName :: Function -> String\n  var functionName = has ('name', function f() {}) ?\n    function functionName(f) { return f.name; } :\n    /* istanbul ignore next */\n    function functionName(f) {\n      var match = /function (\\w*)/.exec (f);\n      return match == null ? '' : match[1];\n    };\n\n  //  $ :: (String, Array TypeClass, StrMap (Array Location)) -> TypeClass\n  function $(_name, dependencies, requirements) {\n    function getBoundMethod(_name) {\n      var name = 'fantasy-land/' + _name;\n      return requirements[_name] === Constructor ?\n        function(typeRep) {\n          var f = funcPath ([name], typeRep);\n          return f == null && typeof typeRep === 'function' ?\n            implPath ([functionName (typeRep), name]) :\n            f;\n        } :\n        function(x) {\n          var isPrototype = x != null &&\n                            x.constructor != null &&\n                            x.constructor.prototype === x;\n          var m = null;\n          if (!isPrototype) m = funcPath ([name], x);\n          if (m == null)    m = implPath ([type (x), 'prototype', name]);\n          return m && m.bind (x);\n        };\n    }\n\n    var version = '11.0.0';  // updated programmatically\n    var keys = Object.keys (requirements);\n\n    var typeClass = TypeClass (\n      'sanctuary-type-classes/' + _name,\n      'https://github.com/sanctuary-js/sanctuary-type-classes/tree/v' + version\n        + '#' + _name,\n      dependencies,\n      function(x) {\n        return keys.every (function(_name) {\n          var arg = requirements[_name] === Constructor ? x.constructor : x;\n          return getBoundMethod (_name) (arg) != null;\n        });\n      }\n    );\n\n    typeClass.methods = keys.reduce (function(methods, _name) {\n      methods[_name] = getBoundMethod (_name);\n      return methods;\n    }, {});\n\n    return typeClass;\n  }\n\n  //# Setoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Setoid][].\n  //.\n  //. ```javascript\n  //. > Setoid.test (null)\n  //. true\n  //. ```\n  var Setoid = $ ('Setoid', [], {equals: Value});\n\n  //# Ord :: TypeClass\n  //.\n  //. `TypeClass` value for [Ord][].\n  //.\n  //. ```javascript\n  //. > Ord.test (0)\n  //. true\n  //.\n  //. > Ord.test (Math.sqrt)\n  //. false\n  //. ```\n  var Ord = $ ('Ord', [Setoid], {lte: Value});\n\n  //# Semigroupoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroupoid][].\n  //.\n  //. ```javascript\n  //. > Semigroupoid.test (Math.sqrt)\n  //. true\n  //.\n  //. > Semigroupoid.test (0)\n  //. false\n  //. ```\n  var Semigroupoid = $ ('Semigroupoid', [], {compose: Value});\n\n  //# Category :: TypeClass\n  //.\n  //. `TypeClass` value for [Category][].\n  //.\n  //. ```javascript\n  //. > Category.test (Math.sqrt)\n  //. true\n  //.\n  //. > Category.test (0)\n  //. false\n  //. ```\n  var Category = $ ('Category', [Semigroupoid], {id: Constructor});\n\n  //# Semigroup :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroup][].\n  //.\n  //. ```javascript\n  //. > Semigroup.test ('')\n  //. true\n  //.\n  //. > Semigroup.test (0)\n  //. false\n  //. ```\n  var Semigroup = $ ('Semigroup', [], {concat: Value});\n\n  //# Monoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Monoid][].\n  //.\n  //. ```javascript\n  //. > Monoid.test ('')\n  //. true\n  //.\n  //. > Monoid.test (0)\n  //. false\n  //. ```\n  var Monoid = $ ('Monoid', [Semigroup], {empty: Constructor});\n\n  //# Group :: TypeClass\n  //.\n  //. `TypeClass` value for [Group][].\n  //.\n  //. ```javascript\n  //. > Group.test (Sum (0))\n  //. true\n  //.\n  //. > Group.test ('')\n  //. false\n  //. ```\n  var Group = $ ('Group', [Monoid], {invert: Value});\n\n  //# Filterable :: TypeClass\n  //.\n  //. `TypeClass` value for [Filterable][].\n  //.\n  //. ```javascript\n  //. > Filterable.test ({})\n  //. true\n  //.\n  //. > Filterable.test ('')\n  //. false\n  //. ```\n  var Filterable = $ ('Filterable', [], {filter: Value});\n\n  //# Functor :: TypeClass\n  //.\n  //. `TypeClass` value for [Functor][].\n  //.\n  //. ```javascript\n  //. > Functor.test ([])\n  //. true\n  //.\n  //. > Functor.test ('')\n  //. false\n  //. ```\n  var Functor = $ ('Functor', [], {map: Value});\n\n  //# Bifunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Bifunctor][].\n  //.\n  //. ```javascript\n  //. > Bifunctor.test (Pair ('foo') (64))\n  //. true\n  //.\n  //. > Bifunctor.test ([])\n  //. false\n  //. ```\n  var Bifunctor = $ ('Bifunctor', [Functor], {bimap: Value});\n\n  //# Profunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Profunctor][].\n  //.\n  //. ```javascript\n  //. > Profunctor.test (Math.sqrt)\n  //. true\n  //.\n  //. > Profunctor.test ([])\n  //. false\n  //. ```\n  var Profunctor = $ ('Profunctor', [Functor], {promap: Value});\n\n  //# Apply :: TypeClass\n  //.\n  //. `TypeClass` value for [Apply][].\n  //.\n  //. ```javascript\n  //. > Apply.test ([])\n  //. true\n  //.\n  //. > Apply.test ('')\n  //. false\n  //. ```\n  var Apply = $ ('Apply', [Functor], {ap: Value});\n\n  //# Applicative :: TypeClass\n  //.\n  //. `TypeClass` value for [Applicative][].\n  //.\n  //. ```javascript\n  //. > Applicative.test ([])\n  //. true\n  //.\n  //. > Applicative.test ({})\n  //. false\n  //. ```\n  var Applicative = $ ('Applicative', [Apply], {of: Constructor});\n\n  //# Chain :: TypeClass\n  //.\n  //. `TypeClass` value for [Chain][].\n  //.\n  //. ```javascript\n  //. > Chain.test ([])\n  //. true\n  //.\n  //. > Chain.test ({})\n  //. false\n  //. ```\n  var Chain = $ ('Chain', [Apply], {chain: Value});\n\n  //# ChainRec :: TypeClass\n  //.\n  //. `TypeClass` value for [ChainRec][].\n  //.\n  //. ```javascript\n  //. > ChainRec.test ([])\n  //. true\n  //.\n  //. > ChainRec.test ({})\n  //. false\n  //. ```\n  var ChainRec = $ ('ChainRec', [Chain], {chainRec: Constructor});\n\n  //# Monad :: TypeClass\n  //.\n  //. `TypeClass` value for [Monad][].\n  //.\n  //. ```javascript\n  //. > Monad.test ([])\n  //. true\n  //.\n  //. > Monad.test ({})\n  //. false\n  //. ```\n  var Monad = $ ('Monad', [Applicative, Chain], {});\n\n  //# Alt :: TypeClass\n  //.\n  //. `TypeClass` value for [Alt][].\n  //.\n  //. ```javascript\n  //. > Alt.test ({})\n  //. true\n  //.\n  //. > Alt.test ('')\n  //. false\n  //. ```\n  var Alt = $ ('Alt', [Functor], {alt: Value});\n\n  //# Plus :: TypeClass\n  //.\n  //. `TypeClass` value for [Plus][].\n  //.\n  //. ```javascript\n  //. > Plus.test ({})\n  //. true\n  //.\n  //. > Plus.test ('')\n  //. false\n  //. ```\n  var Plus = $ ('Plus', [Alt], {zero: Constructor});\n\n  //# Alternative :: TypeClass\n  //.\n  //. `TypeClass` value for [Alternative][].\n  //.\n  //. ```javascript\n  //. > Alternative.test ([])\n  //. true\n  //.\n  //. > Alternative.test ({})\n  //. false\n  //. ```\n  var Alternative = $ ('Alternative', [Applicative, Plus], {});\n\n  //# Foldable :: TypeClass\n  //.\n  //. `TypeClass` value for [Foldable][].\n  //.\n  //. ```javascript\n  //. > Foldable.test ({})\n  //. true\n  //.\n  //. > Foldable.test ('')\n  //. false\n  //. ```\n  var Foldable = $ ('Foldable', [], {reduce: Value});\n\n  //# Traversable :: TypeClass\n  //.\n  //. `TypeClass` value for [Traversable][].\n  //.\n  //. ```javascript\n  //. > Traversable.test ([])\n  //. true\n  //.\n  //. > Traversable.test ('')\n  //. false\n  //. ```\n  var Traversable = $ ('Traversable', [Functor, Foldable], {traverse: Value});\n\n  //# Extend :: TypeClass\n  //.\n  //. `TypeClass` value for [Extend][].\n  //.\n  //. ```javascript\n  //. > Extend.test ([])\n  //. true\n  //.\n  //. > Extend.test ({})\n  //. false\n  //. ```\n  var Extend = $ ('Extend', [Functor], {extend: Value});\n\n  //# Comonad :: TypeClass\n  //.\n  //. `TypeClass` value for [Comonad][].\n  //.\n  //. ```javascript\n  //. > Comonad.test (Identity (0))\n  //. true\n  //.\n  //. > Comonad.test ([])\n  //. false\n  //. ```\n  var Comonad = $ ('Comonad', [Extend], {extract: Value});\n\n  //# Contravariant :: TypeClass\n  //.\n  //. `TypeClass` value for [Contravariant][].\n  //.\n  //. ```javascript\n  //. > Contravariant.test (Math.sqrt)\n  //. true\n  //.\n  //. > Contravariant.test ([])\n  //. false\n  //. ```\n  var Contravariant = $ ('Contravariant', [], {contramap: Value});\n\n  //  Null$prototype$equals :: Null ~> Null -> Boolean\n  function Null$prototype$equals(other) {\n    return true;\n  }\n\n  //  Null$prototype$lte :: Null ~> Null -> Boolean\n  function Null$prototype$lte(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$equals :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$equals(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$lte :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$lte(other) {\n    return true;\n  }\n\n  //  Boolean$prototype$equals :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals (this.valueOf (), other.valueOf ()) :\n      this === other;\n  }\n\n  //  Boolean$prototype$lte :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte (this.valueOf (), other.valueOf ()) :\n      this === false || other === true;\n  }\n\n  //  Number$prototype$equals :: Number ~> Number -> Boolean\n  function Number$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals (this.valueOf (), other.valueOf ()) :\n      isNaN (this) && isNaN (other) || this === other;\n  }\n\n  //  Number$prototype$lte :: Number ~> Number -> Boolean\n  function Number$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte (this.valueOf (), other.valueOf ()) :\n      isNaN (this) || this <= other;\n  }\n\n  //  Date$prototype$equals :: Date ~> Date -> Boolean\n  function Date$prototype$equals(other) {\n    return equals (this.valueOf (), other.valueOf ());\n  }\n\n  //  Date$prototype$lte :: Date ~> Date -> Boolean\n  function Date$prototype$lte(other) {\n    return lte (this.valueOf (), other.valueOf ());\n  }\n\n  //  RegExp$prototype$equals :: RegExp ~> RegExp -> Boolean\n  function RegExp$prototype$equals(other) {\n    return other.source === this.source &&\n           other.global === this.global &&\n           other.ignoreCase === this.ignoreCase &&\n           other.multiline === this.multiline &&\n           other.sticky === this.sticky &&\n           other.unicode === this.unicode;\n  }\n\n  //  String$empty :: () -> String\n  function String$empty() {\n    return '';\n  }\n\n  //  String$prototype$equals :: String ~> String -> Boolean\n  function String$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals (this.valueOf (), other.valueOf ()) :\n      this === other;\n  }\n\n  //  String$prototype$lte :: String ~> String -> Boolean\n  function String$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte (this.valueOf (), other.valueOf ()) :\n      this <= other;\n  }\n\n  //  String$prototype$concat :: String ~> String -> String\n  function String$prototype$concat(other) {\n    return this + other;\n  }\n\n  //  Array$empty :: () -> Array a\n  function Array$empty() {\n    return [];\n  }\n\n  //  Array$of :: a -> Array a\n  function Array$of(x) {\n    return [x];\n  }\n\n  //  Array$chainRec :: ((a -> c, b -> c, a) -> Array c, a) -> Array b\n  function Array$chainRec(f, x) {\n    var result = [];\n    var nil = {};\n    var todo = {head: x, tail: nil};\n    while (todo !== nil) {\n      var more = nil;\n      var steps = f (iterationNext, iterationDone, todo.head);\n      for (var idx = 0; idx < steps.length; idx += 1) {\n        var step = steps[idx];\n        if (step.done) {\n          result.push (step.value);\n        } else {\n          more = {head: step.value, tail: more};\n        }\n      }\n      todo = todo.tail;\n      while (more !== nil) {\n        todo = {head: more.head, tail: todo};\n        more = more.tail;\n      }\n    }\n    return result;\n  }\n\n  //  Array$zero :: () -> Array a\n  function Array$zero() {\n    return [];\n  }\n\n  //  Array$prototype$equals :: Array a ~> Array a -> Boolean\n  function Array$prototype$equals(other) {\n    if (other.length !== this.length) return false;\n    for (var idx = 0; idx < this.length; idx += 1) {\n      if (!(equals (this[idx], other[idx]))) return false;\n    }\n    return true;\n  }\n\n  //  Array$prototype$lte :: Array a ~> Array a -> Boolean\n  function Array$prototype$lte(other) {\n    for (var idx = 0; true; idx += 1) {\n      if (idx === this.length) return true;\n      if (idx === other.length) return false;\n      if (!(equals (this[idx], other[idx]))) {\n        return lte (this[idx], other[idx]);\n      }\n    }\n  }\n\n  //  Array$prototype$concat :: Array a ~> Array a -> Array a\n  function Array$prototype$concat(other) {\n    return this.concat (other);\n  }\n\n  //  Array$prototype$filter :: Array a ~> (a -> Boolean) -> Array a\n  function Array$prototype$filter(pred) {\n    return this.filter (function(x) { return pred (x); });\n  }\n\n  //  Array$prototype$map :: Array a ~> (a -> b) -> Array b\n  function Array$prototype$map(f) {\n    return this.map (function(x) { return f (x); });\n  }\n\n  //  Array$prototype$ap :: Array a ~> Array (a -> b) -> Array b\n  function Array$prototype$ap(fs) {\n    var result = [];\n    for (var idx = 0; idx < fs.length; idx += 1) {\n      for (var idx2 = 0; idx2 < this.length; idx2 += 1) {\n        result.push (fs[idx] (this[idx2]));\n      }\n    }\n    return result;\n  }\n\n  //  Array$prototype$chain :: Array a ~> (a -> Array b) -> Array b\n  function Array$prototype$chain(f) {\n    var result = [];\n    for (var idx = 0; idx < this.length; idx += 1) {\n      for (var idx2 = 0, xs = f (this[idx]); idx2 < xs.length; idx2 += 1) {\n        result.push (xs[idx2]);\n      }\n    }\n    return result;\n  }\n\n  //  Array$prototype$alt :: Array a ~> Array a -> Array a\n  var Array$prototype$alt = Array$prototype$concat;\n\n  //  Array$prototype$reduce :: Array a ~> ((b, a) -> b, b) -> b\n  function Array$prototype$reduce(f, initial) {\n    var acc = initial;\n    for (var idx = 0; idx < this.length; idx += 1) acc = f (acc, this[idx]);\n    return acc;\n  }\n\n  //  Array$prototype$traverse :: Applicative f => Array a ~> (TypeRep f, a -> f b) -> f (Array b)\n  function Array$prototype$traverse(typeRep, f) {\n    var xs = this;\n    function go(idx, n) {\n      switch (n) {\n        case 0: return of (typeRep, []);\n        case 2: return lift2 (pair, f (xs[idx]), f (xs[idx + 1]));\n        default:\n          var m = Math.floor (n / 4) * 2;\n          return lift2 (concat_, go (idx, m), go (idx + m, n - m));\n      }\n    }\n    return this.length % 2 === 1 ?\n      lift2 (concat_, map (Array$of, f (this[0])), go (1, this.length - 1)) :\n      go (0, this.length);\n  }\n\n  //  Array$prototype$extend :: Array a ~> (Array a -> b) -> Array b\n  function Array$prototype$extend(f) {\n    return this.map (function(_, idx, xs) { return f (xs.slice (idx)); });\n  }\n\n  //  Arguments$prototype$equals :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$equals(other) {\n    return Array$prototype$equals.call (this, other);\n  }\n\n  //  Arguments$prototype$lte :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$lte(other) {\n    return Array$prototype$lte.call (this, other);\n  }\n\n  //  Error$prototype$equals :: Error ~> Error -> Boolean\n  function Error$prototype$equals(other) {\n    return equals (this.name, other.name) &&\n           equals (this.message, other.message);\n  }\n\n  //  Object$empty :: () -> StrMap a\n  function Object$empty() {\n    return {};\n  }\n\n  //  Object$zero :: () -> StrMap a\n  function Object$zero() {\n    return {};\n  }\n\n  //  Object$prototype$equals :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$equals(other) {\n    var self = this;\n    var keys = sortedKeys (this);\n    return equals (keys, sortedKeys (other)) &&\n           keys.every (function(k) { return equals (self[k], other[k]); });\n  }\n\n  //  Object$prototype$lte :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$lte(other) {\n    var theseKeys = sortedKeys (this);\n    var otherKeys = sortedKeys (other);\n    while (true) {\n      if (theseKeys.length === 0) return true;\n      if (otherKeys.length === 0) return false;\n      var k = theseKeys.shift ();\n      var z = otherKeys.shift ();\n      if (k < z) return true;\n      if (k > z) return false;\n      if (!(equals (this[k], other[k]))) return lte (this[k], other[k]);\n    }\n  }\n\n  //  Object$prototype$concat :: StrMap a ~> StrMap a -> StrMap a\n  function Object$prototype$concat(other) {\n    var result = {};\n    function assign(k) { result[k] = this[k]; }\n    forEachKey (this, assign);\n    forEachKey (other, assign);\n    return result;\n  }\n\n  //  Object$prototype$filter :: StrMap a ~> (a -> Boolean) -> StrMap a\n  function Object$prototype$filter(pred) {\n    var result = {};\n    forEachKey (this, function(k) {\n      if (pred (this[k])) result[k] = this[k];\n    });\n    return result;\n  }\n\n  //  Object$prototype$map :: StrMap a ~> (a -> b) -> StrMap b\n  function Object$prototype$map(f) {\n    var result = {};\n    forEachKey (this, function(k) { result[k] = f (this[k]); });\n    return result;\n  }\n\n  //  Object$prototype$ap :: StrMap a ~> StrMap (a -> b) -> StrMap b\n  function Object$prototype$ap(other) {\n    var result = {};\n    forEachKey (this, function(k) {\n      if (has (k, other)) result[k] = other[k] (this[k]);\n    });\n    return result;\n  }\n\n  //  Object$prototype$alt :: StrMap a ~> StrMap a -> StrMap a\n  var Object$prototype$alt = Object$prototype$concat;\n\n  //  Object$prototype$reduce :: StrMap a ~> ((b, a) -> b, b) -> b\n  function Object$prototype$reduce(f, initial) {\n    var self = this;\n    function reducer(acc, k) { return f (acc, self[k]); }\n    return (sortedKeys (this)).reduce (reducer, initial);\n  }\n\n  //  Object$prototype$traverse :: Applicative f => StrMap a ~> (TypeRep f, a -> f b) -> f (StrMap b)\n  function Object$prototype$traverse(typeRep, f) {\n    var self = this;\n    return (Object.keys (this)).reduce (function(applicative, k) {\n      function set(o) {\n        return function(v) {\n          var singleton = {}; singleton[k] = v;\n          return Object$prototype$concat.call (o, singleton);\n        };\n      }\n      return lift2 (set, applicative, f (self[k]));\n    }, of (typeRep, {}));\n  }\n\n  //  Function$id :: () -> a -> a\n  function Function$id() {\n    return identity;\n  }\n\n  //  Function$of :: b -> (a -> b)\n  function Function$of(x) {\n    return function(_) { return x; };\n  }\n\n  //  Function$chainRec :: ((a -> c, b -> c, a) -> (z -> c), a) -> (z -> b)\n  function Function$chainRec(f, x) {\n    return function(a) {\n      var step = iterationNext (x);\n      while (!step.done) {\n        step = f (iterationNext, iterationDone, step.value) (a);\n      }\n      return step.value;\n    };\n  }\n\n  //  Function$prototype$equals :: Function ~> Function -> Boolean\n  function Function$prototype$equals(other) {\n    return other === this;\n  }\n\n  //  Function$prototype$compose :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$compose(other) {\n    var semigroupoid = this;\n    return function(x) { return other (semigroupoid (x)); };\n  }\n\n  //  Function$prototype$map :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$map(f) {\n    var functor = this;\n    return function(x) { return f (functor (x)); };\n  }\n\n  //  Function$prototype$promap :: (b -> c) ~> (a -> b, c -> d) -> (a -> d)\n  function Function$prototype$promap(f, g) {\n    var profunctor = this;\n    return function(x) { return g (profunctor (f (x))); };\n  }\n\n  //  Function$prototype$ap :: (a -> b) ~> (a -> b -> c) -> (a -> c)\n  function Function$prototype$ap(f) {\n    var apply = this;\n    return function(x) { return f (x) (apply (x)); };\n  }\n\n  //  Function$prototype$chain :: (a -> b) ~> (b -> a -> c) -> (a -> c)\n  function Function$prototype$chain(f) {\n    var chain = this;\n    return function(x) { return f (chain (x)) (x); };\n  }\n\n  //  Function$prototype$extend :: Semigroup a => (a -> b) ~> ((a -> b) -> c) -> (a -> c)\n  function Function$prototype$extend(f) {\n    var extend = this;\n    return function(x) {\n      return f (function(y) { return extend (concat (x, y)); });\n    };\n  }\n\n  //  Function$prototype$contramap :: (b -> c) ~> (a -> b) -> (a -> c)\n  function Function$prototype$contramap(f) {\n    var contravariant = this;\n    return function(x) { return contravariant (f (x)); };\n  }\n\n  /* eslint-disable key-spacing */\n  var implementations = {\n    Null: {\n      'prototype': {\n        'fantasy-land/equals':      Null$prototype$equals,\n        'fantasy-land/lte':         Null$prototype$lte\n      }\n    },\n    Undefined: {\n      'prototype': {\n        'fantasy-land/equals':      Undefined$prototype$equals,\n        'fantasy-land/lte':         Undefined$prototype$lte\n      }\n    },\n    Boolean: {\n      'prototype': {\n        'fantasy-land/equals':      Boolean$prototype$equals,\n        'fantasy-land/lte':         Boolean$prototype$lte\n      }\n    },\n    Number: {\n      'prototype': {\n        'fantasy-land/equals':      Number$prototype$equals,\n        'fantasy-land/lte':         Number$prototype$lte\n      }\n    },\n    Date: {\n      'prototype': {\n        'fantasy-land/equals':      Date$prototype$equals,\n        'fantasy-land/lte':         Date$prototype$lte\n      }\n    },\n    RegExp: {\n      'prototype': {\n        'fantasy-land/equals':      RegExp$prototype$equals\n      }\n    },\n    String: {\n      'fantasy-land/empty':         String$empty,\n      'prototype': {\n        'fantasy-land/equals':      String$prototype$equals,\n        'fantasy-land/lte':         String$prototype$lte,\n        'fantasy-land/concat':      String$prototype$concat\n      }\n    },\n    Array: {\n      'fantasy-land/empty':         Array$empty,\n      'fantasy-land/of':            Array$of,\n      'fantasy-land/chainRec':      Array$chainRec,\n      'fantasy-land/zero':          Array$zero,\n      'prototype': {\n        'fantasy-land/equals':      Array$prototype$equals,\n        'fantasy-land/lte':         Array$prototype$lte,\n        'fantasy-land/concat':      Array$prototype$concat,\n        'fantasy-land/filter':      Array$prototype$filter,\n        'fantasy-land/map':         Array$prototype$map,\n        'fantasy-land/ap':          Array$prototype$ap,\n        'fantasy-land/chain':       Array$prototype$chain,\n        'fantasy-land/alt':         Array$prototype$alt,\n        'fantasy-land/reduce':      Array$prototype$reduce,\n        'fantasy-land/traverse':    Array$prototype$traverse,\n        'fantasy-land/extend':      Array$prototype$extend\n      }\n    },\n    Arguments: {\n      'prototype': {\n        'fantasy-land/equals':      Arguments$prototype$equals,\n        'fantasy-land/lte':         Arguments$prototype$lte\n      }\n    },\n    Error: {\n      'prototype': {\n        'fantasy-land/equals':      Error$prototype$equals\n      }\n    },\n    Object: {\n      'fantasy-land/empty':         Object$empty,\n      'fantasy-land/zero':          Object$zero,\n      'prototype': {\n        'fantasy-land/equals':      Object$prototype$equals,\n        'fantasy-land/lte':         Object$prototype$lte,\n        'fantasy-land/concat':      Object$prototype$concat,\n        'fantasy-land/filter':      Object$prototype$filter,\n        'fantasy-land/map':         Object$prototype$map,\n        'fantasy-land/ap':          Object$prototype$ap,\n        'fantasy-land/alt':         Object$prototype$alt,\n        'fantasy-land/reduce':      Object$prototype$reduce,\n        'fantasy-land/traverse':    Object$prototype$traverse\n      }\n    },\n    Function: {\n      'fantasy-land/id':            Function$id,\n      'fantasy-land/of':            Function$of,\n      'fantasy-land/chainRec':      Function$chainRec,\n      'prototype': {\n        'fantasy-land/equals':      Function$prototype$equals,\n        'fantasy-land/compose':     Function$prototype$compose,\n        'fantasy-land/map':         Function$prototype$map,\n        'fantasy-land/promap':      Function$prototype$promap,\n        'fantasy-land/ap':          Function$prototype$ap,\n        'fantasy-land/chain':       Function$prototype$chain,\n        'fantasy-land/extend':      Function$prototype$extend,\n        'fantasy-land/contramap':   Function$prototype$contramap\n      }\n    }\n  };\n  /* eslint-enable key-spacing */\n\n  //# equals :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and equal according\n  //. to the type's [`fantasy-land/equals`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/equals` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, RegExp, String,\n  //. Array, Arguments, Error, Object, and Function.\n  //.\n  //. The algorithm supports circular data structures. Two arrays are equal\n  //. if they have the same index paths and for each path have equal values.\n  //. Two arrays which represent `[1, [1, [1, [1, [1, ...]]]]]`, for example,\n  //. are equal even if their internal structures differ. Two objects are equal\n  //. if they have the same property paths and for each path have equal values.\n  //.\n  //. ```javascript\n  //. > equals (0, -0)\n  //. true\n  //.\n  //. > equals (NaN, NaN)\n  //. true\n  //.\n  //. > equals (Cons (1, Cons (2, Nil)), Cons (1, Cons (2, Nil)))\n  //. true\n  //.\n  //. > equals (Cons (1, Cons (2, Nil)), Cons (2, Cons (1, Nil)))\n  //. false\n  //. ```\n  var equals = (function() {\n    //  $pairs :: Array (Array2 Any Any)\n    var $pairs = [];\n\n    return function equals(x, y) {\n      if (!(sameType (x, y))) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some (function(p) { return p[0] === x && p[1] === y; })) {\n        return true;\n      }\n\n      $pairs.push ([x, y]);\n      try {\n        return Setoid.test (x) &&\n               Setoid.test (y) &&\n               Setoid.methods.equals (x) (y);\n      } finally {\n        $pairs.pop ();\n      }\n    };\n  } ());\n\n  //# lt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. less than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`gt`](#gt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lt (0, 0)\n  //. false\n  //.\n  //. > lt (0, 1)\n  //. true\n  //.\n  //. > lt (1, 0)\n  //. false\n  //. ```\n  function lt(x, y) {\n    return sameType (x, y) && !(lte (y, x));\n  }\n\n  //# lte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is less than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/lte` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, String, Array,\n  //. Arguments, and Object.\n  //.\n  //. The algorithm supports circular data structures in the same manner as\n  //. [`equals`](#equals).\n  //.\n  //. See also [`lt`](#lt), [`gt`](#gt), and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lte (0, 0)\n  //. true\n  //.\n  //. > lte (0, 1)\n  //. true\n  //.\n  //. > lte (1, 0)\n  //. false\n  //. ```\n  var lte = (function() {\n    //  $pairs :: Array (Array2 Any Any)\n    var $pairs = [];\n\n    return function lte(x, y) {\n      if (!(sameType (x, y))) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some (function(p) { return p[0] === x && p[1] === y; })) {\n        return equals (x, y);\n      }\n\n      $pairs.push ([x, y]);\n      try {\n        return Ord.test (x) && Ord.test (y) && Ord.methods.lte (x) (y);\n      } finally {\n        $pairs.pop ();\n      }\n    };\n  } ());\n\n  //# gt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. greater than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > gt (0, 0)\n  //. false\n  //.\n  //. > gt (0, 1)\n  //. false\n  //.\n  //. > gt (1, 0)\n  //. true\n  //. ```\n  function gt(x, y) {\n    return lt (y, x);\n  }\n\n  //# gte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is greater than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gt`](#gt).\n  //.\n  //. ```javascript\n  //. > gte (0, 0)\n  //. true\n  //.\n  //. > gte (0, 1)\n  //. false\n  //.\n  //. > gte (1, 0)\n  //. true\n  //. ```\n  function gte(x, y) {\n    return lte (y, x);\n  }\n\n  //# min :: Ord a => (a, a) -> a\n  //.\n  //. Returns the smaller of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > min (10, 2)\n  //. 2\n  //.\n  //. > min (new Date ('1999-12-31'), new Date ('2000-01-01'))\n  //. new Date ('1999-12-31')\n  //.\n  //. > min ('10', '2')\n  //. '10'\n  //. ```\n  function min(x, y) {\n    return lte (x, y) ? x : y;\n  }\n\n  //# max :: Ord a => (a, a) -> a\n  //.\n  //. Returns the larger of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > max (10, 2)\n  //. 10\n  //.\n  //. > max (new Date ('1999-12-31'), new Date ('2000-01-01'))\n  //. new Date ('2000-01-01')\n  //.\n  //. > max ('10', '2')\n  //. '2'\n  //. ```\n  function max(x, y) {\n    return lte (x, y) ? y : x;\n  }\n\n  //# clamp :: Ord a => (a, a, a) -> a\n  //.\n  //. Takes a lower bound, an upper bound, and a value of the same type.\n  //. Returns the value if it is within the bounds; the nearer bound otherwise.\n  //.\n  //. This function is derived from [`min`](#min) and [`max`](#max).\n  //.\n  //. ```javascript\n  //. > clamp (0, 100, 42)\n  //. 42\n  //.\n  //. > clamp (0, 100, -1)\n  //. 0\n  //.\n  //. > clamp ('A', 'Z', '~')\n  //. 'Z'\n  //. ```\n  function clamp(lower, upper, x) {\n    return max (lower, min (upper, x));\n  }\n\n  //# compose :: Semigroupoid c => (c j k, c i j) -> c i k\n  //.\n  //. Function wrapper for [`fantasy-land/compose`][].\n  //.\n  //. `fantasy-land/compose` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > compose (Math.sqrt, x => x + 1) (99)\n  //. 10\n  //. ```\n  function compose(x, y) {\n    return Semigroupoid.methods.compose (y) (x);\n  }\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. Function wrapper for [`fantasy-land/id`][].\n  //.\n  //. `fantasy-land/id` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > id (Function) ('foo')\n  //. 'foo'\n  //. ```\n  function id(typeRep) {\n    return Category.methods.id (typeRep) ();\n  }\n\n  //# concat :: Semigroup a => (a, a) -> a\n  //.\n  //. Function wrapper for [`fantasy-land/concat`][].\n  //.\n  //. `fantasy-land/concat` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > concat ('abc', 'def')\n  //. 'abcdef'\n  //.\n  //. > concat ([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > concat ({x: 1, y: 2}, {y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > concat (Cons ('foo', Cons ('bar', Cons ('baz', Nil))), Cons ('quux', Nil))\n  //. Cons ('foo', Cons ('bar', Cons ('baz', Cons ('quux', Nil))))\n  //. ```\n  function concat(x, y) {\n    return Semigroup.methods.concat (x) (y);\n  }\n\n  //# empty :: Monoid m => TypeRep m -> m\n  //.\n  //. Function wrapper for [`fantasy-land/empty`][].\n  //.\n  //. `fantasy-land/empty` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > empty (String)\n  //. ''\n  //.\n  //. > empty (Array)\n  //. []\n  //.\n  //. > empty (Object)\n  //. {}\n  //.\n  //. > empty (List)\n  //. Nil\n  //. ```\n  function empty(typeRep) {\n    return Monoid.methods.empty (typeRep) ();\n  }\n\n  //# invert :: Group g => g -> g\n  //.\n  //. Function wrapper for [`fantasy-land/invert`][].\n  //.\n  //. ```javascript\n  //. > invert (Sum (5))\n  //. Sum (-5)\n  //. ```\n  function invert(group) {\n    return Group.methods.invert (group) ();\n  }\n\n  //# filter :: Filterable f => (a -> Boolean, f a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/filter`][]. Discards every element\n  //. which does not satisfy the predicate.\n  //.\n  //. `fantasy-land/filter` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. See also [`reject`](#reject).\n  //.\n  //. ```javascript\n  //. > filter (x => x % 2 == 1, [1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > filter (x => x % 2 == 1, {x: 1, y: 2, z: 3})\n  //. {x: 1, z: 3}\n  //.\n  //. > filter (x => x % 2 == 1, Cons (1, Cons (2, Cons (3, Nil))))\n  //. Cons (1, Cons (3, Nil))\n  //.\n  //. > filter (x => x % 2 == 1, Nothing)\n  //. Nothing\n  //.\n  //. > filter (x => x % 2 == 1, Just (0))\n  //. Nothing\n  //.\n  //. > filter (x => x % 2 == 1, Just (1))\n  //. Just (1)\n  //. ```\n  function filter(pred, filterable) {\n    return Filterable.methods.filter (filterable) (pred);\n  }\n\n  //# reject :: Filterable f => (a -> Boolean, f a) -> f a\n  //.\n  //. Discards every element which satisfies the predicate.\n  //.\n  //. This function is derived from [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > reject (x => x % 2 == 1, [1, 2, 3])\n  //. [2]\n  //.\n  //. > reject (x => x % 2 == 1, {x: 1, y: 2, z: 3})\n  //. {y: 2}\n  //.\n  //. > reject (x => x % 2 == 1, Cons (1, Cons (2, Cons (3, Nil))))\n  //. Cons (2, Nil)\n  //.\n  //. > reject (x => x % 2 == 1, Nothing)\n  //. Nothing\n  //.\n  //. > reject (x => x % 2 == 1, Just (0))\n  //. Just (0)\n  //.\n  //. > reject (x => x % 2 == 1, Just (1))\n  //. Nothing\n  //. ```\n  function reject(pred, filterable) {\n    return filter (function(x) { return !(pred (x)); }, filterable);\n  }\n\n  //# map :: Functor f => (a -> b, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/map`][].\n  //.\n  //. `fantasy-land/map` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > map (Math.sqrt, [1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > map (Math.sqrt, {x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > map (Math.sqrt, s => s.length) ('Sanctuary')\n  //. 3\n  //.\n  //. > map (Math.sqrt, Pair ('foo') (64))\n  //. Pair ('foo') (8)\n  //.\n  //. > map (Math.sqrt, Nil)\n  //. Nil\n  //.\n  //. > map (Math.sqrt, Cons (1, Cons (4, Cons (9, Nil))))\n  //. Cons (1, Cons (2, Cons (3, Nil)))\n  //. ```\n  function map(f, functor) {\n    return Functor.methods.map (functor) (f);\n  }\n\n  //# flip :: Functor f => (f (a -> b), a) -> f b\n  //.\n  //. Maps over the given functions, applying each to the given value.\n  //.\n  //. This function is derived from [`map`](#map).\n  //.\n  //. ```javascript\n  //. > flip (x => y => x + y, '!') ('foo')\n  //. 'foo!'\n  //.\n  //. > flip ([Math.floor, Math.ceil], 1.5)\n  //. [1, 2]\n  //.\n  //. > flip ({floor: Math.floor, ceil: Math.ceil}, 1.5)\n  //. {floor: 1, ceil: 2}\n  //.\n  //. > flip (Cons (Math.floor, Cons (Math.ceil, Nil)), 1.5)\n  //. Cons (1, Cons (2, Nil))\n  //. ```\n  function flip(functor, x) {\n    return Functor.methods.map (functor) (thrush (x));\n  }\n\n  //# bimap :: Bifunctor f => (a -> b, c -> d, f a c) -> f b d\n  //.\n  //. Function wrapper for [`fantasy-land/bimap`][].\n  //.\n  //. ```javascript\n  //. > bimap (s => s.toUpperCase (), Math.sqrt, Pair ('foo') (64))\n  //. Pair ('FOO') (8)\n  //. ```\n  function bimap(f, g, bifunctor) {\n    return Bifunctor.methods.bimap (bifunctor) (f, g);\n  }\n\n  //# mapLeft :: Bifunctor f => (a -> b, f a c) -> f b c\n  //.\n  //. Maps the given function over the left side of a Bifunctor.\n  //.\n  //. ```javascript\n  //. > mapLeft (Math.sqrt, Pair (64) (9))\n  //. Pair (8) (9)\n  //. ```\n  function mapLeft(f, bifunctor) {\n    return bimap (f, identity, bifunctor);\n  }\n\n  //# promap :: Profunctor p => (a -> b, c -> d, p b c) -> p a d\n  //.\n  //. Function wrapper for [`fantasy-land/promap`][].\n  //.\n  //. `fantasy-land/promap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > promap (Math.abs, x => x + 1, Math.sqrt) (-100)\n  //. 11\n  //. ```\n  function promap(f, g, profunctor) {\n    return Profunctor.methods.promap (profunctor) (f, g);\n  }\n\n  //# ap :: Apply f => (f (a -> b), f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/ap`][].\n  //.\n  //. `fantasy-land/ap` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > ap ([Math.sqrt, x => x * x], [1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > ap ({a: Math.sqrt, b: x => x * x}, {a: 16, b: 10, c: 1})\n  //. {a: 4, b: 100}\n  //.\n  //. > ap (s => n => s.slice (0, n), s => Math.ceil (s.length / 2)) ('Haskell')\n  //. 'Hask'\n  //.\n  //. > ap (Identity (Math.sqrt), Identity (64))\n  //. Identity (8)\n  //.\n  //. > ap (Cons (Math.sqrt, Cons (x => x * x, Nil)), Cons (16, Cons (100, Nil)))\n  //. Cons (4, Cons (10, Cons (256, Cons (10000, Nil))))\n  //. ```\n  function ap(applyF, applyX) {\n    return Apply.methods.ap (applyX) (applyF);\n  }\n\n  //# lift2 :: Apply f => (a -> b -> c, f a, f b) -> f c\n  //.\n  //. Lifts `a -> b -> c` to `Apply f => f a -> f b -> f c` and returns the\n  //. result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift3`](#lift3).\n  //.\n  //. ```javascript\n  //. > lift2 (x => y => Math.pow (x, y), [10], [1, 2, 3])\n  //. [10, 100, 1000]\n  //.\n  //. > lift2 (x => y => Math.pow (x, y), Identity (10), Identity (3))\n  //. Identity (1000)\n  //. ```\n  function lift2(f, x, y) {\n    return ap (map (f, x), y);\n  }\n\n  //# lift3 :: Apply f => (a -> b -> c -> d, f a, f b, f c) -> f d\n  //.\n  //. Lifts `a -> b -> c -> d` to `Apply f => f a -> f b -> f c -> f d` and\n  //. returns the result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift2`](#lift2).\n  //.\n  //. ```javascript\n  //. > lift3 (x => y => z => x + z + y,\n  //. .        ['<', '['],\n  //. .        ['>', ']'],\n  //. .        ['foo', 'bar', 'baz'])\n  //. [ '<foo>', '<bar>', '<baz>',\n  //. . '<foo]', '<bar]', '<baz]',\n  //. . '[foo>', '[bar>', '[baz>',\n  //. . '[foo]', '[bar]', '[baz]' ]\n  //.\n  //. > lift3 (x => y => z => x + z + y,\n  //. .        Identity ('<'),\n  //. .        Identity ('>'),\n  //. .        Identity ('baz'))\n  //. Identity ('<baz>')\n  //. ```\n  function lift3(f, x, y, z) {\n    return ap (ap (map (f, x), y), z);\n  }\n\n  //# apFirst :: Apply f => (f a, f b) -> f a\n  //.\n  //. Combines two effectful actions, keeping only the result of the first.\n  //. Equivalent to Haskell's `(<*)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > apFirst ([1, 2], [3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > apFirst (Identity (1), Identity (2))\n  //. Identity (1)\n  //. ```\n  function apFirst(x, y) {\n    return lift2 (constant, x, y);\n  }\n\n  //# apSecond :: Apply f => (f a, f b) -> f b\n  //.\n  //. Combines two effectful actions, keeping only the result of the second.\n  //. Equivalent to Haskell's `(*>)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > apSecond ([1, 2], [3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > apSecond (Identity (1), Identity (2))\n  //. Identity (2)\n  //. ```\n  function apSecond(x, y) {\n    return lift2 (constant (identity), x, y);\n  }\n\n  //# of :: Applicative f => (TypeRep f, a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/of`][].\n  //.\n  //. `fantasy-land/of` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > of (Array, 42)\n  //. [42]\n  //.\n  //. > of (Function, 42) (null)\n  //. 42\n  //.\n  //. > of (List, 42)\n  //. Cons (42, Nil)\n  //. ```\n  function of(typeRep, x) {\n    return Applicative.methods.of (typeRep) (x);\n  }\n\n  //# append :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > append (3, [1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > append (3, Cons (1, Cons (2, Nil)))\n  //. Cons (1, Cons (2, Cons (3, Nil)))\n  //. ```\n  function append(x, xs) {\n    return concat (xs, of (xs.constructor, x));\n  }\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > prepend (1, [2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > prepend (1, Cons (2, Cons (3, Nil)))\n  //. Cons (1, Cons (2, Cons (3, Nil)))\n  //. ```\n  function prepend(x, xs) {\n    return concat (of (xs.constructor, x), xs);\n  }\n\n  //# chain :: Chain m => (a -> m b, m a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chain`][].\n  //.\n  //. `fantasy-land/chain` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > chain (x => [x, x], [1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > chain (x => x % 2 == 1 ? of (List, x) : Nil,\n  //. .        Cons (1, Cons (2, Cons (3, Nil))))\n  //. Cons (1, Cons (3, Nil))\n  //.\n  //. > chain (n => s => s.slice (0, n),\n  //. .        s => Math.ceil (s.length / 2))\n  //. .       ('Haskell')\n  //. 'Hask'\n  //. ```\n  function chain(f, chain_) {\n    return Chain.methods.chain (chain_) (f);\n  }\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. This function is derived from [`chain`](#chain).\n  //.\n  //. ```javascript\n  //. > join ([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > join ([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > join (Identity (Identity (1)))\n  //. Identity (1)\n  //. ```\n  function join(chain_) {\n    return chain (identity, chain_);\n  }\n\n  //# chainRec :: ChainRec m => (TypeRep m, (a -> c, b -> c, a) -> m c, a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chainRec`][].\n  //.\n  //. `fantasy-land/chainRec` implementations are provided for the following\n  //. built-in types: Array.\n  //.\n  //. ```javascript\n  //. > chainRec (\n  //. .   Array,\n  //. .   (next, done, s) => s.length == 2 ? [s + '!', s + '?'].map (done)\n  //. .                                    : [s + 'o', s + 'n'].map (next),\n  //. .   ''\n  //. . )\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  function chainRec(typeRep, f, x) {\n    return ChainRec.methods.chainRec (typeRep) (f, x);\n  }\n\n  //# alt :: Alt f => (f a, f a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/alt`][].\n  //.\n  //. `fantasy-land/alt` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > alt ([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > alt (Nothing, Nothing)\n  //. Nothing\n  //.\n  //. > alt (Nothing, Just (1))\n  //. Just (1)\n  //.\n  //. > alt (Just (2), Just (3))\n  //. Just (2)\n  //. ```\n  function alt(x, y) {\n    return Alt.methods.alt (x) (y);\n  }\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/zero`][].\n  //.\n  //. `fantasy-land/zero` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > zero (Array)\n  //. []\n  //.\n  //. > zero (Object)\n  //. {}\n  //.\n  //. > zero (Maybe)\n  //. Nothing\n  //. ```\n  function zero(typeRep) {\n    return Plus.methods.zero (typeRep) ();\n  }\n\n  //# reduce :: Foldable f => ((b, a) -> b, b, f a) -> b\n  //.\n  //. Function wrapper for [`fantasy-land/reduce`][].\n  //.\n  //. `fantasy-land/reduce` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > reduce ((xs, x) => [x].concat (xs), [], [1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reduce (concat, '', Cons ('foo', Cons ('bar', Cons ('baz', Nil))))\n  //. 'foobarbaz'\n  //. ```\n  function reduce(f, x, foldable) {\n    return Foldable.methods.reduce (foldable) (f, x);\n  }\n\n  //# size :: Foldable f => f a -> Integer\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. This function is derived from [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > size ([])\n  //. 0\n  //.\n  //. > size (['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > size (Nil)\n  //. 0\n  //.\n  //. > size (Cons ('foo', Cons ('bar', Cons ('baz', Nil))))\n  //. 3\n  //. ```\n  function size(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) return foldable.length;\n    return reduce (function(n, _) { return n + 1; }, 0, foldable);\n  }\n\n  //# all :: Foldable f => (a -> Boolean, f a) -> Boolean\n  //.\n  //. Returns `true` if all the elements of the structure satisfy the\n  //. predicate; `false` otherwise.\n  //.\n  //. This function is derived from [`reduce`](#reduce).\n  //.\n  //. See also [`any`](#any) and [`none`](#none).\n  //.\n  //. ```javascript\n  //. > all (Number.isInteger, [])\n  //. true\n  //.\n  //. > all (Number.isInteger, [1, 2, 3])\n  //. true\n  //.\n  //. > all (Number.isInteger, [0, 0.25, 0.5, 0.75, 1])\n  //. false\n  //. ```\n  function all(pred, foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) return foldable.every (unary (pred));\n    return reduce (function(b, x) { return b && pred (x); }, true, foldable);\n  }\n\n  //# any :: Foldable f => (a -> Boolean, f a) -> Boolean\n  //.\n  //. Returns `true` if any element of the structure satisfies the predicate;\n  //. `false` otherwise.\n  //.\n  //. This function is derived from [`reduce`](#reduce).\n  //.\n  //. See also [`all`](#all) and [`none`](#none).\n  //.\n  //. ```javascript\n  //. > any (Number.isInteger, [])\n  //. false\n  //.\n  //. > any (Number.isInteger, [1, 2, 3])\n  //. true\n  //.\n  //. > any (Number.isInteger, [0, 0.25, 0.5, 0.75, 1])\n  //. true\n  //. ```\n  function any(pred, foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) return foldable.some (unary (pred));\n    return reduce (function(b, x) { return b || pred (x); }, false, foldable);\n  }\n\n  //# none :: Foldable f => (a -> Boolean, f a) -> Boolean\n  //.\n  //. Returns `true` if none of the elements of the structure satisfies the\n  //. predicate; `false` otherwise.\n  //.\n  //. This function is derived from [`any`](#any). `none (pred, foldable)` is\n  //. equivalent to `!(any (pred, foldable))`.\n  //.\n  //. See also [`all`](#all).\n  //.\n  //. ```javascript\n  //. > none (Number.isInteger, [])\n  //. true\n  //.\n  //. > none (Number.isInteger, [0, 0.25, 0.5, 0.75, 1])\n  //. false\n  //. ```\n  function none(pred, foldable) {\n    return !(any (pred, foldable));\n  }\n\n  //# elem :: (Setoid a, Foldable f) => (a, f a) -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` if the\n  //. value is an element of the structure; `false` otherwise.\n  //.\n  //. This function is derived from [`equals`](#equals) and\n  //. [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > elem ('c', ['a', 'b', 'c'])\n  //. true\n  //.\n  //. > elem ('x', ['a', 'b', 'c'])\n  //. false\n  //.\n  //. > elem (3, {x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > elem (8, {x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > elem (0, Just (0))\n  //. true\n  //.\n  //. > elem (0, Just (1))\n  //. false\n  //.\n  //. > elem (0, Nothing)\n  //. false\n  //. ```\n  function elem(x, foldable) {\n    return any (function(y) { return equals (x, y); }, foldable);\n  }\n\n  //# foldMap :: (Monoid m, Foldable f) => (TypeRep m, a -> m, f a) -> m\n  //.\n  //. Deconstructs a foldable by mapping every element to a monoid and\n  //. concatenating the results.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. and [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > foldMap (String, f => f.name, [Math.sin, Math.cos, Math.tan])\n  //. 'sincostan'\n  //. ```\n  function foldMap(typeRep, f, foldable) {\n    return reduce (function(monoid, x) { return concat (monoid, f (x)); },\n                   empty (typeRep),\n                   foldable);\n  }\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > reverse ([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reverse (Cons (1, Cons (2, Cons (3, Nil))))\n  //. Cons (3, Cons (2, Cons (1, Nil)))\n  //. ```\n  function reverse(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) return (foldable.slice ()).reverse ();\n    var F = foldable.constructor;\n    return reduce (function(xs, x) { return concat (of (F, x), xs); },\n                   empty (F),\n                   foldable);\n  }\n\n  //# sort :: (Ord a, Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) for comparisons.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > sort (['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > sort ([Just (2), Nothing, Just (1)])\n  //. [Nothing, Just (1), Just (2)]\n  //.\n  //. > sort (Cons ('foo', Cons ('bar', Cons ('baz', Nil))))\n  //. Cons ('bar', Cons ('baz', Cons ('foo', Nil)))\n  //. ```\n  function sort(foldable) {\n    return sortBy (identity, foldable);\n  }\n\n  //# sortBy :: (Ord b, Applicative f, Foldable f, Monoid (f a)) => (a -> b, f a) -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) to compare the values produced by applying the\n  //. given function to each element of the structure.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > sortBy (s => s.length, ['red', 'green', 'blue'])\n  //. ['red', 'blue', 'green']\n  //.\n  //. > sortBy (s => s.length, ['black', 'white'])\n  //. ['black', 'white']\n  //.\n  //. > sortBy (s => s.length, ['white', 'black'])\n  //. ['white', 'black']\n  //.\n  //. > sortBy (s => s.length, Cons ('red', Cons ('green', Cons ('blue', Nil))))\n  //. Cons ('red', Cons ('blue', Cons ('green', Nil)))\n  //. ```\n  function sortBy(f, foldable) {\n    var rs = reduce (function(rs, x) {\n      rs.push ({idx: rs.length, x: x, fx: f (x)});\n      return rs;\n    }, [], foldable);\n\n    var lte_ = (function(r) {\n      switch (typeof (r && r.fx)) {\n        case 'number':  return function(x, y) { return x <= y || x !== x; };\n        case 'string':  return function(x, y) { return x <= y; };\n        default:        return lte;\n      }\n    } (rs[0]));\n\n    rs.sort (function(a, b) {\n      return lte_ (a.fx, b.fx) ? lte_ (b.fx, a.fx) ? a.idx - b.idx : -1 : 1;\n    });\n\n    if (Array.isArray (foldable)) {\n      for (var idx = 0; idx < rs.length; idx += 1) rs[idx] = rs[idx].x;\n      return rs;\n    }\n\n    var F = foldable.constructor;\n    var result = empty (F);\n    for (idx = 0; idx < rs.length; idx += 1) {\n      result = concat (result, of (F, rs[idx].x));\n    }\n    return result;\n  }\n\n  //# traverse :: (Applicative f, Traversable t) => (TypeRep f, a -> f b, t a) -> f (t b)\n  //.\n  //. Function wrapper for [`fantasy-land/traverse`][].\n  //.\n  //. `fantasy-land/traverse` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. See also [`sequence`](#sequence).\n  //.\n  //. ```javascript\n  //. > traverse (Array, x => x, [[1, 2, 3], [4, 5]])\n  //. [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]\n  //.\n  //. > traverse (Identity, x => Identity (x + 1), [1, 2, 3])\n  //. Identity ([2, 3, 4])\n  //. ```\n  function traverse(typeRep, f, traversable) {\n    return Traversable.methods.traverse (traversable) (typeRep, f);\n  }\n\n  //# sequence :: (Applicative f, Traversable t) => (TypeRep f, t (f a)) -> f (t a)\n  //.\n  //. Inverts the given `t (f a)` to produce an `f (t a)`.\n  //.\n  //. This function is derived from [`traverse`](#traverse).\n  //.\n  //. ```javascript\n  //. > sequence (Array, Identity ([1, 2, 3]))\n  //. [Identity (1), Identity (2), Identity (3)]\n  //.\n  //. > sequence (Identity, [Identity (1), Identity (2), Identity (3)])\n  //. Identity ([1, 2, 3])\n  //. ```\n  function sequence(typeRep, traversable) {\n    return traverse (typeRep, identity, traversable);\n  }\n\n  //# extend :: Extend w => (w a -> b, w a) -> w b\n  //.\n  //. Function wrapper for [`fantasy-land/extend`][].\n  //.\n  //. `fantasy-land/extend` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > extend (ss => ss.join (''), ['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //.\n  //. > extend (f => f ([3, 4]), reverse) ([1, 2])\n  //. [4, 3, 2, 1]\n  //. ```\n  function extend(f, extend_) {\n    return Extend.methods.extend (extend_) (f);\n  }\n\n  //# duplicate :: Extend w => w a -> w (w a)\n  //.\n  //. Adds one level of nesting to a comonadic structure.\n  //.\n  //. This function is derived from [`extend`](#extend).\n  //.\n  //. ```javascript\n  //. > duplicate (Identity (1))\n  //. Identity (Identity (1))\n  //.\n  //. > duplicate ([1])\n  //. [[1]]\n  //.\n  //. > duplicate ([1, 2, 3])\n  //. [[1, 2, 3], [2, 3], [3]]\n  //.\n  //. > duplicate (reverse) ([1, 2]) ([3, 4])\n  //. [4, 3, 2, 1]\n  //. ```\n  function duplicate(extend_) {\n    return extend (identity, extend_);\n  }\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. Function wrapper for [`fantasy-land/extract`][].\n  //.\n  //. ```javascript\n  //. > extract (Identity (42))\n  //. 42\n  //. ```\n  function extract(comonad) {\n    return Comonad.methods.extract (comonad) ();\n  }\n\n  //# contramap :: Contravariant f => (b -> a, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/contramap`][].\n  //.\n  //. `fantasy-land/contramap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > contramap (s => s.length, Math.sqrt) ('Sanctuary')\n  //. 3\n  //. ```\n  function contramap(f, contravariant) {\n    return Contravariant.methods.contramap (contravariant) (f);\n  }\n\n  return {\n    TypeClass: TypeClass,\n    Setoid: Setoid,\n    Ord: Ord,\n    Semigroupoid: Semigroupoid,\n    Category: Category,\n    Semigroup: Semigroup,\n    Monoid: Monoid,\n    Group: Group,\n    Filterable: Filterable,\n    Functor: Functor,\n    Bifunctor: Bifunctor,\n    Profunctor: Profunctor,\n    Apply: Apply,\n    Applicative: Applicative,\n    Chain: Chain,\n    ChainRec: ChainRec,\n    Monad: Monad,\n    Alt: Alt,\n    Plus: Plus,\n    Alternative: Alternative,\n    Foldable: Foldable,\n    Traversable: Traversable,\n    Extend: Extend,\n    Comonad: Comonad,\n    Contravariant: Contravariant,\n    equals: equals,\n    lt: lt,\n    lte: lte,\n    gt: gt,\n    gte: gte,\n    min: min,\n    max: max,\n    clamp: clamp,\n    compose: compose,\n    id: id,\n    concat: concat,\n    empty: empty,\n    invert: invert,\n    filter: filter,\n    reject: reject,\n    map: map,\n    flip: flip,\n    bimap: bimap,\n    mapLeft: mapLeft,\n    promap: promap,\n    ap: ap,\n    lift2: lift2,\n    lift3: lift3,\n    apFirst: apFirst,\n    apSecond: apSecond,\n    of: of,\n    append: append,\n    prepend: prepend,\n    chain: chain,\n    join: join,\n    chainRec: chainRec,\n    alt: alt,\n    zero: zero,\n    reduce: reduce,\n    size: size,\n    all: all,\n    any: any,\n    none: none,\n    elem: elem,\n    foldMap: foldMap,\n    reverse: reverse,\n    sort: sort,\n    sortBy: sortBy,\n    traverse: traverse,\n    sequence: sequence,\n    extend: extend,\n    duplicate: duplicate,\n    extract: extract,\n    contramap: contramap\n  };\n\n}));\n\n//. [Alt]:                      v:fantasyland/fantasy-land#alt\n//. [Alternative]:              v:fantasyland/fantasy-land#alternative\n//. [Applicative]:              v:fantasyland/fantasy-land#applicative\n//. [Apply]:                    v:fantasyland/fantasy-land#apply\n//. [Bifunctor]:                v:fantasyland/fantasy-land#bifunctor\n//. [Category]:                 v:fantasyland/fantasy-land#category\n//. [Chain]:                    v:fantasyland/fantasy-land#chain\n//. [ChainRec]:                 v:fantasyland/fantasy-land#chainrec\n//. [Comonad]:                  v:fantasyland/fantasy-land#comonad\n//. [Contravariant]:            v:fantasyland/fantasy-land#contravariant\n//. [Extend]:                   v:fantasyland/fantasy-land#extend\n//. [FL]:                       v:fantasyland/fantasy-land\n//. [Filterable]:               v:fantasyland/fantasy-land#filterable\n//. [Foldable]:                 v:fantasyland/fantasy-land#foldable\n//. [Functor]:                  v:fantasyland/fantasy-land#functor\n//. [Group]:                    v:fantasyland/fantasy-land#group\n//. [Monad]:                    v:fantasyland/fantasy-land#monad\n//. [Monoid]:                   v:fantasyland/fantasy-land#monoid\n//. [Ord]:                      v:fantasyland/fantasy-land#ord\n//. [Plus]:                     v:fantasyland/fantasy-land#plus\n//. [Profunctor]:               v:fantasyland/fantasy-land#profunctor\n//. [Semigroup]:                v:fantasyland/fantasy-land#semigroup\n//. [Semigroupoid]:             v:fantasyland/fantasy-land#semigroupoid\n//. [Setoid]:                   v:fantasyland/fantasy-land#setoid\n//. [Traversable]:              v:fantasyland/fantasy-land#traversable\n//. [`fantasy-land/alt`]:       v:fantasyland/fantasy-land#alt-method\n//. [`fantasy-land/ap`]:        v:fantasyland/fantasy-land#ap-method\n//. [`fantasy-land/bimap`]:     v:fantasyland/fantasy-land#bimap-method\n//. [`fantasy-land/chain`]:     v:fantasyland/fantasy-land#chain-method\n//. [`fantasy-land/chainRec`]:  v:fantasyland/fantasy-land#chainrec-method\n//. [`fantasy-land/compose`]:   v:fantasyland/fantasy-land#compose-method\n//. [`fantasy-land/concat`]:    v:fantasyland/fantasy-land#concat-method\n//. [`fantasy-land/contramap`]: v:fantasyland/fantasy-land#contramap-method\n//. [`fantasy-land/empty`]:     v:fantasyland/fantasy-land#empty-method\n//. [`fantasy-land/equals`]:    v:fantasyland/fantasy-land#equals-method\n//. [`fantasy-land/extend`]:    v:fantasyland/fantasy-land#extend-method\n//. [`fantasy-land/extract`]:   v:fantasyland/fantasy-land#extract-method\n//. [`fantasy-land/filter`]:    v:fantasyland/fantasy-land#filter-method\n//. [`fantasy-land/id`]:        v:fantasyland/fantasy-land#id-method\n//. [`fantasy-land/invert`]:    v:fantasyland/fantasy-land#invert-method\n//. [`fantasy-land/lte`]:       v:fantasyland/fantasy-land#lte-method\n//. [`fantasy-land/map`]:       v:fantasyland/fantasy-land#map-method\n//. [`fantasy-land/of`]:        v:fantasyland/fantasy-land#of-method\n//. [`fantasy-land/promap`]:    v:fantasyland/fantasy-land#promap-method\n//. [`fantasy-land/reduce`]:    v:fantasyland/fantasy-land#reduce-method\n//. [`fantasy-land/traverse`]:  v:fantasyland/fantasy-land#traverse-method\n//. [`fantasy-land/zero`]:      v:fantasyland/fantasy-land#zero-method\n//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [type-classes]:             https://github.com/sanctuary-js/sanctuary-def#type-classes\n});\n\nvar sanctuaryEither = createCommonjsModule(function (module) {\n/*\n         _______    ___    _________    ___   ___    _______    ______\n        /  ____/\\  /  /\\  /__   ___/\\  /  /\\ /  /\\  /  ____/\\  /  __  \\\n       /  /\\___\\/ /  / /  \\_/  /\\__\\/ /  /_//  / / /  /\\___\\/ /  /\\/  /\\\n      /  ____/\\  /  / /    /  / /    /  ___   / / /  ____/\\  /      _/ /\n     /  /\\___\\/ /  / /    /  / /    /  /\\_/  / / /  /\\___\\/ /  /|  |\\\\/\n    /______/\\  /__/ /    /__/ /    /__/ //__/ / /______/\\  /__/ |__| |\n    \\______\\/  \\__\\/     \\__\\/     \\__\\/ \\__\\/  \\______\\/  \\__\\/ \\__\\|\n                                                                            */\n\n//. <a href=\"https://github.com/fantasyland/fantasy-land\"><img alt=\"Fantasy Land\" src=\"https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png\" width=\"75\" height=\"75\" align=\"left\"></a>\n//.\n//. # sanctuary-either\n//.\n//. The Either type represents values with two possibilities: a value of type\n//. `Either a b` is either a Left whose value is of type `a` or a Right whose\n//. value is of type `b`.\n\n(function(f) {\n\n  /* istanbul ignore else */\n  {\n    module.exports = f (util,\n                        sanctuaryShow,\n                        sanctuaryTypeClasses);\n  }\n\n} (function(util, show, Z) {\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    var $ = __doctest.require ('sanctuary-def');\n    var type = __doctest.require ('sanctuary-type-identifiers');\n    var S = (function() {\n      var S = __doctest.require ('sanctuary');\n      var EitherType = $.BinaryType\n        ('sanctuary-either/Either')\n        ('')\n        (function(x) { return type (x) === Either['@@type']; })\n        (function(e) { return e.isLeft ? [e.value] : []; })\n        (function(e) { return e.isLeft ? [] : [e.value]; });\n      var env = Z.concat (S.env,\n                          [$.TypeClass, EitherType ($.Unknown) ($.Unknown)]);\n      return S.create ({checkTypes: true, env: env});\n    } ());\n  }\n\n  var Either = {};\n\n  var Left$prototype = {\n    /* eslint-disable key-spacing */\n    'constructor':            Either,\n    'isLeft':                 true,\n    'isRight':                false,\n    '@@show':                 Left$prototype$show,\n    'fantasy-land/map':       Left$prototype$map,\n    'fantasy-land/bimap':     Left$prototype$bimap,\n    'fantasy-land/ap':        Left$prototype$ap,\n    'fantasy-land/chain':     Left$prototype$chain,\n    'fantasy-land/alt':       Left$prototype$alt,\n    'fantasy-land/reduce':    Left$prototype$reduce,\n    'fantasy-land/traverse':  Left$prototype$traverse,\n    'fantasy-land/extend':    Left$prototype$extend\n    /* eslint-enable key-spacing */\n  };\n\n  var Right$prototype = {\n    /* eslint-disable key-spacing */\n    'constructor':            Either,\n    'isLeft':                 false,\n    'isRight':                true,\n    '@@show':                 Right$prototype$show,\n    'fantasy-land/map':       Right$prototype$map,\n    'fantasy-land/bimap':     Right$prototype$bimap,\n    'fantasy-land/ap':        Right$prototype$ap,\n    'fantasy-land/chain':     Right$prototype$chain,\n    'fantasy-land/alt':       Right$prototype$alt,\n    'fantasy-land/reduce':    Right$prototype$reduce,\n    'fantasy-land/traverse':  Right$prototype$traverse,\n    'fantasy-land/extend':    Right$prototype$extend\n    /* eslint-enable key-spacing */\n  };\n\n  var custom = util.inspect.custom;\n  /* istanbul ignore else */\n  if (typeof custom === 'symbol') {\n    Left$prototype[custom] = Left$prototype$show;\n    Right$prototype[custom] = Right$prototype$show;\n  } else {\n    Left$prototype.inspect = Left$prototype$show;\n    Right$prototype.inspect = Right$prototype$show;\n  }\n\n  //. `Either a b` satisfies the following [Fantasy Land][] specifications:\n  //.\n  //. ```javascript\n  //. > const Useless = require ('sanctuary-useless')\n  //.\n  //. > S.map (k => k + ' '.repeat (16 - k.length) +\n  //. .             (Z[k].test (Right (Useless)) ? '\\u2705   ' :\n  //. .              Z[k].test (Right (['foo'])) ? '\\u2705 * ' :\n  //. .              /* otherwise */               '\\u274C   '))\n  //. .       (S.keys (S.unchecked.filter (S.is ($.TypeClass)) (Z)))\n  //. [ 'Setoid          ✅ * ',  // if ‘a’ and ‘b’ satisfy Setoid\n  //. . 'Ord             ✅ * ',  // if ‘a’ and ‘b’ satisfy Ord\n  //. . 'Semigroupoid    ❌   ',\n  //. . 'Category        ❌   ',\n  //. . 'Semigroup       ✅ * ',  // if ‘a’ and ‘b’ satisfy Semigroup\n  //. . 'Monoid          ❌   ',\n  //. . 'Group           ❌   ',\n  //. . 'Filterable      ❌   ',\n  //. . 'Functor         ✅   ',\n  //. . 'Bifunctor       ✅   ',\n  //. . 'Profunctor      ❌   ',\n  //. . 'Apply           ✅   ',\n  //. . 'Applicative     ✅   ',\n  //. . 'Chain           ✅   ',\n  //. . 'ChainRec        ✅   ',\n  //. . 'Monad           ✅   ',\n  //. . 'Alt             ✅   ',\n  //. . 'Plus            ❌   ',\n  //. . 'Alternative     ❌   ',\n  //. . 'Foldable        ✅   ',\n  //. . 'Traversable     ✅   ',\n  //. . 'Extend          ✅   ',\n  //. . 'Comonad         ❌   ',\n  //. . 'Contravariant   ❌   ' ]\n  //. ```\n\n  //# Either :: TypeRep Either\n  //.\n  //. Either [type representative][].\n\n  //# Either.Left :: a -> Either a b\n  //.\n  //. Constructs a value of type `Either a b` from a value of type `a`.\n  //.\n  //. ```javascript\n  //. > Left ('sqrt undefined for -1')\n  //. Left ('sqrt undefined for -1')\n  //. ```\n  var Left = Either.Left = function(value) {\n    var left = Object.create (Left$prototype);\n    if (Z.Setoid.test (value)) {\n      left['fantasy-land/equals'] = Left$prototype$equals;\n      if (Z.Ord.test (value)) {\n        left['fantasy-land/lte'] = Left$prototype$lte;\n      }\n    }\n    if (Z.Semigroup.test (value)) {\n      left['fantasy-land/concat'] = Left$prototype$concat;\n    }\n    left.value = value;\n    return left;\n  };\n\n  //# Either.Right :: b -> Either a b\n  //.\n  //. Constructs a value of type `Either a b` from a value of type `b`.\n  //.\n  //. ```javascript\n  //. > Right (42)\n  //. Right (42)\n  //. ```\n  var Right = Either.Right = function Right(value) {\n    var right = Object.create (Right$prototype);\n    if (Z.Setoid.test (value)) {\n      right['fantasy-land/equals'] = Right$prototype$equals;\n      if (Z.Ord.test (value)) {\n        right['fantasy-land/lte'] = Right$prototype$lte;\n      }\n    }\n    if (Z.Semigroup.test (value)) {\n      right['fantasy-land/concat'] = Right$prototype$concat;\n    }\n    right.value = value;\n    return right;\n  };\n\n  //# Either.@@type :: String\n  //.\n  //. Either [type identifier][].\n  //.\n  //. ```javascript\n  //. > type (Right (42))\n  //. 'sanctuary-either/Either@1'\n  //.\n  //. > type.parse (type (Right (42)))\n  //. {namespace: 'sanctuary-either', name: 'Either', version: 1}\n  //. ```\n  Either['@@type'] = 'sanctuary-either/Either@1';\n\n  //# Either.fantasy-land/of :: b -> Either a b\n  //.\n  //.   - `of (Either) (x)` is equivalent to `Right (x)`\n  //.\n  //. ```javascript\n  //. > S.of (Either) (42)\n  //. Right (42)\n  //. ```\n  Either['fantasy-land/of'] = Right;\n\n  function next(x) { return {tag: next, value: x}; }\n  function done(x) { return {tag: done, value: x}; }\n\n  //# Either.fantasy-land/chainRec :: ((a -> c, b -> c, a) -> Either d c, a) -> Either d b\n  //.\n  //. ```javascript\n  //. > Z.chainRec (\n  //. .   Either,\n  //. .   (next, done, x) =>\n  //. .     x <= 1 ? Left ('!!') : Right (x >= 1000 ? done (x) : next (x * x)),\n  //. .   1\n  //. . )\n  //. Left ('!!')\n  //.\n  //. > Z.chainRec (\n  //. .   Either,\n  //. .   (next, done, x) =>\n  //. .     x <= 1 ? Left ('!!') : Right (x >= 1000 ? done (x) : next (x * x)),\n  //. .   2\n  //. . )\n  //. Right (65536)\n  //. ```\n  Either['fantasy-land/chainRec'] = function(f, x) {\n    var r = next (x);\n    while (r.tag === next) {\n      var either = f (next, done, r.value);\n      if (either.isLeft) return either;\n      r = either.value;\n    }\n    return Right (r.value);\n  };\n\n  //# Either#@@show :: (Showable a, Showable b) => Either a b ~> () -> String\n  //.\n  //.   - `show (Left (x))` is equivalent to `'Left (' + show (x) + ')'`\n  //.   - `show (Right (x))` is equivalent to `'Right (' + show (x) + ')'`\n  //.\n  //. ```javascript\n  //. > show (Left ('sqrt undefined for -1'))\n  //. 'Left (\"sqrt undefined for -1\")'\n  //.\n  //. > show (Right ([1, 2, 3]))\n  //. 'Right ([1, 2, 3])'\n  //. ```\n  function Left$prototype$show() {\n    return 'Left (' + show (this.value) + ')';\n  }\n  function Right$prototype$show() {\n    return 'Right (' + show (this.value) + ')';\n  }\n\n  //# Either#fantasy-land/equals :: (Setoid a, Setoid b) => Either a b ~> Either a b -> Boolean\n  //.\n  //.   - `Left (x)` is equal to `Left (y)` [iff][] `x` is equal to `y`\n  //.     according to [`Z.equals`][]\n  //.   - `Right (x)` is equal to `Right (y)` [iff][] `x` is equal to `y`\n  //.     according to [`Z.equals`][]\n  //.   - `Left (x)` is never equal to `Right (y)`\n  //.\n  //. ```javascript\n  //. > S.equals (Left ([1, 2, 3])) (Left ([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals (Right ([1, 2, 3])) (Right ([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals (Left ([1, 2, 3])) (Right ([1, 2, 3]))\n  //. false\n  //. ```\n  function Left$prototype$equals(other) {\n    return other.isLeft && Z.equals (this.value, other.value);\n  }\n  function Right$prototype$equals(other) {\n    return other.isRight && Z.equals (this.value, other.value);\n  }\n\n  //# Either#fantasy-land/lte :: (Ord a, Ord b) => Either a b ~> Either a b -> Boolean\n  //.\n  //.   - `Left (x)` is less than or equal to `Left (y)` [iff][] `x` is less\n  //.     than or equal to `y` according to [`Z.lte`][]\n  //.   - `Right (x)` is less than or equal to `Right (y)` [iff][] `x` is less\n  //.     than or equal to `y` according to [`Z.lte`][]\n  //.   - `Left (x)` is always less than `Right (y)`\n  //.\n  //. ```javascript\n  //. > S.filter (S.lte (Left (1))) ([Left (0), Left (1), Left (2)])\n  //. [Left (0), Left (1)]\n  //.\n  //. > S.filter (S.lte (Right (1))) ([Right (0), Right (1), Right (2)])\n  //. [Right (0), Right (1)]\n  //.\n  //. > S.filter (S.lte (Left (1))) ([Right (0), Right (1), Right (2)])\n  //. []\n  //.\n  //. > S.filter (S.lte (Right (1))) ([Left (0), Left (1), Left (2)])\n  //. [Left (0), Left (1), Left (2)]\n  //. ```\n  function Left$prototype$lte(other) {\n    return other.isRight || Z.lte (this.value, other.value);\n  }\n  function Right$prototype$lte(other) {\n    return other.isRight && Z.lte (this.value, other.value);\n  }\n\n  //# Either#fantasy-land/concat :: (Semigroup a, Semigroup b) => Either a b ~> Either a b -> Either a b\n  //.\n  //.   - `concat (Left (x)) (Left (y))` is equivalent to\n  //.     `Left (concat (x) (y))`\n  //.   - `concat (Right (x)) (Right (y))` is equivalent to\n  //.     `Right (concat (x) (y))`\n  //.   - `concat (Left (x)) (Right (y))` is equivalent to `Right (y)`\n  //.   - `concat (Right (x)) (Left (y))` is equivalent to `Right (x)`\n  //.\n  //. ```javascript\n  //. > S.concat (Left ('abc')) (Left ('def'))\n  //. Left ('abcdef')\n  //.\n  //. > S.concat (Right ([1, 2, 3])) (Right ([4, 5, 6]))\n  //. Right ([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat (Left ('abc')) (Right ([1, 2, 3]))\n  //. Right ([1, 2, 3])\n  //.\n  //. > S.concat (Right ([1, 2, 3])) (Left ('abc'))\n  //. Right ([1, 2, 3])\n  //. ```\n  function Left$prototype$concat(other) {\n    return other.isLeft ? Left (Z.concat (this.value, other.value)) : other;\n  }\n  function Right$prototype$concat(other) {\n    return other.isRight ? Right (Z.concat (this.value, other.value)) : this;\n  }\n\n  //# Either#fantasy-land/map :: Either a b ~> (b -> c) -> Either a c\n  //.\n  //.   - `map (f) (Left (x))` is equivalent to `Left (x)`\n  //.   - `map (f) (Right (x))` is equivalent to `Right (f (x))`\n  //.\n  //. ```javascript\n  //. > S.map (S.add (1)) (Left ('sqrt undefined for -1'))\n  //. Left ('sqrt undefined for -1')\n  //.\n  //. > S.map (S.add (1)) (Right (99))\n  //. Right (100)\n  //. ```\n  function Left$prototype$map(f) {\n    return this;\n  }\n  function Right$prototype$map(f) {\n    return Right (f (this.value));\n  }\n\n  //# Either#fantasy-land/bimap :: Either a c ~> (a -> b, c -> d) -> Either b d\n  //.\n  //.   - `bimap (f) (g) (Left (x))` is equivalent to `Left (f (x))`\n  //.   - `bimap (f) (g) (Right (x))` is equivalent to `Right (g (x))`\n  //.\n  //. ```javascript\n  //. > S.bimap (S.toUpper) (S.add (1)) (Left ('abc'))\n  //. Left ('ABC')\n  //.\n  //. > S.bimap (S.toUpper) (S.add (1)) (Right (99))\n  //. Right (100)\n  //. ```\n  function Left$prototype$bimap(f, g) {\n    return Left (f (this.value));\n  }\n  function Right$prototype$bimap(f, g) {\n    return Right (g (this.value));\n  }\n\n  //# Either#fantasy-land/ap :: Either a b ~> Either a (b -> c) -> Either a c\n  //.\n  //.   - `ap (Left (x)) (Left (y))` is equivalent to `Left (x)`\n  //.   - `ap (Left (x)) (Right (y))` is equivalent to `Left (x)`\n  //.   - `ap (Right (f)) (Left (x))` is equivalent to `Left (x)`\n  //.   - `ap (Right (f)) (Right (x))` is equivalent to `Right (f (x))`\n  //.\n  //. ```javascript\n  //. > S.ap (Left ('div undefined for 0')) (Left ('sqrt undefined for -1'))\n  //. Left ('div undefined for 0')\n  //.\n  //. > S.ap (Left ('div undefined for 0')) (Right (99))\n  //. Left ('div undefined for 0')\n  //.\n  //. > S.ap (Right (S.add (1))) (Left ('sqrt undefined for -1'))\n  //. Left ('sqrt undefined for -1')\n  //.\n  //. > S.ap (Right (S.add (1))) (Right (99))\n  //. Right (100)\n  //. ```\n  function Left$prototype$ap(other) {\n    return other.isLeft ? other : this;\n  }\n  function Right$prototype$ap(other) {\n    return other.isLeft ? other : Right (other.value (this.value));\n  }\n\n  //# Either#fantasy-land/chain :: Either a b ~> (b -> Either a c) -> Either a c\n  //.\n  //.   - `chain (f) (Left (x))` is equivalent to `Left (x)`\n  //.   - `chain (f) (Right (x))` is equivalent to `f (x)`\n  //.\n  //. ```javascript\n  //. > const sqrt = n => n < 0 ? Left ('sqrt undefined for ' + show (n))\n  //. .                         : Right (Math.sqrt (n))\n  //.\n  //. > S.chain (sqrt) (Left ('div undefined for 0'))\n  //. Left ('div undefined for 0')\n  //.\n  //. > S.chain (sqrt) (Right (-1))\n  //. Left ('sqrt undefined for -1')\n  //.\n  //. > S.chain (sqrt) (Right (25))\n  //. Right (5)\n  //. ```\n  function Left$prototype$chain(f) {\n    return this;\n  }\n  function Right$prototype$chain(f) {\n    return f (this.value);\n  }\n\n  //# Either#fantasy-land/alt :: Either a b ~> Either a b -> Either a b\n  //.\n  //.   - `alt (Left (x)) (Left (y))` is equivalent to `Left (y)`\n  //.   - `alt (Left (x)) (Right (y))` is equivalent to `Right (y)`\n  //.   - `alt (Right (x)) (Left (y))` is equivalent to `Right (x)`\n  //.   - `alt (Right (x)) (Right (y))` is equivalent to `Right (x)`\n  //.\n  //. ```javascript\n  //. > S.alt (Left ('A')) (Left ('B'))\n  //. Left ('B')\n  //.\n  //. > S.alt (Left ('C')) (Right (1))\n  //. Right (1)\n  //.\n  //. > S.alt (Right (2)) (Left ('D'))\n  //. Right (2)\n  //.\n  //. > S.alt (Right (3)) (Right (4))\n  //. Right (3)\n  //. ```\n  function Left$prototype$alt(other) {\n    return other;\n  }\n  function Right$prototype$alt(other) {\n    return this;\n  }\n\n  //# Either#fantasy-land/reduce :: Either a b ~> ((c, b) -> c, c) -> c\n  //.\n  //.   - `reduce (f) (x) (Left (y))` is equivalent to `x`\n  //.   - `reduce (f) (x) (Right (y))` is equivalent to `f (x) (y)`\n  //.\n  //. ```javascript\n  //. > S.reduce (S.concat) ([1]) (Left ('sqrt undefined for -1'))\n  //. [1]\n  //.\n  //. > S.reduce (S.concat) ([1]) (Right ([2]))\n  //. [1, 2]\n  //. ```\n  function Left$prototype$reduce(f, x) {\n    return x;\n  }\n  function Right$prototype$reduce(f, x) {\n    return f (x, this.value);\n  }\n\n  //# Either#fantasy-land/traverse :: Applicative f => Either a b ~> (TypeRep f, b -> f c) -> f (Either a c)\n  //.\n  //.   - `traverse (A) (f) (Left (x))` is equivalent to `of (A) (Left (x))`\n  //.   - `traverse (A) (f) (Right (x))` is equivalent to `map (Right) (f (x))`\n  //.\n  //. ```javascript\n  //. > S.traverse (Array) (S.words) (Left ('sqrt undefined for -1'))\n  //. [Left ('sqrt undefined for -1')]\n  //.\n  //. > S.traverse (Array) (S.words) (Right ('foo bar baz'))\n  //. [Right ('foo'), Right ('bar'), Right ('baz')]\n  //. ```\n  function Left$prototype$traverse(typeRep, f) {\n    return Z.of (typeRep, this);\n  }\n  function Right$prototype$traverse(typeRep, f) {\n    return Z.map (Right, f (this.value));\n  }\n\n  //# Either#fantasy-land/extend :: Either a b ~> (Either a b -> c) -> Either a c\n  //.\n  //.   - `extend (f) (Left (x))` is equivalent to `Left (x)`\n  //.   - `extend (f) (Right (x))` is equivalent to `Right (f (Right (x)))`\n  //.\n  //. ```javascript\n  //. > S.extend (S.reduce (S.add) (1)) (Left ('sqrt undefined for -1'))\n  //. Left ('sqrt undefined for -1')\n  //.\n  //. > S.extend (S.reduce (S.add) (1)) (Right (99))\n  //. Right (100)\n  //. ```\n  function Left$prototype$extend(f) {\n    return this;\n  }\n  function Right$prototype$extend(f) {\n    return Right (f (this));\n  }\n\n  return Either;\n\n}));\n\n//. [Fantasy Land]:             v:fantasyland/fantasy-land\n//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals\n//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte\n//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if\n//. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers\n//. [type representative]:      v:fantasyland/fantasy-land#type-representatives\n});\n\nvar sanctuaryDef = createCommonjsModule(function (module) {\n/*              ___                 ______\n               /  /\\               /  ___/\\\n        ______/  / / _______    __/  /___\\/\n       /  ___   / / /  ___  \\  /_   __/\\\n      /  /\\_/  / / /  /__/  /\\ \\/  /\\_\\/\n     /  / //  / / /  ______/ / /  / /\n    /  /_//  / / /  /______\\/ /  / /\n    \\_______/ /  \\_______/\\  /__/ /\n     \\______\\/    \\______\\/  \\__*/\n\n//. # sanctuary-def\n//.\n//. sanctuary-def is a run-time type system for JavaScript. It facilitates\n//. the definition of curried JavaScript functions that are explicit about\n//. the number of arguments to which they may be applied and the types of\n//. those arguments.\n//.\n//. It is conventional to import the package as `$`:\n//.\n//. ```javascript\n//. const $ = require ('sanctuary-def');\n//. ```\n//.\n//. The next step is to define an environment. An environment is an array\n//. of [types][]. [`env`][] is an environment containing all the built-in\n//. JavaScript types. It may be used as the basis for environments that\n//. include custom types in addition to the built-in types:\n//.\n//. ```javascript\n//. //    Integer :: Type\n//. const Integer = '...';\n//.\n//. //    NonZeroInteger :: Type\n//. const NonZeroInteger = '...';\n//.\n//. //    env :: Array Type\n//. const env = $.env.concat ([Integer, NonZeroInteger]);\n//. ```\n//.\n//. Type constructors such as `List :: Type -> Type` cannot be included in\n//. an environment as they're not of the correct type. One could, though,\n//. use a type constructor to define a fixed number of concrete types:\n//.\n//. ```javascript\n//. //    env :: Array Type\n//. const env = $.env.concat ([\n//.   List ($.Number),                // :: Type\n//.   List ($.String),                // :: Type\n//.   List (List ($.Number)),         // :: Type\n//.   List (List ($.String)),         // :: Type\n//.   List (List (List ($.Number))),  // :: Type\n//.   List (List (List ($.String))),  // :: Type\n//. ]);\n//. ```\n//.\n//. Not only would this be tedious, but one could never enumerate all possible\n//. types as there are infinitely many. Instead, one should use [`Unknown`][]:\n//.\n//. ```javascript\n//. //    env :: Array Type\n//. const env = $.env.concat ([List ($.Unknown)]);\n//. ```\n//.\n//. The next step is to define a `def` function for the environment:\n//.\n//. ```javascript\n//. const def = $.create ({checkTypes: true, env});\n//. ```\n//.\n//. The `checkTypes` option determines whether type checking is enabled.\n//. This allows one to only pay the performance cost of run-time type checking\n//. during development. For example:\n//.\n//. ```javascript\n//. const def = $.create ({\n//.   checkTypes: process.env.NODE_ENV === 'development',\n//.   env,\n//. });\n//. ```\n//.\n//. `def` is a function for defining functions. For example:\n//.\n//. ```javascript\n//. //    add :: Number -> Number -> Number\n//. const add =\n//. def ('add')\n//.     ({})\n//.     ([$.Number, $.Number, $.Number])\n//.     (x => y => x + y);\n//. ```\n//.\n//. `[$.Number, $.Number, $.Number]` specifies that `add` takes two arguments\n//. of type `Number`, one at a time, and returns a value of type `Number`.\n//.\n//. Applying `add` to two arguments, one at a time, gives the expected result:\n//.\n//. ```javascript\n//. add (2) (2);\n//. // => 4\n//. ```\n//.\n//. Applying `add` to multiple arguments at once results in an exception being\n//. thrown:\n//.\n//. ```javascript\n//. add (2, 2, 2);\n//. // ! TypeError: ‘add’ applied to the wrong number of arguments\n//. //\n//. //   add :: Number -> Number -> Number\n//. //          ^^^^^^\n//. //            1\n//. //\n//. //   Expected one argument but received three arguments:\n//. //\n//. //     - 2\n//. //     - 2\n//. //     - 2\n//. ```\n//.\n//. Applying `add` to one argument produces a function awaiting the remaining\n//. argument. This is known as partial application. Partial application allows\n//. more specific functions to be defined in terms of more general ones:\n//.\n//. ```javascript\n//. //    inc :: Number -> Number\n//. const inc = add (1);\n//.\n//. inc (7);\n//. // => 8\n//. ```\n//.\n//. JavaScript's implicit type coercion often obfuscates the source of type\n//. errors. Consider the following function:\n//.\n//. ```javascript\n//. //    _add :: Number -> Number -> Number\n//. const _add = x => y => x + y;\n//. ```\n//.\n//. The type signature indicates that `_add` takes arguments of type `Number`,\n//. but this is not enforced. This allows type errors to be silently ignored:\n//.\n//. ```javascript\n//. _add ('2') ('2');\n//. // => '22'\n//. ```\n//.\n//. `add`, on the other hand, throws if applied to arguments of the wrong\n//. types:\n//.\n//. ```javascript\n//. add ('2') ('2');\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: Number -> Number -> Number\n//. //          ^^^^^^\n//. //            1\n//. //\n//. //   1)  \"2\" :: String\n//. //\n//. //   The value at position 1 is not a member of ‘Number’.\n//. ```\n//.\n//. Type checking is performed as arguments are provided (rather than once all\n//. arguments have been provided), so type errors are reported early:\n//.\n//. ```javascript\n//. add ('X');\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: Number -> Number -> Number\n//. //          ^^^^^^\n//. //            1\n//. //\n//. //   1)  \"X\" :: String\n//. //\n//. //   The value at position 1 is not a member of ‘Number’.\n//. ```\n\n(function(f) {\n\n  /* istanbul ignore else */\n  {\n    module.exports = f (util,\n                        sanctuaryEither,\n                        sanctuaryShow,\n                        sanctuaryTypeClasses,\n                        sanctuaryTypeIdentifiers);\n  }\n\n} (function(util, Either, show, Z, type) {\n\n  var MAX_SAFE_INTEGER = Math.pow (2, 53) - 1;\n  var MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER;\n\n  var slice             = Array.prototype.slice;\n  var hasOwnProperty    = Object.prototype.hasOwnProperty;\n  var toString          = Object.prototype.toString;\n\n  var inspect = typeof util.inspect.custom === 'symbol' ?\n                util.inspect.custom :\n                /* istanbul ignore next */ 'inspect';\n\n  //  Left :: a -> Either a b\n  var Left = Either.Left;\n\n  //  Right :: b -> Either a b\n  var Right = Either.Right;\n\n  //  B :: (b -> c) -> (a -> b) -> a -> c\n  function B(f) {\n    return function(g) {\n      return function(x) {\n        return f (g (x));\n      };\n    };\n  }\n\n  //  I :: a -> a\n  function I(x) { return x; }\n\n  //  K :: a -> b -> a\n  function K(x) { return function(y) { return x; }; }\n\n  //  always0 :: a -> () -> a\n  function always0(x) { return function() { return x; }; }\n\n  //  always2 :: a -> (b, c) -> a\n  function always2(x) { return function(y, z) { return x; }; }\n\n  //  complement :: (a -> Boolean) -> a -> Boolean\n  function complement(pred) { return function(x) { return !(pred (x)); }; }\n\n  //  filter :: Filterable f => (a -> Boolean) -> f a -> f a\n  function filter(pred) {\n    return function(xs) {\n      return Z.filter (pred, xs);\n    };\n  }\n\n  //  init :: Array a -> Array a\n  function init(xs) { return xs.slice (0, -1); }\n\n  //  isEmpty :: Foldable f => f a -> Boolean\n  function isEmpty(xs) { return Z.size (xs) === 0; }\n\n  //  isPrefix :: Array a -> Array a -> Boolean\n  function isPrefix(candidate) {\n    return function(xs) {\n      if (candidate.length > xs.length) return false;\n      for (var idx = 0; idx < candidate.length; idx += 1) {\n        if (candidate[idx] !== xs[idx]) return false;\n      }\n      return true;\n    };\n  }\n\n  //  joinWith :: (String, Array String) -> String\n  function joinWith(separator, ss) {\n    return ss.join (separator);\n  }\n\n  //  last :: Array a -> a\n  function last(xs) { return xs[xs.length - 1]; }\n\n  //  memberOf :: Array a -> a -> Boolean\n  function memberOf(xs) {\n    return function(y) {\n      return xs.some (function(x) { return Z.equals (x, y); });\n    };\n  }\n\n  //  or :: (Array a, Array a) -> Array a\n  function or(xs, ys) { return isEmpty (xs) ? ys : xs; }\n\n  //  prop :: String -> {} -> a\n  function prop(field) { return function(record) { return record[field]; }; }\n\n  //  sizeEq :: Foldable f => Integer -> f a -> Boolean\n  function sizeEq(n) { return function(xs) { return Z.size (xs) === n; }; }\n\n  //  strRepeat :: (String, Integer) -> String\n  function strRepeat(s, times) {\n    return joinWith (s, Array (times + 1));\n  }\n\n  //  r :: Char -> String -> String\n  function r(c) {\n    return function(s) {\n      return strRepeat (c, s.length);\n    };\n  }\n\n  //  _ :: String -> String\n  var _ = r (' ');\n\n  //  sortedKeys :: Object -> Array String\n  function sortedKeys(o) {\n    return (Object.keys (o)).sort ();\n  }\n\n  //  toArray :: Foldable f => f a -> Array a\n  function toArray(foldable) {\n    return Array.isArray (foldable) ?\n           foldable :\n           Z.reduce (function(xs, x) { xs.push (x); return xs; },\n                     [],\n                     foldable);\n  }\n\n  //  toMarkdownList :: (String, String, a -> String, Array a) -> String\n  function toMarkdownList(empty, s, f, xs) {\n    return isEmpty (xs) ?\n      empty :\n      Z.reduce (function(s, x) { return s + '  - ' + f (x) + '\\n'; }, s, xs);\n  }\n\n  //  trimTrailingSpaces :: String -> String\n  function trimTrailingSpaces(s) {\n    return s.replace (/[ ]+$/gm, '');\n  }\n\n  //  when :: Boolean -> (a -> a) -> a -> a\n  function when(bool) {\n    return function(f) {\n      return function(x) {\n        return bool ? f (x) : x;\n      };\n    };\n  }\n\n  //  wrap :: String -> String -> String -> String\n  function wrap(prefix) {\n    return function(suffix) {\n      return function(s) {\n        return prefix + s + suffix;\n      };\n    };\n  }\n\n  //  parenthesize :: (String -> String) -> String -> String\n  function parenthesize(f) { return wrap (f ('(')) (f (')')); }\n\n  //  q :: String -> String\n  var q = wrap ('\\u2018') ('\\u2019');\n\n  //  stripNamespace :: TypeClass -> String\n  function stripNamespace(typeClass) {\n    return typeClass.name.slice (typeClass.name.indexOf ('/') + 1);\n  }\n\n  function _test(env) {\n    return function(x) {\n      return function recur(t) {\n        return t.supertypes.every (recur) && t._test (env) (x);\n      };\n    };\n  }\n\n  var Type$prototype = {\n    'constructor': {'@@type': 'sanctuary-def/Type@1'},\n    'validate': function(env) {\n      var test2 = _test (env);\n      var type = this;\n      return function(x) {\n        if (!(test2 (x) (type))) return Left ({value: x, propPath: []});\n        for (var idx = 0; idx < type.keys.length; idx += 1) {\n          var k = type.keys[idx];\n          var t = type.types[k];\n          var ys = type.extractors[k] (x);\n          for (var idx2 = 0; idx2 < ys.length; idx2 += 1) {\n            var result = t.validate (env) (ys[idx2]);\n            if (result.isLeft) {\n              return Left ({value: result.value.value,\n                            propPath: Z.concat ([k], result.value.propPath)});\n            }\n          }\n        }\n        return Right (x);\n      };\n    },\n    'fantasy-land/equals': function(other) {\n      return (\n        Z.equals (this.type, other.type) &&\n        Z.equals (this.name, other.name) &&\n        Z.equals (this.url, other.url) &&\n        Z.equals (this.supertypes, other.supertypes) &&\n        Z.equals (this.keys, other.keys) &&\n        Z.equals (this.types, other.types)\n      );\n    },\n    '@@show': function() {\n      return this.format (I, K (I));\n    }\n  };\n\n  //  _Type :: ... -> Type\n  function _Type(\n    type,       // :: String\n    name,       // :: String\n    url,        // :: String\n    arity,      // :: NonNegativeInteger\n    format,\n    // :: Nullable ((String -> String, String -> String -> String) -> String)\n    supertypes, // :: Array Type\n    test,       // :: Any -> Boolean\n    tuples      // :: Array (Array3 String (a -> Array b) Type)\n  ) {\n    var t = Object.create (Type$prototype);\n    t._test = test;\n    t._extractors = tuples.reduce (function(_extractors, tuple) {\n      _extractors[tuple[0]] = tuple[1];\n      return _extractors;\n    }, {});\n    t.arity = arity;  // number of type parameters\n    t.extractors = Z.map (B (toArray), t._extractors);\n    t.format = format || function(outer, inner) {\n      return Z.reduce (function(s, tuple) {\n        return s +\n               outer (' ') +\n               when (tuple[2].arity > 0)\n                    (parenthesize (outer))\n                    (inner (tuple[0]) (show (tuple[2])));\n      }, outer (name), tuples);\n    };\n    t.keys = tuples.map (function(tuple) { return tuple[0]; });\n    t.name = name;\n    t.supertypes = supertypes;\n    t.type = type;\n    t.types = tuples.reduce (function(types, tuple) {\n      types[tuple[0]] = tuple[2];\n      return types;\n    }, {});\n    t.url = url;\n    return t;\n  }\n\n  var BINARY        = 'BINARY';\n  var FUNCTION      = 'FUNCTION';\n  var INCONSISTENT  = 'INCONSISTENT';\n  var NO_ARGUMENTS  = 'NO_ARGUMENTS';\n  var NULLARY       = 'NULLARY';\n  var RECORD        = 'RECORD';\n  var UNARY         = 'UNARY';\n  var UNKNOWN       = 'UNKNOWN';\n  var VARIABLE      = 'VARIABLE';\n\n  //  Inconsistent :: Type\n  var Inconsistent =\n  _Type (INCONSISTENT, '', '', 0, always2 ('???'), [], K (K (false)), []);\n\n  //  NoArguments :: Type\n  var NoArguments =\n  _Type (NO_ARGUMENTS, '', '', 0, always2 ('()'), [], K (K (true)), []);\n\n  //  arityGte :: NonNegativeInteger -> Type -> Boolean\n  function arityGte(n) {\n    return function(t) {\n      return t.arity >= n;\n    };\n  }\n\n  //  typeEq :: String -> a -> Boolean\n  function typeEq(name) {\n    return function(x) {\n      return type (x) === name;\n    };\n  }\n\n  //  typeofEq :: String -> a -> Boolean\n  function typeofEq(typeof_) {\n    return function(x) {\n      // eslint-disable-next-line valid-typeof\n      return typeof x === typeof_;\n    };\n  }\n\n  //  functionUrl :: String -> String\n  function functionUrl(name) {\n    var version = '0.20.1';  // updated programmatically\n    return 'https://github.com/sanctuary-js/sanctuary-def/tree/v' + version +\n           '#' + name;\n  }\n\n  var NullaryTypeWithUrl = Z.ap (NullaryType, functionUrl);\n  var UnaryTypeWithUrl = Z.ap (UnaryType, functionUrl);\n  var BinaryTypeWithUrl = Z.ap (BinaryType, functionUrl);\n\n  //. ### Types\n  //.\n  //. Conceptually, a type is a set of values. One can think of a value of\n  //. type `Type` as a function of type `Any -> Boolean` that tests values\n  //. for membership in the set (though this is an oversimplification).\n\n  //# Unknown :: Type\n  //.\n  //. Type used to represent missing type information. The type of `[]`,\n  //. for example, is `Array ???`.\n  //.\n  //. May be used with type constructors when defining environments. Given a\n  //. type constructor `List :: Type -> Type`, one could use `List ($.Unknown)`\n  //. to include an infinite number of types in an environment:\n  //.\n  //.   - `List Number`\n  //.   - `List String`\n  //.   - `List (List Number)`\n  //.   - `List (List String)`\n  //.   - `List (List (List Number))`\n  //.   - `List (List (List String))`\n  //.   - `...`\n  var Unknown =\n  _Type (UNKNOWN, '', '', 0, always2 ('Unknown'), [], K (K (true)), []);\n\n  //# Any :: Type\n  //.\n  //. Type comprising every JavaScript value.\n  var Any = NullaryTypeWithUrl\n    ('Any')\n    ([])\n    (K (true));\n\n  //# AnyFunction :: Type\n  //.\n  //. Type comprising every Function value.\n  var AnyFunction = NullaryTypeWithUrl\n    ('Function')\n    ([])\n    (typeofEq ('function'));\n\n  //# Arguments :: Type\n  //.\n  //. Type comprising every [`arguments`][arguments] object.\n  var Arguments = NullaryTypeWithUrl\n    ('Arguments')\n    ([])\n    (typeEq ('Arguments'));\n\n  //# Array :: Type -> Type\n  //.\n  //. Constructor for homogeneous Array types.\n  var Array_ = UnaryTypeWithUrl\n    ('Array')\n    ([])\n    (typeEq ('Array'))\n    (I);\n\n  //# Array0 :: Type\n  //.\n  //. Type whose sole member is `[]`.\n  var Array0 = NullaryTypeWithUrl\n    ('Array0')\n    ([Array_ (Unknown)])\n    (sizeEq (0));\n\n  //# Array1 :: Type -> Type\n  //.\n  //. Constructor for singleton Array types.\n  var Array1 = UnaryTypeWithUrl\n    ('Array1')\n    ([Array_ (Unknown)])\n    (sizeEq (1))\n    (I);\n\n  //# Array2 :: Type -> Type -> Type\n  //.\n  //. Constructor for heterogeneous Array types of length 2. `['foo', true]` is\n  //. a member of `Array2 String Boolean`.\n  var Array2 = BinaryTypeWithUrl\n    ('Array2')\n    ([Array_ (Unknown)])\n    (sizeEq (2))\n    (function(array2) { return [array2[0]]; })\n    (function(array2) { return [array2[1]]; });\n\n  //# Boolean :: Type\n  //.\n  //. Type comprising `true` and `false`.\n  var Boolean_ = NullaryTypeWithUrl\n    ('Boolean')\n    ([])\n    (typeofEq ('boolean'));\n\n  //# Date :: Type\n  //.\n  //. Type comprising every Date value.\n  var Date_ = NullaryTypeWithUrl\n    ('Date')\n    ([])\n    (typeEq ('Date'));\n\n  //# ValidDate :: Type\n  //.\n  //. Type comprising every [`Date`][] value except `new Date (NaN)`.\n  var ValidDate = NullaryTypeWithUrl\n    ('ValidDate')\n    ([Date_])\n    (B (complement (isNaN)) (Number));\n\n  //# Descending :: Type -> Type\n  //.\n  //. [Descending][] type constructor.\n  var Descending = UnaryTypeWithUrl\n    ('Descending')\n    ([])\n    (typeEq ('sanctuary-descending/Descending@1'))\n    (I);\n\n  //# Either :: Type -> Type -> Type\n  //.\n  //. [Either][] type constructor.\n  var Either_ = BinaryTypeWithUrl\n    ('Either')\n    ([])\n    (typeEq ('sanctuary-either/Either@1'))\n    (function(either) { return either.isLeft ? [either.value] : []; })\n    (function(either) { return either.isLeft ? [] : [either.value]; });\n\n  //# Error :: Type\n  //.\n  //. Type comprising every Error value, including values of more specific\n  //. constructors such as [`SyntaxError`][] and [`TypeError`][].\n  var Error_ = NullaryTypeWithUrl\n    ('Error')\n    ([])\n    (typeEq ('Error'));\n\n  //# Fn :: Type -> Type -> Type\n  //.\n  //. Binary type constructor for unary function types. `$.Fn (I) (O)`\n  //. represents `I -> O`, the type of functions that take a value of\n  //. type `I` and return a value of type `O`.\n  function Fn($1) { return function($2) { return Function_ ([$1, $2]); }; }\n\n  //# Function :: NonEmpty (Array Type) -> Type\n  //.\n  //. Constructor for Function types.\n  //.\n  //. Examples:\n  //.\n  //.   - `$.Function ([$.Date, $.String])` represents the `Date -> String`\n  //.     type; and\n  //.   - `$.Function ([a, b, a])` represents the `(a, b) -> a` type.\n  function Function_(types) {\n    var tuples = Z.reduce (function(tuples, t) {\n      tuples.push (['$' + show (tuples.length + 1), K ([]), t]);\n      return tuples;\n    }, [], types);\n\n    function format(outer, inner) {\n      return when (tuples.length !== 2)\n                  (parenthesize (outer))\n                  (joinWith (outer (', '),\n                             Z.map (function(tuple) {\n                               return when (tuple[2].type === FUNCTION)\n                                           (parenthesize (outer))\n                                           (inner (tuple[0])\n                                                  (show (tuple[2])));\n                             }, init (tuples)))) +\n             outer (' -> ') +\n             inner ((last (tuples))[0])\n                   (show ((last (tuples))[2]));\n    }\n\n    return _Type (FUNCTION,\n                  '',\n                  '',\n                  types.length,\n                  format,\n                  [AnyFunction],\n                  K (K (true)),\n                  tuples);\n  }\n\n  //# HtmlElement :: Type\n  //.\n  //. Type comprising every [HTML element][].\n  var HtmlElement = NullaryTypeWithUrl\n    ('HtmlElement')\n    ([])\n    (function(x) {\n       return /^\\[object HTML.+Element\\]$/.test (toString.call (x));\n     });\n\n  //# Identity :: Type -> Type\n  //.\n  //. [Identity][] type constructor.\n  var Identity = UnaryTypeWithUrl\n    ('Identity')\n    ([])\n    (typeEq ('sanctuary-identity/Identity@1'))\n    (I);\n\n  //# Maybe :: Type -> Type\n  //.\n  //. [Maybe][] type constructor.\n  var Maybe = UnaryTypeWithUrl\n    ('Maybe')\n    ([])\n    (typeEq ('sanctuary-maybe/Maybe@1'))\n    (I);\n\n  //# NonEmpty :: Type -> Type\n  //.\n  //. Constructor for non-empty types. `$.NonEmpty ($.String)`, for example, is\n  //. the type comprising every [`String`][] value except `''`.\n  //.\n  //. The given type must satisfy the [Monoid][] and [Setoid][] specifications.\n  var NonEmpty = UnaryTypeWithUrl\n    ('NonEmpty')\n    ([])\n    (function(x) {\n       return Z.Monoid.test (x) &&\n              Z.Setoid.test (x) &&\n              !(Z.equals (x, Z.empty (x.constructor)));\n     })\n    (function(monoid) { return [monoid]; });\n\n  //# Null :: Type\n  //.\n  //. Type whose sole member is `null`.\n  var Null = NullaryTypeWithUrl\n    ('Null')\n    ([])\n    (typeEq ('Null'));\n\n  //# Nullable :: Type -> Type\n  //.\n  //. Constructor for types that include `null` as a member.\n  var Nullable = UnaryTypeWithUrl\n    ('Nullable')\n    ([])\n    (K (true))\n    (function(nullable) {\n       // eslint-disable-next-line eqeqeq\n       return nullable === null ? [] : [nullable];\n     });\n\n  //# Number :: Type\n  //.\n  //. Type comprising every primitive Number value (including `NaN`).\n  var Number_ = NullaryTypeWithUrl\n    ('Number')\n    ([])\n    (typeofEq ('number'));\n\n  function nonZero(x) { return x !== 0; }\n  function nonNegative(x) { return x >= 0; }\n  function positive(x) { return x > 0; }\n  function negative(x) { return x < 0; }\n\n  //# PositiveNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value greater than zero.\n  var PositiveNumber = NullaryTypeWithUrl\n    ('PositiveNumber')\n    ([Number_])\n    (positive);\n\n  //# NegativeNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value less than zero.\n  var NegativeNumber = NullaryTypeWithUrl\n    ('NegativeNumber')\n    ([Number_])\n    (negative);\n\n  //# ValidNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value except `NaN`.\n  var ValidNumber = NullaryTypeWithUrl\n    ('ValidNumber')\n    ([Number_])\n    (complement (isNaN));\n\n  //# NonZeroValidNumber :: Type\n  //.\n  //. Type comprising every [`ValidNumber`][] value except `0` and `-0`.\n  var NonZeroValidNumber = NullaryTypeWithUrl\n    ('NonZeroValidNumber')\n    ([ValidNumber])\n    (nonZero);\n\n  //# FiniteNumber :: Type\n  //.\n  //. Type comprising every [`ValidNumber`][] value except `Infinity` and\n  //. `-Infinity`.\n  var FiniteNumber = NullaryTypeWithUrl\n    ('FiniteNumber')\n    ([ValidNumber])\n    (isFinite);\n\n  //# NonZeroFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value except `0` and `-0`.\n  var NonZeroFiniteNumber = NullaryTypeWithUrl\n    ('NonZeroFiniteNumber')\n    ([FiniteNumber])\n    (nonZero);\n\n  //# PositiveFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value greater than zero.\n  var PositiveFiniteNumber = NullaryTypeWithUrl\n    ('PositiveFiniteNumber')\n    ([FiniteNumber])\n    (positive);\n\n  //# NegativeFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value less than zero.\n  var NegativeFiniteNumber = NullaryTypeWithUrl\n    ('NegativeFiniteNumber')\n    ([FiniteNumber])\n    (negative);\n\n  //# Integer :: Type\n  //.\n  //. Type comprising every integer in the range\n  //. [[`Number.MIN_SAFE_INTEGER`][min] .. [`Number.MAX_SAFE_INTEGER`][max]].\n  var Integer = NullaryTypeWithUrl\n    ('Integer')\n    ([ValidNumber])\n    (function(x) {\n       return Math.floor (x) === x &&\n              x >= MIN_SAFE_INTEGER &&\n              x <= MAX_SAFE_INTEGER;\n     });\n\n  //# NonZeroInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value except `0` and `-0`.\n  var NonZeroInteger = NullaryTypeWithUrl\n    ('NonZeroInteger')\n    ([Integer])\n    (nonZero);\n\n  //# NonNegativeInteger :: Type\n  //.\n  //. Type comprising every non-negative [`Integer`][] value (including `-0`).\n  //. Also known as the set of natural numbers under ISO 80000-2:2009.\n  var NonNegativeInteger = NullaryTypeWithUrl\n    ('NonNegativeInteger')\n    ([Integer])\n    (nonNegative);\n\n  //# PositiveInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value greater than zero.\n  var PositiveInteger = NullaryTypeWithUrl\n    ('PositiveInteger')\n    ([Integer])\n    (positive);\n\n  //# NegativeInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value less than zero.\n  var NegativeInteger = NullaryTypeWithUrl\n    ('NegativeInteger')\n    ([Integer])\n    (negative);\n\n  //# Object :: Type\n  //.\n  //. Type comprising every \"plain\" Object value. Specifically, values\n  //. created via:\n  //.\n  //.   - object literal syntax;\n  //.   - [`Object.create`][]; or\n  //.   - the `new` operator in conjunction with `Object` or a custom\n  //.     constructor function.\n  var Object_ = NullaryTypeWithUrl\n    ('Object')\n    ([])\n    (typeEq ('Object'));\n\n  //# Pair :: Type -> Type -> Type\n  //.\n  //. [Pair][] type constructor.\n  var Pair = BinaryTypeWithUrl\n    ('Pair')\n    ([])\n    (typeEq ('sanctuary-pair/Pair@1'))\n    (function(pair) { return [pair.fst]; })\n    (function(pair) { return [pair.snd]; });\n\n  //# RegExp :: Type\n  //.\n  //. Type comprising every RegExp value.\n  var RegExp_ = NullaryTypeWithUrl\n    ('RegExp')\n    ([])\n    (typeEq ('RegExp'));\n\n  //# GlobalRegExp :: Type\n  //.\n  //. Type comprising every [`RegExp`][] value whose `global` flag is `true`.\n  //.\n  //. See also [`NonGlobalRegExp`][].\n  var GlobalRegExp = NullaryTypeWithUrl\n    ('GlobalRegExp')\n    ([RegExp_])\n    (prop ('global'));\n\n  //# NonGlobalRegExp :: Type\n  //.\n  //. Type comprising every [`RegExp`][] value whose `global` flag is `false`.\n  //.\n  //. See also [`GlobalRegExp`][].\n  var NonGlobalRegExp = NullaryTypeWithUrl\n    ('NonGlobalRegExp')\n    ([RegExp_])\n    (complement (prop ('global')));\n\n  //# StrMap :: Type -> Type\n  //.\n  //. Constructor for homogeneous Object types.\n  //.\n  //. `{foo: 1, bar: 2, baz: 3}`, for example, is a member of `StrMap Number`;\n  //. `{foo: 1, bar: 2, baz: 'XXX'}` is not.\n  var StrMap = UnaryTypeWithUrl\n    ('StrMap')\n    ([Object_])\n    (K (true))\n    (I);\n\n  //# String :: Type\n  //.\n  //. Type comprising every primitive String value.\n  var String_ = NullaryTypeWithUrl\n    ('String')\n    ([])\n    (typeofEq ('string'));\n\n  //# RegexFlags :: Type\n  //.\n  //. Type comprising the canonical RegExp flags:\n  //.\n  //.   - `''`\n  //.   - `'g'`\n  //.   - `'i'`\n  //.   - `'m'`\n  //.   - `'gi'`\n  //.   - `'gm'`\n  //.   - `'im'`\n  //.   - `'gim'`\n  var RegexFlags = NullaryTypeWithUrl\n    ('RegexFlags')\n    ([String_])\n    (function(s) { return /^g?i?m?$/.test (s); });\n\n  //# Symbol :: Type\n  //.\n  //. Type comprising every Symbol value.\n  var Symbol_ = NullaryTypeWithUrl\n    ('Symbol')\n    ([])\n    (typeofEq ('symbol'));\n\n  //# Type :: Type\n  //.\n  //. Type comprising every `Type` value.\n  var Type = NullaryTypeWithUrl\n    ('Type')\n    ([])\n    (typeEq ('sanctuary-def/Type@1'));\n\n  //# TypeClass :: Type\n  //.\n  //. Type comprising every [`TypeClass`][] value.\n  var TypeClass = NullaryTypeWithUrl\n    ('TypeClass')\n    ([])\n    (typeEq ('sanctuary-type-classes/TypeClass@1'));\n\n  //# Undefined :: Type\n  //.\n  //. Type whose sole member is `undefined`.\n  var Undefined = NullaryTypeWithUrl\n    ('Undefined')\n    ([])\n    (typeEq ('Undefined'));\n\n  //# env :: Array Type\n  //.\n  //. An array of [types][]:\n  //.\n  //.   - <code>[AnyFunction](#AnyFunction)</code>\n  //.   - <code>[Arguments](#Arguments)</code>\n  //.   - <code>[Array](#Array) ([Unknown][])</code>\n  //.   - <code>[Array2](#Array2) ([Unknown][]) ([Unknown][])</code>\n  //.   - <code>[Boolean](#Boolean)</code>\n  //.   - <code>[Date](#Date)</code>\n  //.   - <code>[Descending](#Descending) ([Unknown][])</code>\n  //.   - <code>[Either](#Either) ([Unknown][]) ([Unknown][])</code>\n  //.   - <code>[Error](#Error)</code>\n  //.   - <code>[Fn](#Fn) ([Unknown][]) ([Unknown][])</code>\n  //.   - <code>[HtmlElement](#HtmlElement)</code>\n  //.   - <code>[Identity](#Identity) ([Unknown][])</code>\n  //.   - <code>[Maybe](#Maybe) ([Unknown][])</code>\n  //.   - <code>[Null](#Null)</code>\n  //.   - <code>[Number](#Number)</code>\n  //.   - <code>[Object](#Object)</code>\n  //.   - <code>[Pair](#Pair) ([Unknown][]) ([Unknown][])</code>\n  //.   - <code>[RegExp](#RegExp)</code>\n  //.   - <code>[StrMap](#StrMap) ([Unknown][])</code>\n  //.   - <code>[String](#String)</code>\n  //.   - <code>[Symbol](#Symbol)</code>\n  //.   - <code>[Type](#Type)</code>\n  //.   - <code>[TypeClass](#TypeClass)</code>\n  //.   - <code>[Undefined](#Undefined)</code>\n  var env = [\n    AnyFunction,\n    Arguments,\n    Array_ (Unknown),\n    Array2 (Unknown) (Unknown),\n    Boolean_,\n    Date_,\n    Descending (Unknown),\n    Either_ (Unknown) (Unknown),\n    Error_,\n    Fn (Unknown) (Unknown),\n    HtmlElement,\n    Identity (Unknown),\n    Maybe (Unknown),\n    Null,\n    Number_,\n    Object_,\n    Pair (Unknown) (Unknown),\n    RegExp_,\n    StrMap (Unknown),\n    String_,\n    Symbol_,\n    Type,\n    TypeClass,\n    Undefined\n  ];\n\n  //  Unchecked :: String -> Type\n  function Unchecked(s) { return NullaryType (s) ('') ([]) (K (true)); }\n\n  //  production :: Boolean\n  var production =\n    typeof process !== 'undefined' &&\n    /* global process:false */\n    process != null &&\n    process.env != null &&\n    process.env.NODE_ENV === 'production';\n\n  //  numbers :: Array String\n  var numbers = [\n    'zero',\n    'one',\n    'two',\n    'three',\n    'four',\n    'five',\n    'six',\n    'seven',\n    'eight',\n    'nine'\n  ];\n\n  //  numArgs :: Integer -> String\n  function numArgs(n) {\n    return (n < numbers.length ? numbers[n] : show (n)) + ' ' +\n           (n === 1 ? 'argument' : 'arguments');\n  }\n\n  //  expandUnknown\n  //  :: Array Type\n  //  -> Array Object\n  //  -> Any\n  //  -> (a -> Array b)\n  //  -> Type\n  //  -> Array Type\n  function expandUnknown(env) {\n    return function(seen) {\n      return function(value) {\n        return function(extractor) {\n          return function(type) {\n            return type.type === UNKNOWN ?\n                   _determineActualTypes (env, seen, extractor (value)) :\n                   [type];\n          };\n        };\n      };\n    };\n  }\n\n  //  _determineActualTypes :: ... -> Array Type\n  function _determineActualTypes(\n    env,            // :: Array Type\n    seen,           // :: Array Object\n    values          // :: Array Any\n  ) {\n    var expandUnknown4 = expandUnknown (env);\n\n    function refine(types, value) {\n      var seen$;\n      if (typeof value === 'object' && value != null ||\n          typeof value === 'function') {\n        //  Abort if a circular reference is encountered; add the current\n        //  object to the array of seen objects otherwise.\n        if (seen.indexOf (value) >= 0) return [];\n        seen$ = Z.concat (seen, [value]);\n      } else {\n        seen$ = seen;\n      }\n      var expandUnknown2 = expandUnknown4 (seen$) (value);\n      return Z.chain (function(t) {\n        return (\n          (t.validate (env) (value)).isLeft ?\n            [] :\n          t.type === UNARY ?\n            Z.map (fromUnaryType (t),\n                   expandUnknown2 (t.extractors.$1) (t.types.$1)) :\n          t.type === BINARY ?\n            Z.lift2 (fromBinaryType (t),\n                     expandUnknown2 (t.extractors.$1) (t.types.$1),\n                     expandUnknown2 (t.extractors.$2) (t.types.$2)) :\n          // else\n            [t]\n        );\n      }, types);\n    }\n\n    return isEmpty (values) ?\n      [Unknown] :\n      or (Z.reduce (refine, env, values), [Inconsistent]);\n  }\n\n  //  isConsistent :: Type -> Boolean\n  function isConsistent(t) {\n    return t.type === UNARY   ? isConsistent (t.types.$1) :\n           t.type === BINARY  ? isConsistent (t.types.$1) &&\n                                isConsistent (t.types.$2) :\n           /* else */           t.type !== INCONSISTENT;\n  }\n\n  //  determineActualTypesStrict :: (Array Type, Array Any) -> Array Type\n  function determineActualTypesStrict(env, values) {\n    return Z.filter (isConsistent,\n                     _determineActualTypes (env, [], values));\n  }\n\n  //  determineActualTypesLoose :: (Array Type, Array Any) -> Array Type\n  function determineActualTypesLoose(env, values) {\n    return Z.reject (function(t) { return t.type === INCONSISTENT; },\n                     _determineActualTypes (env, [], values));\n  }\n\n  //  TypeInfo = { name :: String\n  //             , constraints :: StrMap (Array TypeClass)\n  //             , types :: NonEmpty (Array Type) }\n  //\n  //  TypeVarMap = StrMap { types :: Array Type\n  //                      , valuesByPath :: StrMap (Array Any) }\n  //\n  //  PropPath = Array (Number | String)\n\n  //  updateTypeVarMap :: ... -> TypeVarMap\n  function updateTypeVarMap(\n    env,            // :: Array Type\n    typeVarMap,     // :: TypeVarMap\n    typeVar,        // :: Type\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    values          // :: Array Any\n  ) {\n    var $typeVarMap = {};\n    for (var typeVarName in typeVarMap) {\n      var entry = typeVarMap[typeVarName];\n      var $entry = {types: entry.types.slice (), valuesByPath: {}};\n      for (var k in entry.valuesByPath) {\n        $entry.valuesByPath[k] = entry.valuesByPath[k].slice ();\n      }\n      $typeVarMap[typeVarName] = $entry;\n    }\n    if (!(hasOwnProperty.call ($typeVarMap, typeVar.name))) {\n      $typeVarMap[typeVar.name] = {\n        types: Z.filter (arityGte (typeVar.arity), env),\n        valuesByPath: {}\n      };\n    }\n\n    var key = JSON.stringify (Z.concat ([index], propPath));\n    if (!(hasOwnProperty.call ($typeVarMap[typeVar.name].valuesByPath, key))) {\n      $typeVarMap[typeVar.name].valuesByPath[key] = [];\n    }\n\n    var isValid = test (env);\n\n    var expandUnknownStrict = B (B (B (filter (isConsistent))))\n                                (expandUnknown (env) ([]));\n\n    values.forEach (function(value) {\n      var expandUnknownStrict2 = expandUnknownStrict (value);\n      $typeVarMap[typeVar.name].valuesByPath[key].push (value);\n      $typeVarMap[typeVar.name].types = Z.chain (function(t) {\n        return (\n          !(isValid (t) (value)) ?\n            [] :\n          typeVar.arity === 0 && t.type === UNARY ?\n            Z.map (fromUnaryType (t),\n                   expandUnknownStrict2 (t.extractors.$1) (t.types.$1)) :\n          typeVar.arity === 0 && t.type === BINARY ?\n            Z.lift2 (fromBinaryType (t),\n                     expandUnknownStrict2 (t.extractors.$1) (t.types.$1),\n                     expandUnknownStrict2 (t.extractors.$2) (t.types.$2)) :\n          // else\n            [t]\n        );\n      }, $typeVarMap[typeVar.name].types);\n    });\n\n    return $typeVarMap;\n  }\n\n  //  underlineTypeVars :: (TypeInfo, StrMap (Array Any)) -> String\n  function underlineTypeVars(typeInfo, valuesByPath) {\n    //  Note: Sorting these keys lexicographically is not \"correct\", but it\n    //  does the right thing for indexes less than 10.\n    var paths = Z.map (JSON.parse, sortedKeys (valuesByPath));\n    return underline (\n      typeInfo,\n      K (K (_)),\n      function(index) {\n        return function(f) {\n          return function(t) {\n            return function(propPath) {\n              var indexedPropPath = Z.concat ([index], propPath);\n              return function(s) {\n                if (paths.some (isPrefix (indexedPropPath))) {\n                  var key = JSON.stringify (indexedPropPath);\n                  if (!(hasOwnProperty.call (valuesByPath, key))) return s;\n                  if (!(isEmpty (valuesByPath[key]))) return f (s);\n                }\n                return _ (s);\n              };\n            };\n          };\n        };\n      }\n    );\n  }\n\n  //  satisfactoryTypes :: ... -> Either (() -> Error)\n  //                                     { typeVarMap :: TypeVarMap\n  //                                     , types :: Array Type }\n  function satisfactoryTypes(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    typeVarMap,     // :: TypeVarMap\n    expType,        // :: Type\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    values          // :: Array Any\n  ) {\n    var recur = satisfactoryTypes;\n\n    for (var idx = 0; idx < values.length; idx += 1) {\n      var result = expType.validate (env) (values[idx]);\n      if (result.isLeft) {\n        return Left (function() {\n          return invalidValue (env,\n                               typeInfo,\n                               index,\n                               Z.concat (propPath, result.value.propPath),\n                               result.value.value);\n        });\n      }\n    }\n\n    switch (expType.type) {\n\n      case VARIABLE:\n        var typeVarName = expType.name;\n        var constraints = typeInfo.constraints;\n        if (hasOwnProperty.call (constraints, typeVarName)) {\n          var typeClasses = constraints[typeVarName];\n          for (idx = 0; idx < values.length; idx += 1) {\n            for (var idx2 = 0; idx2 < typeClasses.length; idx2 += 1) {\n              if (!(typeClasses[idx2].test (values[idx]))) {\n                return Left (function() {\n                  return typeClassConstraintViolation (\n                    env,\n                    typeInfo,\n                    typeClasses[idx2],\n                    index,\n                    propPath,\n                    values[idx]);\n                });\n              }\n            }\n          }\n        }\n\n        var typeVarMap$ = updateTypeVarMap (env,\n                                            typeVarMap,\n                                            expType,\n                                            index,\n                                            propPath,\n                                            values);\n\n        var okTypes = typeVarMap$[typeVarName].types;\n        return isEmpty (okTypes) ?\n          Left (function() {\n            return typeVarConstraintViolation (\n              env,\n              typeInfo,\n              index,\n              propPath,\n              typeVarMap$[typeVarName].valuesByPath\n            );\n          }) :\n          Z.reduce (function(e, t) {\n            return Z.chain (function(r) {\n              //  The `a` in `Functor f => f a` corresponds to the `a`\n              //  in `Maybe a` but to the `b` in `Either a b`. A type\n              //  variable's $1 will correspond to either $1 or $2 of\n              //  the actual type depending on the actual type's arity.\n              var offset = t.arity - expType.arity;\n              return expType.keys.reduce (function(e, k, idx) {\n                var extractor = t.extractors[t.keys[offset + idx]];\n                return Z.reduce (function(e, x) {\n                  return Z.chain (function(r) {\n                    return recur (env,\n                                  typeInfo,\n                                  r.typeVarMap,\n                                  expType.types[k],\n                                  index,\n                                  Z.concat (propPath, [k]),\n                                  [x]);\n                  }, e);\n                }, e, Z.chain (extractor, values));\n              }, Right (r));\n            }, e);\n          }, Right ({typeVarMap: typeVarMap$, types: okTypes}), okTypes);\n\n      case UNARY:\n        return Z.map (\n          function(result) {\n            return {\n              typeVarMap: result.typeVarMap,\n              types: Z.map (fromUnaryType (expType),\n                            or (result.types, [expType.types.$1]))\n            };\n          },\n          recur (env,\n                 typeInfo,\n                 typeVarMap,\n                 expType.types.$1,\n                 index,\n                 Z.concat (propPath, ['$1']),\n                 Z.chain (expType.extractors.$1, values))\n        );\n\n      case BINARY:\n        return Z.chain (\n          function(result) {\n            var $1s = result.types;\n            return Z.map (\n              function(result) {\n                var $2s = result.types;\n                return {\n                  typeVarMap: result.typeVarMap,\n                  types: Z.lift2 (fromBinaryType (expType),\n                                  or ($1s, [expType.types.$1]),\n                                  or ($2s, [expType.types.$2]))\n                };\n              },\n              recur (env,\n                     typeInfo,\n                     result.typeVarMap,\n                     expType.types.$2,\n                     index,\n                     Z.concat (propPath, ['$2']),\n                     Z.chain (expType.extractors.$2, values))\n            );\n          },\n          recur (env,\n                 typeInfo,\n                 typeVarMap,\n                 expType.types.$1,\n                 index,\n                 Z.concat (propPath, ['$1']),\n                 Z.chain (expType.extractors.$1, values))\n        );\n\n      case RECORD:\n        return Z.reduce (function(e, k) {\n          return Z.chain (function(r) {\n            return recur (env,\n                          typeInfo,\n                          r.typeVarMap,\n                          expType.types[k],\n                          index,\n                          Z.concat (propPath, [k]),\n                          Z.chain (expType.extractors[k], values));\n          }, e);\n        }, Right ({typeVarMap: typeVarMap, types: [expType]}), expType.keys);\n\n      default:\n        return Right ({typeVarMap: typeVarMap, types: [expType]});\n    }\n  }\n\n  //# test :: Array Type -> Type -> a -> Boolean\n  //.\n  //. Takes an environment, a type, and any value. Returns `true` if the value\n  //. is a member of the type; `false` otherwise.\n  //.\n  //. The environment is only significant if the type contains\n  //. [type variables][].\n  function test(env) {\n    return function(t) {\n      return function(x) {\n        var typeInfo = {name: 'name', constraints: {}, types: [t]};\n        return (satisfactoryTypes (env, typeInfo, {}, t, 0, [], [x])).isRight;\n      };\n    };\n  }\n\n  //. ### Type constructors\n  //.\n  //. sanctuary-def provides several functions for defining types.\n\n  //# NullaryType :: String -> String -> Array Type -> (Any -> Boolean) -> Type\n  //.\n  //. Type constructor for types with no type variables (such as [`Number`][]).\n  //.\n  //. To define a nullary type `t` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - an array of supertypes (exposed as `t.supertypes`); and\n  //.\n  //.   - a predicate that accepts any value that is a member of every one of\n  //.     the given supertypes, and returns `true` if (and only if) the value\n  //.     is a member of `t`.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Integer :: Type\n  //. const Integer = $.NullaryType\n  //.   ('Integer')\n  //.   ('http://example.com/my-package#Integer')\n  //.   ([])\n  //.   (x => typeof x === 'number' &&\n  //.         Math.floor (x) === x &&\n  //.         x >= Number.MIN_SAFE_INTEGER &&\n  //.         x <= Number.MAX_SAFE_INTEGER);\n  //.\n  //. //    NonZeroInteger :: Type\n  //. const NonZeroInteger = $.NullaryType\n  //.   ('NonZeroInteger')\n  //.   ('http://example.com/my-package#NonZeroInteger')\n  //.   ([Integer])\n  //.   (x => x !== 0);\n  //.\n  //. //    rem :: Integer -> NonZeroInteger -> Integer\n  //. const rem =\n  //. def ('rem')\n  //.     ({})\n  //.     ([Integer, NonZeroInteger, Integer])\n  //.     (x => y => x % y);\n  //.\n  //. rem (42) (5);\n  //. // => 2\n  //.\n  //. rem (0.5);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   rem :: Integer -> NonZeroInteger -> Integer\n  //. //          ^^^^^^^\n  //. //             1\n  //. //\n  //. //   1)  0.5 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of ‘Integer’.\n  //. //\n  //. //   See http://example.com/my-package#Integer for information about the Integer type.\n  //.\n  //. rem (42) (0);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   rem :: Integer -> NonZeroInteger -> Integer\n  //. //                     ^^^^^^^^^^^^^^\n  //. //                           1\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of ‘NonZeroInteger’.\n  //. //\n  //. //   See http://example.com/my-package#NonZeroInteger for information about the NonZeroInteger type.\n  //. ```\n  function NullaryType(name) {\n    return function(url) {\n      return function(supertypes) {\n        return function(test) {\n          return _Type (NULLARY, name, url, 0, null, supertypes, K (test), []);\n        };\n      };\n    };\n  }\n\n  //# UnaryType :: Foldable f => String -> String -> Array Type -> (Any -> Boolean) -> (t a -> f a) -> Type -> Type\n  //.\n  //. Type constructor for types with one type variable (such as [`Array`][]).\n  //.\n  //. To define a unary type `t a` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - an array of supertypes (exposed as `t.supertypes`);\n  //.\n  //.   - a predicate that accepts any value that is a member of every one of\n  //.     the given supertypes, and returns `true` if (and only if) the value\n  //.     is a member of `t x` for some type `x`;\n  //.\n  //.   - a function that takes any value of type `t a` and returns the values\n  //.     of type `a` contained in the `t`; and\n  //.\n  //.   - the type of `a`.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. const show = require ('sanctuary-show');\n  //. const type = require ('sanctuary-type-identifiers');\n  //.\n  //. //    MaybeTypeRep :: TypeRep Maybe\n  //. const MaybeTypeRep = {'@@type': 'my-package/Maybe'};\n  //.\n  //. //    Maybe :: Type -> Type\n  //. const Maybe = $.UnaryType\n  //.   ('Maybe')\n  //.   ('http://example.com/my-package#Maybe')\n  //.   ([])\n  //.   (x => type (x) === MaybeTypeRep['@@type'])\n  //.   (maybe => maybe.isJust ? [maybe.value] : []);\n  //.\n  //. //    Nothing :: Maybe a\n  //. const Nothing = {\n  //.   'constructor': MaybeTypeRep,\n  //.   'isJust': false,\n  //.   'isNothing': true,\n  //.   '@@show': () => 'Nothing',\n  //. };\n  //.\n  //. //    Just :: a -> Maybe a\n  //. const Just = x => ({\n  //.   'constructor': MaybeTypeRep,\n  //.   'isJust': true,\n  //.   'isNothing': false,\n  //.   '@@show': () => `Just (${show (x)})`,\n  //.   'value': x,\n  //. });\n  //.\n  //. //    fromMaybe :: a -> Maybe a -> a\n  //. const fromMaybe =\n  //. def ('fromMaybe')\n  //.     ({})\n  //.     ([a, Maybe (a), a])\n  //.     (x => m => m.isJust ? m.value : x);\n  //.\n  //. fromMaybe (0) (Just (42));\n  //. // => 42\n  //.\n  //. fromMaybe (0) (Nothing);\n  //. // => 0\n  //.\n  //. fromMaybe (0) (Just ('XXX'));\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   fromMaybe :: a -> Maybe a -> a\n  //. //                ^          ^\n  //. //                1          2\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   2)  \"XXX\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  function UnaryType(name) {\n    return function(url) {\n      return function(supertypes) {\n        return function(test) {\n          return function(_1) {\n            return function($1) {\n              return _Type (UNARY,\n                            name,\n                            url,\n                            1,\n                            null,\n                            supertypes,\n                            K (test),\n                            [['$1', _1, $1]]);\n            };\n          };\n        };\n      };\n    };\n  }\n\n  //  fromUnaryType :: Type -> Type -> Type\n  function fromUnaryType(t) {\n    return UnaryType (t.name)\n                     (t.url)\n                     (t.supertypes)\n                     (t._test ([]))\n                     (t._extractors.$1);\n  }\n\n  //# BinaryType :: Foldable f => String -> String -> Array Type -> (Any -> Boolean) -> (t a b -> f a) -> (t a b -> f b) -> Type -> Type -> Type\n  //.\n  //. Type constructor for types with two type variables (such as\n  //. [`Array2`][]).\n  //.\n  //. To define a binary type `t a b` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - an array of supertypes (exposed as `t.supertypes`);\n  //.\n  //.   - a predicate that accepts any value that is a member of every one of\n  //.     the given supertypes, and returns `true` if (and only if) the value\n  //.     is a member of `t x y` for some types `x` and `y`;\n  //.\n  //.   - a function that takes any value of type `t a b` and returns the\n  //.     values of type `a` contained in the `t`;\n  //.\n  //.   - a function that takes any value of type `t a b` and returns the\n  //.     values of type `b` contained in the `t`;\n  //.\n  //.   - the type of `a`; and\n  //.\n  //.   - the type of `b`.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. const type = require ('sanctuary-type-identifiers');\n  //.\n  //. //    PairTypeRep :: TypeRep Pair\n  //. const PairTypeRep = {'@@type': 'my-package/Pair'};\n  //.\n  //. //    $Pair :: Type -> Type -> Type\n  //. const $Pair = $.BinaryType\n  //.   ('Pair')\n  //.   ('http://example.com/my-package#Pair')\n  //.   ([])\n  //.   (x => type (x) === PairTypeRep['@@type'])\n  //.   (({fst}) => [fst])\n  //.   (({snd}) => [snd]);\n  //.\n  //. //    Pair :: a -> b -> Pair a b\n  //. const Pair =\n  //. def ('Pair')\n  //.     ({})\n  //.     ([a, b, $Pair (a) (b)])\n  //.     (fst => snd => ({\n  //.        'constructor': PairTypeRep,\n  //.        'fst': fst,\n  //.        'snd': snd,\n  //.        '@@show': () => `Pair (${show (fst)}) (${show (snd)})`,\n  //.      }));\n  //.\n  //. //    Rank :: Type\n  //. const Rank = $.NullaryType\n  //.   ('Rank')\n  //.   ('http://example.com/my-package#Rank')\n  //.   ([$.String])\n  //.   (x => /^(A|2|3|4|5|6|7|8|9|10|J|Q|K)$/.test (x));\n  //.\n  //. //    Suit :: Type\n  //. const Suit = $.NullaryType\n  //.   ('Suit')\n  //.   ('http://example.com/my-package#Suit')\n  //.   ([$.String])\n  //.   (x => /^[\\u2660\\u2663\\u2665\\u2666]$/.test (x));\n  //.\n  //. //    Card :: Type\n  //. const Card = $Pair (Rank) (Suit);\n  //.\n  //. //    showCard :: Card -> String\n  //. const showCard =\n  //. def ('showCard')\n  //.     ({})\n  //.     ([Card, $.String])\n  //.     (card => card.fst + card.snd);\n  //.\n  //. showCard (Pair ('A') ('♠'));\n  //. // => 'A♠'\n  //.\n  //. showCard (Pair ('X') ('♠'));\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   showCard :: Pair Rank Suit -> String\n  //. //                    ^^^^\n  //. //                     1\n  //. //\n  //. //   1)  \"X\" :: String\n  //. //\n  //. //   The value at position 1 is not a member of ‘Rank’.\n  //. //\n  //. //   See http://example.com/my-package#Rank for information about the Rank type.\n  //. ```\n  function BinaryType(name) {\n    return function(url) {\n      return function(supertypes) {\n        return function(test) {\n          return function(_1) {\n            return function(_2) {\n              return function($1) {\n                return function($2) {\n                  return _Type (BINARY,\n                                name,\n                                url,\n                                2,\n                                null,\n                                supertypes,\n                                K (test),\n                                [['$1', _1, $1],\n                                 ['$2', _2, $2]]);\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  }\n\n  //  fromBinaryType :: (Type -> Type -> Type) -> Type -> Type -> Type\n  function fromBinaryType(t) {\n    return BinaryType (t.name)\n                      (t.url)\n                      (t.supertypes)\n                      (t._test ([]))\n                      (t._extractors.$1)\n                      (t._extractors.$2);\n  }\n\n  //# EnumType :: String -> String -> Array Any -> Type\n  //.\n  //. Type constructor for [enumerated types][] (such as [`RegexFlags`][]).\n  //.\n  //. To define an enumerated type `t` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`); and\n  //.\n  //.   - an array of distinct values.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Denomination :: Type\n  //. const Denomination = $.EnumType\n  //.   ('Denomination')\n  //.   ('http://example.com/my-package#Denomination')\n  //.   ([10, 20, 50, 100, 200]);\n  //. ```\n  function EnumType(name) {\n    return function(url) {\n      return B (NullaryType (name) (url) ([])) (memberOf);\n    };\n  }\n\n  //# RecordType :: StrMap Type -> Type\n  //.\n  //. `RecordType` is used to construct anonymous record types. The type\n  //. definition specifies the name and type of each required field. A field is\n  //. an enumerable property (either an own property or an inherited property).\n  //.\n  //. To define an anonymous record type one must provide:\n  //.\n  //.   - an object mapping field name to type.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Point :: Type\n  //. const Point = $.RecordType ({x: $.FiniteNumber, y: $.FiniteNumber});\n  //.\n  //. //    dist :: Point -> Point -> FiniteNumber\n  //. const dist =\n  //. def ('dist')\n  //.     ({})\n  //.     ([Point, Point, $.FiniteNumber])\n  //.     (p => q => Math.sqrt (Math.pow (p.x - q.x, 2) +\n  //.                           Math.pow (p.y - q.y, 2)));\n  //.\n  //. dist ({x: 0, y: 0}) ({x: 3, y: 4});\n  //. // => 5\n  //.\n  //. dist ({x: 0, y: 0}) ({x: 3, y: 4, color: 'red'});\n  //. // => 5\n  //.\n  //. dist ({x: 0, y: 0}) ({x: NaN, y: NaN});\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber\n  //. //                                                              ^^^^^^^^^^^^\n  //. //                                                                   1\n  //. //\n  //. //   1)  NaN :: Number\n  //. //\n  //. //   The value at position 1 is not a member of ‘FiniteNumber’.\n  //.\n  //. dist (0);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber\n  //. //           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  //. //                              1\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of ‘{ x :: FiniteNumber, y :: FiniteNumber }’.\n  //. ```\n  function RecordType(fields) {\n    var keys = sortedKeys (fields);\n\n    function format(outer, inner) {\n      if (isEmpty (keys)) return outer ('{}');\n      var reprs = Z.map (function(k) {\n        var t = fields[k];\n        return outer (' ') +\n               outer (/^(?!\\d)[$\\w]+$/.test (k) ? k : show (k)) +\n               outer (' :: ') +\n               inner (k) (show (t));\n      }, keys);\n      return wrap (outer ('{')) (outer (' }')) (joinWith (outer (','), reprs));\n    }\n\n    function test(env) {\n      return function(x) {\n        if (x == null) return false;\n        var missing = {};\n        keys.forEach (function(k) { missing[k] = k; });\n        for (var k in x) delete missing[k];\n        return isEmpty (missing);\n      };\n    }\n\n    var tuples = keys.map (function(k) {\n      return [k, function(x) { return [x[k]]; }, fields[k]];\n    });\n\n    return _Type (RECORD, '', '', 0, format, [], test, tuples);\n  }\n\n  //# NamedRecordType :: NonEmpty String -> String -> Array Type -> StrMap Type -> Type\n  //.\n  //. `NamedRecordType` is used to construct named record types. The type\n  //. definition specifies the name and type of each required field. A field is\n  //. an enumerable property (either an own property or an inherited property).\n  //.\n  //. To define a named record type `t` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - an array of supertypes (exposed as `t.supertypes`); and\n  //.\n  //.   - an object mapping field name to type.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Circle :: Type\n  //. const Circle = $.NamedRecordType\n  //.   ('my-package/Circle')\n  //.   ('http://example.com/my-package#Circle')\n  //.   ([])\n  //.   ({radius: $.PositiveFiniteNumber});\n  //.\n  //. //    Cylinder :: Type\n  //. const Cylinder = $.NamedRecordType\n  //.   ('Cylinder')\n  //.   ('http://example.com/my-package#Cylinder')\n  //.   ([Circle])\n  //.   ({height: $.PositiveFiniteNumber});\n  //.\n  //. //    volume :: Cylinder -> PositiveFiniteNumber\n  //. const volume =\n  //. def ('volume')\n  //.     ({})\n  //.     ([Cylinder, $.FiniteNumber])\n  //.     (cyl => Math.PI * cyl.radius * cyl.radius * cyl.height);\n  //.\n  //. volume ({radius: 2, height: 10});\n  //. // => 125.66370614359172\n  //.\n  //. volume ({radius: 2});\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   volume :: Cylinder -> FiniteNumber\n  //. //             ^^^^^^^^\n  //. //                1\n  //. //\n  //. //   1)  {\"radius\": 2} :: Object, StrMap Number\n  //. //\n  //. //   The value at position 1 is not a member of ‘Cylinder’.\n  //. //\n  //. //   See http://example.com/my-package#Cylinder for information about the Cylinder type.\n  //. ```\n  function NamedRecordType(name) {\n    return function(url) {\n      return function(supertypes) {\n        return function(fields) {\n          var keys = sortedKeys (fields);\n\n          function format(outer, inner) {\n            return outer (name);\n          }\n\n          function test(env) {\n            var test2 = _test (env);\n            return function(x) {\n              if (x == null) return false;\n              var missing = {};\n              keys.forEach (function(k) { missing[k] = k; });\n              for (var k in x) delete missing[k];\n              return isEmpty (missing) &&\n                     keys.every (function(k) {\n                       return test2 (x[k]) (fields[k]);\n                     });\n            };\n          }\n\n          var tuples = keys.map (function(k) {\n            return [k, function(x) { return [x[k]]; }, fields[k]];\n          });\n\n          return _Type (RECORD,\n                        name,\n                        url,\n                        0,\n                        format,\n                        supertypes,\n                        test,\n                        tuples);\n        };\n      };\n    };\n  }\n\n  //  typeVarPred :: NonNegativeInteger -> Array Type -> Any -> Boolean\n  function typeVarPred(arity) {\n    var filter = arityGte (arity);\n    return function(env) {\n      var test2 = _test (env);\n      return function(x) {\n        var test1 = test2 (x);\n        return env.some (function(t) { return filter (t) && test1 (t); });\n      };\n    };\n  }\n\n  //# TypeVariable :: String -> Type\n  //.\n  //. Polymorphism is powerful. Not being able to define a function for\n  //. all types would be very limiting indeed: one couldn't even define the\n  //. identity function!\n  //.\n  //. Before defining a polymorphic function one must define one or more type\n  //. variables:\n  //.\n  //. ```javascript\n  //. const a = $.TypeVariable ('a');\n  //. const b = $.TypeVariable ('b');\n  //.\n  //. //    id :: a -> a\n  //. const id = def ('id') ({}) ([a, a]) (x => x);\n  //.\n  //. id (42);\n  //. // => 42\n  //.\n  //. id (null);\n  //. // => null\n  //. ```\n  //.\n  //. The same type variable may be used in multiple positions, creating a\n  //. constraint:\n  //.\n  //. ```javascript\n  //. //    cmp :: a -> a -> Number\n  //. const cmp =\n  //. def ('cmp')\n  //.     ({})\n  //.     ([a, a, $.Number])\n  //.     (x => y => x < y ? -1 : x > y ? 1 : 0);\n  //.\n  //. cmp (42) (42);\n  //. // => 0\n  //.\n  //. cmp ('a') ('z');\n  //. // => -1\n  //.\n  //. cmp ('z') ('a');\n  //. // => 1\n  //.\n  //. cmp (0) ('1');\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   cmp :: a -> a -> Number\n  //. //          ^    ^\n  //. //          1    2\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   2)  \"1\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  function TypeVariable(name) {\n    var tuples = [];\n    var test = typeVarPred (tuples.length);\n    return _Type (VARIABLE, name, '', 0, always2 (name), [], test, tuples);\n  }\n\n  //# UnaryTypeVariable :: String -> Type -> Type\n  //.\n  //. Combines [`UnaryType`][] and [`TypeVariable`][].\n  //.\n  //. To define a unary type variable `t a` one must provide:\n  //.\n  //.   - a name (conventionally matching `^[a-z]$`); and\n  //.\n  //.   - the type of `a`.\n  //.\n  //. Consider the type of a generalized `map`:\n  //.\n  //. ```haskell\n  //. map :: Functor f => (a -> b) -> f a -> f b\n  //. ```\n  //.\n  //. `f` is a unary type variable. With two (nullary) type variables, one\n  //. unary type variable, and one [type class][] it's possible to define a\n  //. fully polymorphic `map` function:\n  //.\n  //. ```javascript\n  //. const $ = require ('sanctuary-def');\n  //. const Z = require ('sanctuary-type-classes');\n  //.\n  //. const a = $.TypeVariable ('a');\n  //. const b = $.TypeVariable ('b');\n  //. const f = $.UnaryTypeVariable ('f');\n  //.\n  //. //    map :: Functor f => (a -> b) -> f a -> f b\n  //. const map =\n  //. def ('map')\n  //.     ({f: [Z.Functor]})\n  //.     ([$.Function ([a, b]), f (a), f (b)])\n  //.     (f => functor => Z.map (f, functor));\n  //. ```\n  //.\n  //. Whereas a regular type variable is fully resolved (`a` might become\n  //. `Array (Array String)`, for example), a unary type variable defers to\n  //. its type argument, which may itself be a type variable. The type argument\n  //. corresponds to the type argument of a unary type or the *second* type\n  //. argument of a binary type. The second type argument of `Map k v`, for\n  //. example, is `v`. One could replace `Functor => f` with `Map k` or with\n  //. `Map Integer`, but not with `Map`.\n  //.\n  //. This shallow inspection makes it possible to constrain a value's \"outer\"\n  //. and \"inner\" types independently.\n  function UnaryTypeVariable(name) {\n    return function($1) {\n      var tuples = [['$1', K ([]), $1]];\n      var test = typeVarPred (tuples.length);\n      return _Type (VARIABLE, name, '', 1, null, [], test, tuples);\n    };\n  }\n\n  //# BinaryTypeVariable :: String -> Type -> Type -> Type\n  //.\n  //. Combines [`BinaryType`][] and [`TypeVariable`][].\n  //.\n  //. To define a binary type variable `t a b` one must provide:\n  //.\n  //.   - a name (conventionally matching `^[a-z]$`);\n  //.\n  //.   - the type of `a`; and\n  //.\n  //.   - the type of `b`.\n  //.\n  //. The more detailed explanation of [`UnaryTypeVariable`][] also applies to\n  //. `BinaryTypeVariable`.\n  function BinaryTypeVariable(name) {\n    return function($1) {\n      return function($2) {\n        var tuples = [['$1', K ([]), $1],\n                      ['$2', K ([]), $2]];\n        var test = typeVarPred (tuples.length);\n        return _Type (VARIABLE, name, '', 2, null, [], test, tuples);\n      };\n    };\n  }\n\n  //# Thunk :: Type -> Type\n  //.\n  //. `$.Thunk (T)` is shorthand for `$.Function ([T])`, the type comprising\n  //. every nullary function (thunk) that returns a value of type `T`.\n  function Thunk(t) { return Function_ ([t]); }\n\n  //# Predicate :: Type -> Type\n  //.\n  //. `$.Predicate (T)` is shorthand for `$.Fn (T) ($.Boolean)`, the type\n  //. comprising every predicate function that takes a value of type `T`.\n  function Predicate(t) { return Fn (t) (Boolean_); }\n\n  //. ### Type classes\n  //.\n  //. One can trivially define a function of type `String -> String -> String`\n  //. that concatenates two strings. This is overly restrictive, though, since\n  //. other types support concatenation (`Array a`, for example).\n  //.\n  //. One could use a type variable to define a polymorphic \"concat\" function:\n  //.\n  //. ```javascript\n  //. //    _concat :: a -> a -> a\n  //. const _concat =\n  //. def ('_concat')\n  //.     ({})\n  //.     ([a, a, a])\n  //.     (x => y => x.concat (y));\n  //.\n  //. _concat ('fizz') ('buzz');\n  //. // => 'fizzbuzz'\n  //.\n  //. _concat ([1, 2]) ([3, 4]);\n  //. // => [1, 2, 3, 4]\n  //.\n  //. _concat ([1, 2]) ('buzz');\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   _concat :: a -> a -> a\n  //. //              ^    ^\n  //. //              1    2\n  //. //\n  //. //   1)  [1, 2] :: Array Number\n  //. //\n  //. //   2)  \"buzz\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  //.\n  //. The type of `_concat` is misleading: it suggests that it can operate on\n  //. any two values of *any* one type. In fact there's an implicit constraint,\n  //. since the type must support concatenation (in [mathematical][semigroup]\n  //. terms, the type must have a [semigroup][FL:Semigroup]). Violating this\n  //. implicit constraint results in a run-time error in the implementation:\n  //.\n  //. ```javascript\n  //. _concat (null) (null);\n  //. // ! TypeError: Cannot read property 'concat' of null\n  //. ```\n  //.\n  //. The solution is to constrain `a` by first defining a [`TypeClass`][]\n  //. value, then specifying the constraint in the definition of the \"concat\"\n  //. function:\n  //.\n  //. ```javascript\n  //. const Z = require ('sanctuary-type-classes');\n  //.\n  //. //    Semigroup :: TypeClass\n  //. const Semigroup = Z.TypeClass (\n  //.   'my-package/Semigroup',\n  //.   'http://example.com/my-package#Semigroup',\n  //.   [],\n  //.   x => x != null && typeof x.concat === 'function'\n  //. );\n  //.\n  //. //    concat :: Semigroup a => a -> a -> a\n  //. const concat =\n  //. def ('concat')\n  //.     ({a: [Semigroup]})\n  //.     ([a, a, a])\n  //.     (x => y => x.concat (y));\n  //.\n  //. concat ([1, 2]) ([3, 4]);\n  //. // => [1, 2, 3, 4]\n  //.\n  //. concat (null) (null);\n  //. // ! TypeError: Type-class constraint violation\n  //. //\n  //. //   concat :: Semigroup a => a -> a -> a\n  //. //             ^^^^^^^^^^^    ^\n  //. //                            1\n  //. //\n  //. //   1)  null :: Null\n  //. //\n  //. //   ‘concat’ requires ‘a’ to satisfy the Semigroup type-class constraint; the value at position 1 does not.\n  //. //\n  //. //   See http://example.com/my-package#Semigroup for information about the my-package/Semigroup type class.\n  //. ```\n  //.\n  //. Multiple constraints may be placed on a type variable by including\n  //. multiple `TypeClass` values in the array (e.g. `{a: [Foo, Bar, Baz]}`).\n\n  //  invalidArgumentsCount :: (TypeInfo, Integer, Integer, Array Any) -> Error\n  //\n  //  This function is used in `curry` when a function defined via `def`\n  //  is applied to too many arguments.\n  function invalidArgumentsCount(typeInfo, index, numArgsExpected, args) {\n    return new TypeError (trimTrailingSpaces (\n      q (typeInfo.name) + ' applied to the wrong number of arguments\\n\\n' +\n      underline (\n        typeInfo,\n        K (K (_)),\n        function(index_) {\n          return function(f) {\n            return K (K (index_ === index ? f : _));\n          };\n        }\n      ) + '\\n' +\n      'Expected ' + numArgs (numArgsExpected) +\n      ' but received ' + numArgs (args.length) +\n      toMarkdownList ('.\\n', ':\\n\\n', show, args)\n    ));\n  }\n\n  //  constraintsRepr :: ... -> String\n  function constraintsRepr(\n    constraints,    // :: StrMap (Array TypeClass)\n    outer,          // :: String -> String\n    inner           // :: String -> TypeClass -> String -> String\n  ) {\n    var $reprs = [];\n    (sortedKeys (constraints)).forEach (function(k) {\n      var f = inner (k);\n      constraints[k].forEach (function(typeClass) {\n        $reprs.push (f (typeClass) (stripNamespace (typeClass) + ' ' + k));\n      });\n    });\n    return when ($reprs.length > 0)\n                (wrap ('') (outer (' => ')))\n                (when ($reprs.length > 1)\n                      (parenthesize (outer))\n                      (joinWith (outer (', '), $reprs)));\n  }\n\n  //  label :: String -> String -> String\n  function label(label) {\n    return function(s) {\n      var delta = s.length - label.length;\n      return strRepeat (' ', Math.floor (delta / 2)) + label +\n             strRepeat (' ', Math.ceil (delta / 2));\n    };\n  }\n\n  //  typeVarNames :: Type -> Array String\n  function typeVarNames(t) {\n    return Z.concat (\n      t.type === VARIABLE ? [t.name] : [],\n      Z.chain (function(k) { return typeVarNames (t.types[k]); }, t.keys)\n    );\n  }\n\n  //  showTypeWith :: Array Type -> Type -> String\n  function showTypeWith(types) {\n    var names = Z.chain (typeVarNames, types);\n    return function(t) {\n      var code = 'a'.charCodeAt (0);\n      return when (t.type === FUNCTION)\n                  (parenthesize (I))\n                  ((show (t)).replace (/\\bUnknown\\b/g, function() {\n                     // eslint-disable-next-line no-plusplus\n                     do var name = String.fromCharCode (code++);\n                     while (names.indexOf (name) >= 0);\n                     return name;\n                   }));\n    };\n  }\n\n  //  showValuesAndTypes :: ... -> String\n  function showValuesAndTypes(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    values,         // :: Array Any\n    pos             // :: Integer\n  ) {\n    var showType = showTypeWith (typeInfo.types);\n    return show (pos) + ')  ' + joinWith ('\\n    ', Z.map (function(x) {\n      return show (x) +\n             ' :: ' +\n             joinWith (', ',\n                       or (Z.map (showType,\n                                  determineActualTypesLoose (env, [x])),\n                           ['(no types)']));\n    }, values));\n  }\n\n  //  typeSignature :: TypeInfo -> String\n  function typeSignature(typeInfo) {\n    return typeInfo.name + ' :: ' +\n           constraintsRepr (typeInfo.constraints, I, K (K (I))) +\n           joinWith (' -> ',\n                     Z.map (showTypeWith (typeInfo.types), typeInfo.types));\n  }\n\n  //  _underline :: ... -> String\n  function _underline(\n    t,              // :: Type\n    propPath,       // :: PropPath\n    formatType3     // :: Type -> Array String -> String -> String\n  ) {\n    return formatType3 (t) (propPath) (t.format (_, function(k) {\n      return K (_underline (t.types[k],\n                            Z.concat (propPath, [k]),\n                            formatType3));\n    }));\n  }\n\n  //  underline :: ... -> String\n  function underline(\n    typeInfo,               // :: TypeInfo\n    underlineConstraint,    // :: String -> TypeClass -> String -> String\n    formatType5\n    // :: Integer -> (String -> String) -> Type -> PropPath -> String -> String\n  ) {\n    var st = typeInfo.types.reduce (function(st, t, index) {\n      var f = B (when (t.type === FUNCTION)\n                      (parenthesize (_)))\n                (B (function(f) { return _underline (t, [], f); })\n                   (formatType5 (index)));\n      st.carets.push (f (r ('^')));\n      st.numbers.push (f (function(s) {\n        return label (show (st.counter += 1)) (s);\n      }));\n      return st;\n    }, {carets: [], numbers: [], counter: 0});\n\n    return typeSignature (typeInfo) + '\\n' +\n           _ (typeInfo.name + ' :: ') +\n              constraintsRepr (typeInfo.constraints, _, underlineConstraint) +\n              joinWith (_ (' -> '), st.carets) + '\\n' +\n           _ (typeInfo.name + ' :: ') +\n              constraintsRepr (typeInfo.constraints, _, K (K (_))) +\n              joinWith (_ (' -> '), st.numbers) + '\\n';\n  }\n\n  //  resolvePropPath :: (Type, Array String) -> Type\n  function resolvePropPath(t, propPath) {\n    return Z.reduce (function(t, prop) { return t.types[prop]; },\n                     t,\n                     propPath);\n  }\n\n  //  formatType6 ::\n  //    PropPath -> Integer -> (String -> String) ->\n  //      Type -> PropPath -> String -> String\n  function formatType6(indexedPropPath) {\n    return function(index_) {\n      return function(f) {\n        return function(t) {\n          return function(propPath_) {\n            var indexedPropPath_ = Z.concat ([index_], propPath_);\n            var p = isPrefix (indexedPropPath_) (indexedPropPath);\n            var q = isPrefix (indexedPropPath) (indexedPropPath_);\n            return p && q ? f : p ? I : _;\n          };\n        };\n      };\n    };\n  }\n\n  //  see :: (String, { name :: String, url :: String? }) -> String\n  function see(label, record) {\n    return record.url == null || record.url === '' ?\n           '' :\n           '\\nSee ' + record.url +\n           ' for information about the ' + record.name + ' ' + label + '.\\n';\n  }\n\n  //  typeClassConstraintViolation :: ... -> Error\n  function typeClassConstraintViolation(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    typeClass,      // :: TypeClass\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    value,          // :: Any\n    typeVarMap      // :: TypeVarMap\n  ) {\n    var expType = resolvePropPath (typeInfo.types[index], propPath);\n    return new TypeError (trimTrailingSpaces (\n      'Type-class constraint violation\\n\\n' +\n      underline (typeInfo,\n                 function(tvn) {\n                   return function(tc) {\n                     return (\n                       tvn === expType.name && tc.name === typeClass.name ?\n                         r ('^') :\n                         _\n                     );\n                   };\n                 },\n                 formatType6 (Z.concat ([index], propPath))) +\n      '\\n' +\n      showValuesAndTypes (env, typeInfo, [value], 1) + '\\n\\n' +\n      q (typeInfo.name) + ' requires ' +\n      q (expType.name) + ' to satisfy the ' +\n      stripNamespace (typeClass) + ' type-class constraint; ' +\n      'the value at position 1 does not.\\n' +\n      see ('type class', typeClass)\n    ));\n  }\n\n  //  typeVarConstraintViolation :: ... -> Error\n  function typeVarConstraintViolation(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    valuesByPath    // :: StrMap (Array Any)\n  ) {\n    //  If we apply an ‘a -> a -> a -> a’ function to Left ('x'), Right (1),\n    //  and Right (null) we'd like to avoid underlining the first argument\n    //  position, since Left ('x') is compatible with the other ‘a’ values.\n    var key = JSON.stringify (Z.concat ([index], propPath));\n    var values = valuesByPath[key];\n\n    //  Note: Sorting these keys lexicographically is not \"correct\", but it\n    //  does the right thing for indexes less than 10.\n    var keys = Z.filter (function(k) {\n      var values_ = valuesByPath[k];\n      return (\n        //  Keep X, the position at which the violation was observed.\n        k === key ||\n        //  Keep positions whose values are incompatible with the values at X.\n        isEmpty (determineActualTypesStrict (env, Z.concat (values, values_)))\n      );\n    }, sortedKeys (valuesByPath));\n\n    var underlinedTypeVars =\n    underlineTypeVars (typeInfo,\n                       Z.reduce (function($valuesByPath, k) {\n                         $valuesByPath[k] = valuesByPath[k];\n                         return $valuesByPath;\n                       }, {}, keys));\n\n    return new TypeError (trimTrailingSpaces (\n      'Type-variable constraint violation\\n\\n' +\n      underlinedTypeVars + '\\n' +\n      (Z.reduce (function(st, k) {\n        var values = valuesByPath[k];\n        return isEmpty (values) ? st : {\n          idx: st.idx + 1,\n          s: st.s +\n             showValuesAndTypes (env, typeInfo, values, st.idx + 1) +\n             '\\n\\n'\n        };\n      }, {idx: 0, s: ''}, keys)).s +\n      'Since there is no type of which all the above values are ' +\n      'members, the type-variable constraint has been violated.\\n'\n    ));\n  }\n\n  //  invalidValue :: ... -> Error\n  function invalidValue(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    value           // :: Any\n  ) {\n    var t = resolvePropPath (typeInfo.types[index], propPath);\n\n    var underlinedTypeVars =\n    underline (typeInfo,\n               K (K (_)),\n               formatType6 (Z.concat ([index], propPath)));\n\n    return new TypeError (trimTrailingSpaces (\n      t.type === VARIABLE &&\n      isEmpty (determineActualTypesLoose (env, [value])) ?\n        'Unrecognized value\\n\\n' +\n        underlinedTypeVars + '\\n' +\n        showValuesAndTypes (env, typeInfo, [value], 1) + '\\n\\n' +\n        toMarkdownList (\n          'The environment is empty! ' +\n          'Polymorphic functions require a non-empty environment.\\n',\n          'The value at position 1 is not a member of any type in ' +\n          'the environment.\\n\\n' +\n          'The environment contains the following types:\\n\\n',\n          showTypeWith (typeInfo.types),\n          env\n        ) :\n      // else\n        'Invalid value\\n\\n' +\n        underlinedTypeVars + '\\n' +\n        showValuesAndTypes (env, typeInfo, [value], 1) + '\\n\\n' +\n        'The value at position 1 is not a member of ' +\n        q (show (t)) + '.\\n' +\n        see (arityGte (1) (t) ? 'type constructor' : 'type', t)\n    ));\n  }\n\n  //  invalidArgumentsLength :: ... -> Error\n  //\n  //  This function is used in `wrapFunctionCond` to ensure that higher-order\n  //  functions defined via `def` only ever apply a function argument to the\n  //  correct number of arguments.\n  function invalidArgumentsLength(\n    typeInfo,           // :: TypeInfo\n    index,              // :: Integer\n    numArgsExpected,    // :: Integer\n    args                // :: Array Any\n  ) {\n    return new TypeError (trimTrailingSpaces (\n      q (typeInfo.name) +\n      ' applied ' + q (show (typeInfo.types[index])) +\n      ' to the wrong number of arguments\\n\\n' +\n      underline (\n        typeInfo,\n        K (K (_)),\n        function(index_) {\n          return function(f) {\n            return function(t) {\n              return function(propPath) {\n                return function(s) {\n                  return index_ === index ?\n                    t.format (_, function(k) { return k === '$1' ? f : _; }) :\n                    _ (s);\n                };\n              };\n            };\n          };\n        }\n      ) + '\\n' +\n      'Expected ' + numArgs (numArgsExpected) +\n      ' but received ' + numArgs (args.length) +\n      toMarkdownList ('.\\n', ':\\n\\n', show, args)\n    ));\n  }\n\n  //  assertRight :: Either (() -> Error) a -> a !\n  function assertRight(either) {\n    if (either.isLeft) throw either.value ();\n    return either.value;\n  }\n\n  //  withTypeChecking :: ... -> Function\n  function withTypeChecking(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    impl            // :: Function\n  ) {\n    var n = typeInfo.types.length - 1;\n\n    //  wrapFunctionCond :: (TypeVarMap, Integer, a) -> a\n    function wrapFunctionCond(_typeVarMap, index, value) {\n      var expType = typeInfo.types[index];\n      if (expType.type !== FUNCTION) return value;\n\n      //  checkValue :: (TypeVarMap, Integer, String, a) -> Either (() -> Error) TypeVarMap\n      function checkValue(typeVarMap, index, k, x) {\n        var propPath = [k];\n        var t = expType.types[k];\n        return (\n          t.type === VARIABLE ?\n            Z.chain (\n              function(typeVarMap) {\n                return isEmpty (typeVarMap[t.name].types) ?\n                  Left (function() {\n                    return typeVarConstraintViolation (\n                      env,\n                      typeInfo,\n                      index,\n                      propPath,\n                      typeVarMap[t.name].valuesByPath\n                    );\n                  }) :\n                  Right (typeVarMap);\n              },\n              Right (updateTypeVarMap (env,\n                                       typeVarMap,\n                                       t,\n                                       index,\n                                       propPath,\n                                       [x]))\n            ) :\n          // else\n            Z.map (\n              function(r) { return r.typeVarMap; },\n              satisfactoryTypes (env,\n                                 typeInfo,\n                                 typeVarMap,\n                                 t,\n                                 index,\n                                 propPath,\n                                 [x])\n            )\n        );\n      }\n\n      var typeVarMap = _typeVarMap;\n      return function(x) {\n        if (arguments.length !== expType.arity - 1) {\n          throw invalidArgumentsLength (typeInfo,\n                                        index,\n                                        expType.arity - 1,\n                                        slice.call (arguments));\n        }\n\n        var args = arguments;\n        typeVarMap = assertRight (\n          (init (expType.keys)).reduce (function(either, k, idx) {\n            var arg = args[idx];\n            return Z.chain (function(typeVarMap) {\n              return checkValue (typeVarMap, index, k, arg);\n            }, either);\n          }, Right (typeVarMap))\n        );\n\n        var output = value.apply (this, arguments);\n        var k = last (expType.keys);\n        typeVarMap = assertRight (checkValue (typeVarMap, index, k, output));\n        return output;\n      };\n    }\n\n    //  wrapNext :: (TypeVarMap, Array Any, Integer) -> (a -> b)\n    function wrapNext(_typeVarMap, _values, index) {\n      return function(x) {\n        var args = slice.call (arguments);\n        if (args.length !== 1) {\n          throw invalidArgumentsCount (typeInfo, index, 1, args);\n        }\n        var typeVarMap = (assertRight (\n          satisfactoryTypes (env,\n                             typeInfo,\n                             _typeVarMap,\n                             typeInfo.types[index],\n                             index,\n                             [],\n                             args)\n        )).typeVarMap;\n\n        var values = Z.concat (_values, args);\n        if (index + 1 === n) {\n          var value = values.reduce (function(f, x, idx) {\n            return f (wrapFunctionCond (typeVarMap, idx, x));\n          }, impl);\n          typeVarMap = (assertRight (\n            satisfactoryTypes (env,\n                               typeInfo,\n                               typeVarMap,\n                               typeInfo.types[n],\n                               n,\n                               [],\n                               [value])\n          )).typeVarMap;\n          return wrapFunctionCond (typeVarMap, n, value);\n        } else {\n          return wrapNext (typeVarMap, values, index + 1);\n        }\n      };\n    }\n\n    var wrapped = typeInfo.types[0].type === NO_ARGUMENTS ?\n      function() {\n        if (arguments.length !== 0) {\n          throw invalidArgumentsCount (typeInfo, 0, 0, slice.call (arguments));\n        }\n        var value = impl ();\n        var typeVarMap = (assertRight (\n          satisfactoryTypes (env,\n                             typeInfo,\n                             {},\n                             typeInfo.types[n],\n                             n,\n                             [],\n                             [value])\n        )).typeVarMap;\n        return wrapFunctionCond (typeVarMap, n, value);\n      } :\n      wrapNext ({}, [], 0);\n\n    wrapped[inspect] = wrapped.toString = always0 (typeSignature (typeInfo));\n\n    return wrapped;\n  }\n\n  //  defTypes :: NonEmpty (Array Type)\n  var defTypes = [\n    String_,\n    StrMap (Array_ (TypeClass)),\n    NonEmpty (Array_ (Type)),\n    AnyFunction,\n    AnyFunction\n  ];\n\n  function create(opts) {\n    function def(name) {\n      return function(constraints) {\n        return function(expTypes) {\n          return function(impl) {\n            return opts.checkTypes ?\n              withTypeChecking (opts.env,\n                                {name: name,\n                                 constraints: constraints,\n                                 types: expTypes.length === 1 ?\n                                        Z.concat ([NoArguments], expTypes) :\n                                        expTypes},\n                                impl) :\n              impl;\n          };\n        };\n      };\n    }\n    return def (def.name) ({}) (defTypes) (def);\n  }\n\n  var def = create ({checkTypes: !production, env: env});\n\n  //  fromUncheckedUnaryType :: (Type -> Type) -> Type -> Type\n  function fromUncheckedUnaryType(typeConstructor) {\n    var t = typeConstructor (Unknown);\n    return def (t.name) ({}) ([Type, Type]) (fromUnaryType (t));\n  }\n\n  //  fromUncheckedBinaryType :: (Type -> Type -> Type) -> Type -> Type -> Type\n  function fromUncheckedBinaryType(typeConstructor) {\n    var t = typeConstructor (Unknown) (Unknown);\n    return def (t.name) ({}) ([Type, Type, Type]) (fromBinaryType (t));\n  }\n\n  return {\n    Any: Any,\n    AnyFunction: AnyFunction,\n    Arguments: Arguments,\n    Array: fromUncheckedUnaryType (Array_),\n    Array0: Array0,\n    Array1: fromUncheckedUnaryType (Array1),\n    Array2: fromUncheckedBinaryType (Array2),\n    Boolean: Boolean_,\n    Date: Date_,\n    ValidDate: ValidDate,\n    Descending: fromUncheckedUnaryType (Descending),\n    Either: fromUncheckedBinaryType (Either_),\n    Error: Error_,\n    Fn:\n      def ('Fn')\n          ({})\n          ([Type, Type, Type])\n          (Fn),\n    Function:\n      def ('Function')\n          ({})\n          ([NonEmpty (Array_ (Type)), Type])\n          (Function_),\n    HtmlElement: HtmlElement,\n    Identity: fromUncheckedUnaryType (Identity),\n    Maybe: fromUncheckedUnaryType (Maybe),\n    NonEmpty: NonEmpty,\n    Null: Null,\n    Nullable: fromUncheckedUnaryType (Nullable),\n    Number: Number_,\n    PositiveNumber: PositiveNumber,\n    NegativeNumber: NegativeNumber,\n    ValidNumber: ValidNumber,\n    NonZeroValidNumber: NonZeroValidNumber,\n    FiniteNumber: FiniteNumber,\n    NonZeroFiniteNumber: NonZeroFiniteNumber,\n    PositiveFiniteNumber: PositiveFiniteNumber,\n    NegativeFiniteNumber: NegativeFiniteNumber,\n    Integer: Integer,\n    NonZeroInteger: NonZeroInteger,\n    NonNegativeInteger: NonNegativeInteger,\n    PositiveInteger: PositiveInteger,\n    NegativeInteger: NegativeInteger,\n    Object: Object_,\n    Pair: fromUncheckedBinaryType (Pair),\n    RegExp: RegExp_,\n    GlobalRegExp: GlobalRegExp,\n    NonGlobalRegExp: NonGlobalRegExp,\n    RegexFlags: RegexFlags,\n    StrMap: fromUncheckedUnaryType (StrMap),\n    String: String_,\n    Symbol: Symbol_,\n    Type: Type,\n    TypeClass: TypeClass,\n    Undefined: Undefined,\n    Unknown: Unknown,\n    env: env,\n    create:\n      def ('create')\n          ({})\n          ([RecordType ({checkTypes: Boolean_, env: Array_ (Type)}),\n            Unchecked (joinWith (' -> ', Z.map (show, defTypes)))])\n          (create),\n    test:\n      def ('test')\n          ({})\n          ([Array_ (Type), Type, Any, Boolean_])\n          (test),\n    NullaryType:\n      def ('NullaryType')\n          ({})\n          ([String_,\n            String_,\n            Array_ (Type),\n            Unchecked ('(Any -> Boolean)'),\n            Type])\n          (NullaryType),\n    UnaryType:\n      def ('UnaryType')\n          ({f: [Z.Foldable]})\n          ([String_,\n            String_,\n            Array_ (Type),\n            Unchecked ('(Any -> Boolean)'),\n            Unchecked ('(t a -> f a)'),\n            Unchecked ('Type -> Type')])\n          (function(name) {\n             return B (B (B (B (def (name) ({}) ([Type, Type])))))\n                      (UnaryType (name));\n           }),\n    BinaryType:\n      def ('BinaryType')\n          ({f: [Z.Foldable]})\n          ([String_,\n            String_,\n            Array_ (Type),\n            Unchecked ('(Any -> Boolean)'),\n            Unchecked ('(t a b -> f a)'),\n            Unchecked ('(t a b -> f b)'),\n            Unchecked ('Type -> Type -> Type')])\n          (function(name) {\n             return B (B (B (B (B (def (name) ({}) ([Type, Type, Type]))))))\n                      (BinaryType (name));\n           }),\n    EnumType:\n      def ('EnumType')\n          ({})\n          ([String_, String_, Array_ (Any), Type])\n          (EnumType),\n    RecordType:\n      def ('RecordType')\n          ({})\n          ([StrMap (Type), Type])\n          (RecordType),\n    NamedRecordType:\n      def ('NamedRecordType')\n          ({})\n          ([NonEmpty (String_), String_, Array_ (Type), StrMap (Type), Type])\n          (NamedRecordType),\n    TypeVariable:\n      def ('TypeVariable')\n          ({})\n          ([String_, Type])\n          (TypeVariable),\n    UnaryTypeVariable:\n      def ('UnaryTypeVariable')\n          ({})\n          ([String_, Unchecked ('Type -> Type')])\n          (function(name) {\n             return def (name) ({}) ([Type, Type]) (UnaryTypeVariable (name));\n           }),\n    BinaryTypeVariable:\n      def ('BinaryTypeVariable')\n          ({})\n          ([String_, Unchecked ('Type -> Type -> Type')])\n          (function(name) {\n             return def (name)\n                        ({})\n                        ([Type, Type, Type])\n                        (BinaryTypeVariable (name));\n           }),\n    Thunk:\n      def ('Thunk')\n          ({})\n          ([Type, Type])\n          (Thunk),\n    Predicate:\n      def ('Predicate')\n          ({})\n          ([Type, Type])\n          (Predicate)\n  };\n\n}));\n\n//. [Descending]:           v:sanctuary-js/sanctuary-descending\n//. [Either]:               v:sanctuary-js/sanctuary-either\n//. [FL:Semigroup]:         https://github.com/fantasyland/fantasy-land#semigroup\n//. [HTML element]:         https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n//. [Identity]:             v:sanctuary-js/sanctuary-identity\n//. [Maybe]:                v:sanctuary-js/sanctuary-maybe\n//. [Monoid]:               https://github.com/fantasyland/fantasy-land#monoid\n//. [Pair]:                 v:sanctuary-js/sanctuary-pair\n//. [Setoid]:               https://github.com/fantasyland/fantasy-land#setoid\n//. [Unknown]:              #Unknown\n//. [`Array`]:              #Array\n//. [`Array2`]:             #Array2\n//. [`BinaryType`]:         #BinaryType\n//. [`Date`]:               #Date\n//. [`FiniteNumber`]:       #FiniteNumber\n//. [`GlobalRegExp`]:       #GlobalRegExp\n//. [`Integer`]:            #Integer\n//. [`NonGlobalRegExp`]:    #NonGlobalRegExp\n//. [`Number`]:             #Number\n//. [`Object.create`]:      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n//. [`RegExp`]:             #RegExp\n//. [`RegexFlags`]:         #RegexFlags\n//. [`String`]:             #String\n//. [`SyntaxError`]:        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError\n//. [`TypeClass`]:          https://github.com/sanctuary-js/sanctuary-type-classes#TypeClass\n//. [`TypeError`]:          https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\n//. [`TypeVariable`]:       #TypeVariable\n//. [`UnaryType`]:          #UnaryType\n//. [`UnaryTypeVariable`]:  #UnaryTypeVariable\n//. [`Unknown`]:            #Unknown\n//. [`ValidNumber`]:        #ValidNumber\n//. [`env`]:                #env\n//. [arguments]:            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n//. [enumerated types]:     https://en.wikipedia.org/wiki/Enumerated_type\n//. [max]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER\n//. [min]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER\n//. [semigroup]:            https://en.wikipedia.org/wiki/Semigroup\n//. [type class]:           #type-classes\n//. [type variables]:       #TypeVariable\n//. [types]:                #types\n});\n\nvar sanctuaryMaybe = createCommonjsModule(function (module) {\n/*\n    ,______  ______,  ,________,,_____,,_____,,__________  ,__________,\n    |      \\/      |  |        ||     ||     ||          \\ |          |\n    |_,          ,_|  |_      _||_    ||    _||_,   __    ||_,   _____|\n      |   \\  /   |     /      \\   \\   \\/   /    |        /   |      |\n    ,_|    ||    |_,,_/   /\\   \\_, \\      /   ,_|   __   \\ ,_|   ___|_,\n    |      ||      ||     ||     |  |    |    |           ||          |\n    |______||______||_____||_____|  |____|    |__________/ |__________|\n                                                                         */\n\n//. <a href=\"https://github.com/fantasyland/fantasy-land\"><img alt=\"Fantasy Land\" src=\"https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png\" width=\"75\" height=\"75\" align=\"left\"></a>\n//.\n//. # sanctuary-maybe\n//.\n//. The Maybe type represents optional values: a value of type `Maybe a` is\n//. either Nothing (the empty value) or a Just whose value is of type `a`.\n\n(function(f) {\n\n  /* istanbul ignore else */\n  {\n    module.exports = f (util,\n                        sanctuaryShow,\n                        sanctuaryTypeClasses);\n  }\n\n} (function(util, show, Z) {\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    var $ = __doctest.require ('sanctuary-def');\n    var type = __doctest.require ('sanctuary-type-identifiers');\n    var S = (function() {\n      var S = __doctest.require ('sanctuary');\n      var MaybeType = $.UnaryType\n        ('sanctuary-maybe/Maybe')\n        ('')\n        (function(x) { return type (x) === Maybe['@@type']; })\n        (function(m) { return m.isJust ? [m.value] : []; });\n      var env = Z.concat (S.env, [$.TypeClass, MaybeType ($.Unknown)]);\n      return S.create ({checkTypes: true, env: env});\n    } ());\n  }\n\n  var Maybe = {};\n\n  var Nothing$prototype = {\n    /* eslint-disable key-spacing */\n    'constructor':            Maybe,\n    'isNothing':              true,\n    'isJust':                 false,\n    '@@show':                 Nothing$prototype$show,\n    'fantasy-land/equals':    Nothing$prototype$equals,\n    'fantasy-land/lte':       Nothing$prototype$lte,\n    'fantasy-land/concat':    Nothing$prototype$concat,\n    'fantasy-land/filter':    Nothing$prototype$filter,\n    'fantasy-land/map':       Nothing$prototype$map,\n    'fantasy-land/ap':        Nothing$prototype$ap,\n    'fantasy-land/chain':     Nothing$prototype$chain,\n    'fantasy-land/alt':       Nothing$prototype$alt,\n    'fantasy-land/reduce':    Nothing$prototype$reduce,\n    'fantasy-land/traverse':  Nothing$prototype$traverse,\n    'fantasy-land/extend':    Nothing$prototype$extend\n    /* eslint-enable key-spacing */\n  };\n\n  var Just$prototype = {\n    /* eslint-disable key-spacing */\n    'constructor':            Maybe,\n    'isNothing':              false,\n    'isJust':                 true,\n    '@@show':                 Just$prototype$show,\n    'fantasy-land/filter':    Just$prototype$filter,\n    'fantasy-land/map':       Just$prototype$map,\n    'fantasy-land/ap':        Just$prototype$ap,\n    'fantasy-land/chain':     Just$prototype$chain,\n    'fantasy-land/alt':       Just$prototype$alt,\n    'fantasy-land/reduce':    Just$prototype$reduce,\n    'fantasy-land/traverse':  Just$prototype$traverse,\n    'fantasy-land/extend':    Just$prototype$extend\n    /* eslint-enable key-spacing */\n  };\n\n  var custom = util.inspect.custom;\n  /* istanbul ignore else */\n  if (typeof custom === 'symbol') {\n    Nothing$prototype[custom] = Nothing$prototype$show;\n    Just$prototype[custom] = Just$prototype$show;\n  } else {\n    Nothing$prototype.inspect = Nothing$prototype$show;\n    Just$prototype.inspect = Just$prototype$show;\n  }\n\n  //. `Maybe a` satisfies the following [Fantasy Land][] specifications:\n  //.\n  //. ```javascript\n  //. > const Useless = require ('sanctuary-useless')\n  //.\n  //. > S.map (k => k + ' '.repeat (16 - k.length) +\n  //. .             (Z[k].test (Just (Useless)) ? '\\u2705   ' :\n  //. .              Z[k].test (Nothing)        ? '\\u2705 * ' :\n  //. .              /* otherwise */              '\\u274C   '))\n  //. .       (S.keys (S.unchecked.filter (S.is ($.TypeClass)) (Z)))\n  //. [ 'Setoid          ✅ * ',  // if ‘a’ satisfies Setoid\n  //. . 'Ord             ✅ * ',  // if ‘a’ satisfies Ord\n  //. . 'Semigroupoid    ❌   ',\n  //. . 'Category        ❌   ',\n  //. . 'Semigroup       ✅ * ',  // if ‘a’ satisfies Semigroup\n  //. . 'Monoid          ✅ * ',  // if ‘a’ satisfies Semigroup\n  //. . 'Group           ❌   ',\n  //. . 'Filterable      ✅   ',\n  //. . 'Functor         ✅   ',\n  //. . 'Bifunctor       ❌   ',\n  //. . 'Profunctor      ❌   ',\n  //. . 'Apply           ✅   ',\n  //. . 'Applicative     ✅   ',\n  //. . 'Chain           ✅   ',\n  //. . 'ChainRec        ✅   ',\n  //. . 'Monad           ✅   ',\n  //. . 'Alt             ✅   ',\n  //. . 'Plus            ✅   ',\n  //. . 'Alternative     ✅   ',\n  //. . 'Foldable        ✅   ',\n  //. . 'Traversable     ✅   ',\n  //. . 'Extend          ✅   ',\n  //. . 'Comonad         ❌   ',\n  //. . 'Contravariant   ❌   ' ]\n  //. ```\n\n  //# Maybe :: TypeRep Maybe\n  //.\n  //. Maybe [type representative][].\n\n  //# Maybe.Nothing :: Maybe a\n  //.\n  //. The empty value of type `Maybe a`.\n  //.\n  //. ```javascript\n  //. > Nothing\n  //. Nothing\n  //. ```\n  var Nothing = Maybe.Nothing = Object.create (Nothing$prototype);\n\n  //# Maybe.Just :: a -> Maybe a\n  //.\n  //. Constructs a value of type `Maybe a` from a value of type `a`.\n  //.\n  //. ```javascript\n  //. > Just (42)\n  //. Just (42)\n  //. ```\n  var Just = Maybe.Just = function(value) {\n    var just = Object.create (Just$prototype);\n    if (Z.Setoid.test (value)) {\n      just['fantasy-land/equals'] = Just$prototype$equals;\n      if (Z.Ord.test (value)) {\n        just['fantasy-land/lte'] = Just$prototype$lte;\n      }\n    }\n    if (Z.Semigroup.test (value)) {\n      just['fantasy-land/concat'] = Just$prototype$concat;\n    }\n    just.value = value;\n    return just;\n  };\n\n  //# Maybe.@@type :: String\n  //.\n  //. Maybe [type identifier][].\n  //.\n  //. ```javascript\n  //. > type (Just (42))\n  //. 'sanctuary-maybe/Maybe@1'\n  //.\n  //. > type.parse (type (Just (42)))\n  //. {namespace: 'sanctuary-maybe', name: 'Maybe', version: 1}\n  //. ```\n  Maybe['@@type'] = 'sanctuary-maybe/Maybe@1';\n\n  //# Maybe.fantasy-land/empty :: () -> Maybe a\n  //.\n  //.   - `empty (Maybe)` is equivalent to `Nothing`\n  //.\n  //. ```javascript\n  //. > S.empty (Maybe)\n  //. Nothing\n  //. ```\n  Maybe['fantasy-land/empty'] = function() { return Nothing; };\n\n  //# Maybe.fantasy-land/of :: a -> Maybe a\n  //.\n  //.   - `of (Maybe) (x)` is equivalent to `Just (x)`\n  //.\n  //. ```javascript\n  //. > S.of (Maybe) (42)\n  //. Just (42)\n  //. ```\n  Maybe['fantasy-land/of'] = Just;\n\n  function next(x) { return {tag: next, value: x}; }\n  function done(x) { return {tag: done, value: x}; }\n\n  //# Maybe.fantasy-land/chainRec :: ((a -> c, b -> c, a) -> Maybe c, a) -> Maybe b\n  //.\n  //. ```javascript\n  //. > Z.chainRec (\n  //. .   Maybe,\n  //. .   (next, done, x) =>\n  //. .     x <= 1 ? Nothing : Just (x >= 1000 ? done (x) : next (x * x)),\n  //. .   1\n  //. . )\n  //. Nothing\n  //.\n  //. > Z.chainRec (\n  //. .   Maybe,\n  //. .   (next, done, x) =>\n  //. .     x <= 1 ? Nothing : Just (x >= 1000 ? done (x) : next (x * x)),\n  //. .   2\n  //. . )\n  //. Just (65536)\n  //. ```\n  Maybe['fantasy-land/chainRec'] = function(f, x) {\n    var r = next (x);\n    while (r.tag === next) {\n      var maybe = f (next, done, r.value);\n      if (maybe.isNothing) return maybe;\n      r = maybe.value;\n    }\n    return Just (r.value);\n  };\n\n  //# Maybe.fantasy-land/zero :: () -> Maybe a\n  //.\n  //.   - `zero (Maybe)` is equivalent to `Nothing`\n  //.\n  //. ```javascript\n  //. > S.zero (Maybe)\n  //. Nothing\n  //. ```\n  Maybe['fantasy-land/zero'] = function() { return Nothing; };\n\n  //# Maybe#@@show :: Showable a => Maybe a ~> () -> String\n  //.\n  //.   - `show (Nothing)` is equivalent to `'Nothing'`\n  //.   - `show (Just (x))` is equivalent to `'Just (' + show (x) + ')'`\n  //.\n  //. ```javascript\n  //. > show (Nothing)\n  //. 'Nothing'\n  //.\n  //. > show (Just (['foo', 'bar', 'baz']))\n  //. 'Just ([\"foo\", \"bar\", \"baz\"])'\n  //. ```\n  function Nothing$prototype$show() {\n    return 'Nothing';\n  }\n  function Just$prototype$show() {\n    return 'Just (' + show (this.value) + ')';\n  }\n\n  //# Maybe#fantasy-land/equals :: Setoid a => Maybe a ~> Maybe a -> Boolean\n  //.\n  //.   - `Nothing` is equal to `Nothing`\n  //.   - `Just (x)` is equal to `Just (y)` [iff][] `x` is equal to `y`\n  //.     according to [`Z.equals`][]\n  //.   - `Nothing` is never equal to `Just (x)`\n  //.\n  //. ```javascript\n  //. > S.equals (Nothing) (Nothing)\n  //. true\n  //.\n  //. > S.equals (Just ([1, 2, 3])) (Just ([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals (Just ([1, 2, 3])) (Just ([3, 2, 1]))\n  //. false\n  //.\n  //. > S.equals (Just ([1, 2, 3])) (Nothing)\n  //. false\n  //. ```\n  function Nothing$prototype$equals(other) {\n    return other.isNothing;\n  }\n  function Just$prototype$equals(other) {\n    return other.isJust && Z.equals (this.value, other.value);\n  }\n\n  //# Maybe#fantasy-land/lte :: Ord a => Maybe a ~> Maybe a -> Boolean\n  //.\n  //.   - `Nothing` is (less than or) equal to `Nothing`\n  //.   - `Just (x)` is less than or equal to `Just (y)` [iff][] `x` is less\n  //.     than or equal to `y` according to [`Z.lte`][]\n  //.   - `Nothing` is always less than `Just (x)`\n  //.\n  //. ```javascript\n  //. > S.filter (S.lte (Nothing)) ([Nothing, Just (0), Just (1), Just (2)])\n  //. [Nothing]\n  //.\n  //. > S.filter (S.lte (Just (1))) ([Nothing, Just (0), Just (1), Just (2)])\n  //. [Nothing, Just (0), Just (1)]\n  //. ```\n  function Nothing$prototype$lte(other) {\n    return true;\n  }\n  function Just$prototype$lte(other) {\n    return other.isJust && Z.lte (this.value, other.value);\n  }\n\n  //# Maybe#fantasy-land/concat :: Semigroup a => Maybe a ~> Maybe a -> Maybe a\n  //.\n  //.   - `concat (Nothing) (Nothing)` is equivalent to `Nothing`\n  //.   - `concat (Just (x)) (Just (y))` is equivalent to\n  //.     `Just (concat (x) (y))`\n  //.   - `concat (Nothing) (Just (x))` is equivalent to `Just (x)`\n  //.   - `concat (Just (x)) (Nothing)` is equivalent to `Just (x)`\n  //.\n  //. ```javascript\n  //. > S.concat (Nothing) (Nothing)\n  //. Nothing\n  //.\n  //. > S.concat (Just ([1, 2, 3])) (Just ([4, 5, 6]))\n  //. Just ([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat (Nothing) (Just ([1, 2, 3]))\n  //. Just ([1, 2, 3])\n  //.\n  //. > S.concat (Just ([1, 2, 3])) (Nothing)\n  //. Just ([1, 2, 3])\n  //. ```\n  function Nothing$prototype$concat(other) {\n    return other;\n  }\n  function Just$prototype$concat(other) {\n    return other.isJust ? Just (Z.concat (this.value, other.value)) : this;\n  }\n\n  //# Maybe#fantasy-land/filter :: Maybe a ~> (a -> Boolean) -> Maybe a\n  //.\n  //.   - `filter (p) (Nothing)` is equivalent to `Nothing`\n  //.   - `filter (p) (Just (x))` is equivalent to `p (x) ? Just (x) : Nothing`\n  //.\n  //. ```javascript\n  //. > S.filter (isFinite) (Nothing)\n  //. Nothing\n  //.\n  //. > S.filter (isFinite) (Just (Infinity))\n  //. Nothing\n  //.\n  //. > S.filter (isFinite) (Just (Number.MAX_SAFE_INTEGER))\n  //. Just (9007199254740991)\n  //. ```\n  function Nothing$prototype$filter(pred) {\n    return this;\n  }\n  function Just$prototype$filter(pred) {\n    return pred (this.value) ? this : Nothing;\n  }\n\n  //# Maybe#fantasy-land/map :: Maybe a ~> (a -> b) -> Maybe b\n  //.\n  //.   - `map (f) (Nothing)` is equivalent to `Nothing`\n  //.   - `map (f) (Just (x))` is equivalent to `Just (f (x))`\n  //.\n  //. ```javascript\n  //. > S.map (Math.sqrt) (Nothing)\n  //. Nothing\n  //.\n  //. > S.map (Math.sqrt) (Just (9))\n  //. Just (3)\n  //. ```\n  function Nothing$prototype$map(f) {\n    return this;\n  }\n  function Just$prototype$map(f) {\n    return Just (f (this.value));\n  }\n\n  //# Maybe#fantasy-land/ap :: Maybe a ~> Maybe (a -> b) -> Maybe b\n  //.\n  //.   - `ap (Nothing) (Nothing)` is equivalent to `Nothing`\n  //.   - `ap (Nothing) (Just (x))` is equivalent to `Nothing`\n  //.   - `ap (Just (f)) (Nothing)` is equivalent to `Nothing`\n  //.   - `ap (Just (f)) (Just (x))` is equivalent to `Just (f (x))`\n  //.\n  //. ```javascript\n  //. > S.ap (Nothing) (Nothing)\n  //. Nothing\n  //.\n  //. > S.ap (Nothing) (Just (9))\n  //. Nothing\n  //.\n  //. > S.ap (Just (Math.sqrt)) (Nothing)\n  //. Nothing\n  //.\n  //. > S.ap (Just (Math.sqrt)) (Just (9))\n  //. Just (3)\n  //. ```\n  function Nothing$prototype$ap(other) {\n    return this;\n  }\n  function Just$prototype$ap(other) {\n    return other.isJust ? Just (other.value (this.value)) : other;\n  }\n\n  //# Maybe#fantasy-land/chain :: Maybe a ~> (a -> Maybe b) -> Maybe b\n  //.\n  //.   - `chain (f) (Nothing)` is equivalent to `Nothing`\n  //.   - `chain (f) (Just (x))` is equivalent to `f (x)`\n  //.\n  //. ```javascript\n  //. > const head = xs => xs.length === 0 ? Nothing : Just (xs[0])\n  //.\n  //. > S.chain (head) (Nothing)\n  //. Nothing\n  //.\n  //. > S.chain (head) (Just ([]))\n  //. Nothing\n  //.\n  //. > S.chain (head) (Just (['foo', 'bar', 'baz']))\n  //. Just ('foo')\n  //. ```\n  function Nothing$prototype$chain(f) {\n    return this;\n  }\n  function Just$prototype$chain(f) {\n    return f (this.value);\n  }\n\n  //# Maybe#fantasy-land/alt :: Maybe a ~> Maybe a -> Maybe a\n  //.\n  //.   - `alt (Nothing) (Nothing)` is equivalent to `Nothing`\n  //.   - `alt (Nothing) (Just (x))` is equivalent to `Just (x)`\n  //.   - `alt (Just (x)) (Nothing)` is equivalent to `Just (x)`\n  //.   - `alt (Just (x)) (Just (y))` is equivalent to `Just (x)`\n  //.\n  //. ```javascript\n  //. > S.alt (Nothing) (Nothing)\n  //. Nothing\n  //.\n  //. > S.alt (Nothing) (Just (1))\n  //. Just (1)\n  //.\n  //. > S.alt (Just (2)) (Nothing)\n  //. Just (2)\n  //.\n  //. > S.alt (Just (3)) (Just (4))\n  //. Just (3)\n  //. ```\n  function Nothing$prototype$alt(other) {\n    return other;\n  }\n  function Just$prototype$alt(other) {\n    return this;\n  }\n\n  //# Maybe#fantasy-land/reduce :: Maybe a ~> ((b, a) -> b, b) -> b\n  //.\n  //.   - `reduce (f) (x) (Nothing)` is equivalent to `x`\n  //.   - `reduce (f) (x) (Just (y))` is equivalent to `f (x) (y)`\n  //.\n  //. ```javascript\n  //. > S.reduce (S.concat) ('abc') (Nothing)\n  //. 'abc'\n  //.\n  //. > S.reduce (S.concat) ('abc') (Just ('xyz'))\n  //. 'abcxyz'\n  //. ```\n  function Nothing$prototype$reduce(f, x) {\n    return x;\n  }\n  function Just$prototype$reduce(f, x) {\n    return f (x, this.value);\n  }\n\n  //# Maybe#fantasy-land/traverse :: Applicative f => Maybe a ~> (TypeRep f, a -> f b) -> f (Maybe b)\n  //.\n  //.   - `traverse (A) (f) (Nothing)` is equivalent to `of (A) (Nothing)`\n  //.   - `traverse (A) (f) (Just (x))` is equivalent to `map (Just) (f (x))`\n  //.\n  //. ```javascript\n  //. > S.traverse (Array) (S.words) (Nothing)\n  //. [Nothing]\n  //.\n  //. > S.traverse (Array) (S.words) (Just ('foo bar baz'))\n  //. [Just ('foo'), Just ('bar'), Just ('baz')]\n  //. ```\n  function Nothing$prototype$traverse(typeRep, f) {\n    return Z.of (typeRep, this);\n  }\n  function Just$prototype$traverse(typeRep, f) {\n    return Z.map (Just, f (this.value));\n  }\n\n  //# Maybe#fantasy-land/extend :: Maybe a ~> (Maybe a -> b) -> Maybe b\n  //.\n  //.   - `extend (f) (Nothing)` is equivalent to `Nothing`\n  //.   - `extend (f) (Just (x))` is equivalent to `Just (f (Just (x)))`\n  //.\n  //. ```javascript\n  //. > S.extend (S.reduce (S.add) (1)) (Nothing)\n  //. Nothing\n  //.\n  //. > S.extend (S.reduce (S.add) (1)) (Just (99))\n  //. Just (100)\n  //. ```\n  function Nothing$prototype$extend(f) {\n    return this;\n  }\n  function Just$prototype$extend(f) {\n    return Just (f (this));\n  }\n\n  return Maybe;\n\n}));\n\n//. [Fantasy Land]:             v:fantasyland/fantasy-land\n//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals\n//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte\n//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if\n//. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers\n//. [type representative]:      v:fantasyland/fantasy-land#type-representatives\n});\n\nvar sanctuaryPair = createCommonjsModule(function (module) {\n/*                   *\\\n      //                     \\\\\n     //   @@  @@     @@  @@   \\\\\n    //      @@       @@  @@    \\\\\n    \\\\      @@       @@  @@    //\n     \\\\   @@  @@  @    @@ @   //\n      \\\\          /       @  //\n       \\*             @@@@  */\n\n//. <a href=\"https://github.com/fantasyland/fantasy-land\"><img alt=\"Fantasy Land\" src=\"https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png\" width=\"75\" height=\"75\" align=\"left\"></a>\n//.\n//. # sanctuary-pair\n//.\n//. Pair is the canonical product type: a value of type `Pair a b` always\n//. contains exactly two values: one of type `a`; one of type `b`.\n\n(function(f) {\n\n  /* istanbul ignore else */\n  {\n    module.exports = f (util,\n                        sanctuaryShow,\n                        sanctuaryTypeClasses);\n  }\n\n} (function(util, show, Z) {\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    var $ = __doctest.require ('sanctuary-def');\n    var type = __doctest.require ('sanctuary-type-identifiers');\n    var S = (function() {\n      var S = __doctest.require ('sanctuary');\n      var PairType = $.BinaryType\n        ('sanctuary-pair/Pair')\n        ('')\n        (function(x) { return type (x) === Pair['@@type']; })\n        (function(p) { return [p.fst]; })\n        (function(p) { return [p.snd]; });\n      var env = Z.concat (S.env,\n                          [$.TypeClass, PairType ($.Unknown) ($.Unknown)]);\n      return S.create ({checkTypes: true, env: env});\n    } ());\n  }\n\n  var prototype = {\n    /* eslint-disable key-spacing */\n    'constructor':            Pair,\n    '@@show':                 Pair$prototype$show,\n    'fantasy-land/compose':   Pair$prototype$compose,\n    'fantasy-land/map':       Pair$prototype$map,\n    'fantasy-land/bimap':     Pair$prototype$bimap,\n    'fantasy-land/reduce':    Pair$prototype$reduce,\n    'fantasy-land/traverse':  Pair$prototype$traverse,\n    'fantasy-land/extend':    Pair$prototype$extend,\n    'fantasy-land/extract':   Pair$prototype$extract\n    /* eslint-enable key-spacing */\n  };\n\n  var custom = util.inspect.custom;\n  /* istanbul ignore else */\n  if (typeof custom === 'symbol') {\n    prototype[custom] = Pair$prototype$show;\n  } else {\n    prototype.inspect = Pair$prototype$show;\n  }\n\n  /* istanbul ignore else */\n  if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n    prototype[Symbol.iterator] = function() {\n      return [this.fst, this.snd][Symbol.iterator] ();\n    };\n  }\n\n  //. `Pair a b` satisfies the following [Fantasy Land][] specifications:\n  //.\n  //. ```javascript\n  //. > const Useless = require ('sanctuary-useless')\n  //.\n  //. > S.map (k => k + ' '.repeat (16 - k.length) +\n  //. .             (Z[k].test (Pair (Useless) (Useless)) ? '\\u2705   ' :\n  //. .              Z[k].test (Pair (['foo']) (['bar'])) ? '\\u2705 * ' :\n  //. .              /* otherwise */                        '\\u274C   '))\n  //. .       (S.keys (S.unchecked.filter (S.is ($.TypeClass)) (Z)))\n  //. [ 'Setoid          ✅ * ',  // if ‘a’ and ‘b’ satisfy Setoid\n  //. . 'Ord             ✅ * ',  // if ‘a’ and ‘b’ satisfy Ord\n  //. . 'Semigroupoid    ✅   ',\n  //. . 'Category        ❌   ',\n  //. . 'Semigroup       ✅ * ',  // if ‘a’ and ‘b’ satisfy Semigroup\n  //. . 'Monoid          ❌   ',\n  //. . 'Group           ❌   ',\n  //. . 'Filterable      ❌   ',\n  //. . 'Functor         ✅   ',\n  //. . 'Bifunctor       ✅   ',\n  //. . 'Profunctor      ❌   ',\n  //. . 'Apply           ✅ * ',  // if ‘a’ satisfies Semigroup\n  //. . 'Applicative     ❌   ',\n  //. . 'Chain           ✅ * ',  // if ‘a’ satisfies Semigroup\n  //. . 'ChainRec        ❌   ',\n  //. . 'Monad           ❌   ',\n  //. . 'Alt             ❌   ',\n  //. . 'Plus            ❌   ',\n  //. . 'Alternative     ❌   ',\n  //. . 'Foldable        ✅   ',\n  //. . 'Traversable     ✅   ',\n  //. . 'Extend          ✅   ',\n  //. . 'Comonad         ✅   ',\n  //. . 'Contravariant   ❌   ' ]\n  //. ```\n\n  //# Pair :: a -> b -> Pair a b\n  //.\n  //. Pair's sole data constructor. Additionally, it serves as the\n  //. Pair [type representative][].\n  //.\n  //. ```javascript\n  //. > Pair (1) (2)\n  //. Pair (1) (2)\n  //. ```\n  function Pair(fst) {\n    return function(snd) {\n      var pair = Object.create (prototype);\n      if (Z.Setoid.test (fst) && Z.Setoid.test (snd)) {\n        pair['fantasy-land/equals'] = Pair$prototype$equals;\n        if (Z.Ord.test (fst) && Z.Ord.test (snd)) {\n          pair['fantasy-land/lte'] = Pair$prototype$lte;\n        }\n      }\n      if (Z.Semigroup.test (fst)) {\n        if (Z.Semigroup.test (snd)) {\n          pair['fantasy-land/concat'] = Pair$prototype$concat;\n        }\n        pair['fantasy-land/ap'] = Pair$prototype$ap;\n        pair['fantasy-land/chain'] = Pair$prototype$chain;\n      }\n      pair.fst = fst;\n      pair.snd = snd;\n      return pair;\n    };\n  }\n\n  //# Pair.fst :: Pair a b -> a\n  //.\n  //. `fst (Pair (x) (y))` is equivalent to `x`.\n  //.\n  //. ```javascript\n  //. > Pair.fst (Pair ('abc') ([1, 2, 3]))\n  //. 'abc'\n  //. ```\n  Pair.fst = function(p) { return p.fst; };\n\n  //# Pair.snd :: Pair a b -> b\n  //.\n  //. `snd (Pair (x) (y))` is equivalent to `y`.\n  //.\n  //. ```javascript\n  //. > Pair.snd (Pair ('abc') ([1, 2, 3]))\n  //. [1, 2, 3]\n  //. ```\n  Pair.snd = function(p) { return p.snd; };\n\n  //# Pair.swap :: Pair a b -> Pair b a\n  //.\n  //. `swap (Pair (x) (y))` is equivalent to `Pair (y) (x)`.\n  //.\n  //. ```javascript\n  //. > Pair.swap (Pair ('abc') ([1, 2, 3]))\n  //. Pair ([1, 2, 3]) ('abc')\n  //. ```\n  Pair.swap = function(p) { return Pair (p.snd) (p.fst); };\n\n  //# Pair.@@type :: String\n  //.\n  //. Pair [type identifier][].\n  //.\n  //. ```javascript\n  //. > type (Pair ('abc') ([1, 2, 3]))\n  //. 'sanctuary-pair/Pair@1'\n  //.\n  //. > type.parse (type (Pair ('abc') ([1, 2, 3])))\n  //. {namespace: 'sanctuary-pair', name: 'Pair', version: 1}\n  //. ```\n  Pair['@@type'] = 'sanctuary-pair/Pair@1';\n\n  //# Pair#@@show :: (Showable a, Showable b) => Pair a b ~> () -> String\n  //.\n  //. `show (Pair (x) (y))` is equivalent to\n  //. `'Pair (' + show (x) + ') (' + show (y) + ')'`.\n  //.\n  //. ```javascript\n  //. > show (Pair ('abc') ([1, 2, 3]))\n  //. 'Pair (\"abc\") ([1, 2, 3])'\n  //. ```\n  function Pair$prototype$show() {\n    return 'Pair (' + show (this.fst) + ') (' + show (this.snd) + ')';\n  }\n\n  //# Pair#fantasy-land/equals :: (Setoid a, Setoid b) => Pair a b ~> Pair a b -> Boolean\n  //.\n  //. `Pair (x) (y)` is equal to `Pair (v) (w)` [iff][] `x` is equal to `v`\n  //. and `y` is equal to `w` according to [`Z.equals`][].\n  //.\n  //. ```javascript\n  //. > S.equals (Pair ('abc') ([1, 2, 3])) (Pair ('abc') ([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals (Pair ('abc') ([1, 2, 3])) (Pair ('abc') ([3, 2, 1]))\n  //. false\n  //. ```\n  function Pair$prototype$equals(other) {\n    return Z.equals (this.fst, other.fst) && Z.equals (this.snd, other.snd);\n  }\n\n  //# Pair#fantasy-land/lte :: (Ord a, Ord b) => Pair a b ~> Pair a b -> Boolean\n  //.\n  //. `Pair (x) (y)` is less than or equal to `Pair (v) (w)` [iff][] `x` is\n  //. less than `v` or `x` is equal to `v` and `y` is less than or equal to\n  //. `w` according to [`Z.lte`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.lte (Pair ('b') (2)))\n  //. .          ([Pair ('a') (1), Pair ('a') (2), Pair ('a') (3),\n  //. .            Pair ('b') (1), Pair ('b') (2), Pair ('b') (3),\n  //. .            Pair ('c') (1), Pair ('c') (2), Pair ('c') (3)])\n  //. [ Pair ('a') (1),\n  //. . Pair ('a') (2),\n  //. . Pair ('a') (3),\n  //. . Pair ('b') (1),\n  //. . Pair ('b') (2) ]\n  //. ```\n  function Pair$prototype$lte(other) {\n    return Z.equals (this.fst, other.fst) ? Z.lte (this.snd, other.snd)\n                                          : Z.lte (this.fst, other.fst);\n  }\n\n  //# Pair#fantasy-land/compose :: Pair a b ~> Pair b c -> Pair a c\n  //.\n  //. `compose (Pair (x) (y)) (Pair (v) (w))` is equivalent to `Pair (v) (y)`.\n  //.\n  //. ```javascript\n  //. > S.compose (Pair ('a') (0)) (Pair ([1, 2, 3]) ('b'))\n  //. Pair ([1, 2, 3]) (0)\n  //. ```\n  function Pair$prototype$compose(other) {\n    return Pair (this.fst) (other.snd);\n  }\n\n  //# Pair#fantasy-land/concat :: (Semigroup a, Semigroup b) => Pair a b ~> Pair a b -> Pair a b\n  //.\n  //. `concat (Pair (x) (y)) (Pair (v) (w))` is equivalent to\n  //. `Pair (concat (x) (v)) (concat (y) (w))`.\n  //.\n  //. ```javascript\n  //. > S.concat (Pair ('abc') ([1, 2, 3])) (Pair ('xyz') ([4, 5, 6]))\n  //. Pair ('abcxyz') ([1, 2, 3, 4, 5, 6])\n  //. ```\n  function Pair$prototype$concat(other) {\n    return Pair (Z.concat (this.fst, other.fst))\n                (Z.concat (this.snd, other.snd));\n  }\n\n  //# Pair#fantasy-land/map :: Pair a b ~> (b -> c) -> Pair a c\n  //.\n  //. `map (f) (Pair (x) (y))` is equivalent to `Pair (x) (f (y))`.\n  //.\n  //. ```javascript\n  //. > S.map (Math.sqrt) (Pair ('abc') (256))\n  //. Pair ('abc') (16)\n  //. ```\n  function Pair$prototype$map(f) {\n    return Pair (this.fst) (f (this.snd));\n  }\n\n  //# Pair#fantasy-land/bimap :: Pair a c ~> (a -> b, c -> d) -> Pair b d\n  //.\n  //. `bimap (f) (g) (Pair (x) (y))` is equivalent to `Pair (f (x)) (g (y))`.\n  //.\n  //. ```javascript\n  //. > S.bimap (S.toUpper) (Math.sqrt) (Pair ('abc') (256))\n  //. Pair ('ABC') (16)\n  //. ```\n  function Pair$prototype$bimap(f, g) {\n    return Pair (f (this.fst)) (g (this.snd));\n  }\n\n  //# Pair#fantasy-land/ap :: Semigroup a => Pair a b ~> Pair a (b -> c) -> Pair a c\n  //.\n  //. `ap (Pair (v) (f)) (Pair (x) (y))` is equivalent to\n  //. `Pair (concat (v) (x)) (f (y))`.\n  //.\n  //. ```javascript\n  //. > S.ap (Pair ('abc') (Math.sqrt)) (Pair ('xyz') (256))\n  //. Pair ('abcxyz') (16)\n  //. ```\n  function Pair$prototype$ap(other) {\n    return Pair (Z.concat (other.fst, this.fst)) (other.snd (this.snd));\n  }\n\n  //# Pair#fantasy-land/chain :: Semigroup a => Pair a b ~> (b -> Pair a c) -> Pair a c\n  //.\n  //. `chain (f) (Pair (x) (y))` is equivalent to\n  //. `Pair (concat (x) (fst (f (y)))) (snd (f (y)))`.\n  //.\n  //. ```javascript\n  //. > S.chain (n => Pair (show (n)) (Math.sqrt (n))) (Pair ('abc') (256))\n  //. Pair ('abc256') (16)\n  //. ```\n  function Pair$prototype$chain(f) {\n    var other = f (this.snd);\n    return Pair (Z.concat (this.fst, other.fst)) (other.snd);\n  }\n\n  //# Pair#fantasy-land/reduce :: Pair a b ~> ((c, b) -> c, c) -> c\n  //.\n  //. `reduce (f) (x) (Pair (v) (w))` is equivalent to `f (x) (w)`.\n  //.\n  //. ```javascript\n  //. > S.reduce (S.concat) ([1, 2, 3]) (Pair ('abc') ([4, 5, 6]))\n  //. [1, 2, 3, 4, 5, 6]\n  //. ```\n  function Pair$prototype$reduce(f, x) {\n    return f (x, this.snd);\n  }\n\n  //# Pair#fantasy-land/traverse :: Applicative f => Pair a b ~> (TypeRep f, b -> f c) -> f (Pair a c)\n  //.\n  //. `traverse (_) (f) (Pair (x) (y))` is equivalent to\n  //. `map (Pair (x)) (f (y))`.\n  //.\n  //. ```javascript\n  //. > S.traverse (Array) (S.words) (Pair (123) ('foo bar baz'))\n  //. [Pair (123) ('foo'), Pair (123) ('bar'), Pair (123) ('baz')]\n  //. ```\n  function Pair$prototype$traverse(typeRep, f) {\n    return Z.map (Pair (this.fst), f (this.snd));\n  }\n\n  //# Pair#fantasy-land/extend :: Pair a b ~> (Pair a b -> c) -> Pair a c\n  //.\n  //. `extend (f) (Pair (x) (y))` is equivalent to\n  //. `Pair (x) (f (Pair (x) (y)))`.\n  //.\n  //. ```javascript\n  //. > S.extend (S.reduce (S.add) (1)) (Pair ('abc') (99))\n  //. Pair ('abc') (100)\n  //. ```\n  function Pair$prototype$extend(f) {\n    return Pair (this.fst) (f (this));\n  }\n\n  //# Pair#fantasy-land/extract :: Pair a b ~> () -> b\n  //.\n  //. `extract (Pair (x) (y))` is equivalent to `y`.\n  //.\n  //. ```javascript\n  //. > S.extract (Pair ('abc') ([1, 2, 3]))\n  //. [1, 2, 3]\n  //. ```\n  function Pair$prototype$extract() {\n    return this.snd;\n  }\n\n  return Pair;\n\n}));\n\n//. [Fantasy Land]:             v:fantasyland/fantasy-land\n//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals\n//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte\n//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if\n//. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers\n//. [type representative]:      v:fantasyland/fantasy-land#type-representatives\n});\n\nvar sanctuary = createCommonjsModule(function (module) {\n/*    #######\n   ####     ####\n ####   ###   ####\n#####   ###########   sanctuary\n########   ########   noun\n###########   #####   1 [ mass noun ] refuge from unsafe JavaScript\n ####   ###   ####\n   ####     ####\n      #######    */\n\n//. # Sanctuary\n//.\n//. [![npm](https://img.shields.io/npm/v/sanctuary.svg)](https://www.npmjs.com/package/sanctuary)\n//. [![CircleCI](https://img.shields.io/circleci/project/github/sanctuary-js/sanctuary/master.svg)](https://circleci.com/gh/sanctuary-js/sanctuary/tree/master)\n//. [![Gitter](https://img.shields.io/gitter/room/badges/shields.svg)](https://gitter.im/sanctuary-js/sanctuary)\n//.\n//. Sanctuary is a JavaScript functional programming library inspired by\n//. [Haskell][] and [PureScript][]. It's stricter than [Ramda][], and\n//. provides a similar suite of functions.\n//.\n//. Sanctuary promotes programs composed of simple, pure functions. Such\n//. programs are easier to comprehend, test, and maintain &ndash; they are\n//. also a pleasure to write.\n//.\n//. Sanctuary provides two data types, [Maybe][] and [Either][], both of\n//. which are compatible with [Fantasy Land][]. Thanks to these data types\n//. even Sanctuary functions that may fail, such as [`head`](#head), are\n//. composable.\n//.\n//. Sanctuary makes it possible to write safe code without null checks.\n//. In JavaScript it's trivial to introduce a possible run-time type error:\n//.\n//.     words[0].toUpperCase()\n//.\n//. If `words` is `[]` we'll get a familiar error at run-time:\n//.\n//.     TypeError: Cannot read property 'toUpperCase' of undefined\n//.\n//. Sanctuary gives us a fighting chance of avoiding such errors. We might\n//. write:\n//.\n//.     S.map (S.toUpper) (S.head (words))\n//.\n//. Sanctuary is designed to work in Node.js and in ES5-compatible browsers.\n//.\n//. ## Folktale\n//.\n//. [Folktale][], like Sanctuary, is a standard library for functional\n//. programming in JavaScript. It is well designed and well documented.\n//. Whereas Sanctuary treats JavaScript as a member of the ML language\n//. family, Folktale embraces JavaScript's object-oriented programming\n//. model. Programming with Folktale resembles programming with Scala.\n//.\n//. ## Ramda\n//.\n//. [Ramda][] provides several functions that return problematic values\n//. such as `undefined`, `Infinity`, or `NaN` when applied to unsuitable\n//. inputs. These are known as [partial functions][]. Partial functions\n//. necessitate the use of guards or null checks. In order to safely use\n//. `R.head`, for example, one must ensure that the array is non-empty:\n//.\n//.     if (R.isEmpty (xs)) {\n//.       // ...\n//.     } else {\n//.       return f (R.head (xs));\n//.     }\n//.\n//. Using the Maybe type renders such guards (and null checks) unnecessary.\n//. Changing functions such as `R.head` to return Maybe values was proposed\n//. in [ramda/ramda#683][], but was considered too much of a stretch for\n//. JavaScript programmers. Sanctuary was released the following month,\n//. in January 2015, as a companion library to Ramda.\n//.\n//. In addition to broadening in scope in the years since its release,\n//. Sanctuary's philosophy has diverged from Ramda's in several respects.\n//.\n//. ### Totality\n//.\n//. Every Sanctuary function is defined for every value that is a member of\n//. the function's input type. Such functions are known as [total functions][].\n//. Ramda, on the other hand, contains a number of [partial functions][].\n//.\n//. ### Information preservation\n//.\n//. Certain Sanctuary functions preserve more information than their Ramda\n//. counterparts. Examples:\n//.\n//.     |> R.tail ([])                      |> S.tail ([])\n//.     []                                  Nothing\n//.\n//.     |> R.tail (['foo'])                 |> S.tail (['foo'])\n//.     []                                  Just ([])\n//.\n//.     |> R.replace (/^x/) ('') ('abc')    |> S.stripPrefix ('x') ('abc')\n//.     'abc'                               Nothing\n//.\n//.     |> R.replace (/^x/) ('') ('xabc')   |> S.stripPrefix ('x') ('xabc')\n//.     'abc'                               Just ('abc')\n//.\n//. ### Invariants\n//.\n//. Sanctuary performs rigorous [type checking][] of inputs and outputs, and\n//. throws a descriptive error if a type error is encountered. This allows bugs\n//. to be caught and fixed early in the development cycle.\n//.\n//. Ramda operates on the [garbage in, garbage out][GIGO] principle. Functions\n//. are documented to take arguments of particular types, but these invariants\n//. are not enforced. The problem with this approach in a language as\n//. permissive as JavaScript is that there's no guarantee that garbage input\n//. will produce garbage output ([ramda/ramda#1413][]). Ramda performs ad hoc\n//. type checking in some such cases ([ramda/ramda#1419][]).\n//.\n//. Sanctuary can be configured to operate in garbage in, garbage out mode.\n//. Ramda cannot be configured to enforce its invariants.\n//.\n//. ### Currying\n//.\n//. Sanctuary functions are curried. There is, for example, exactly one way to\n//. apply `S.reduce` to `S.add`, `0`, and `xs`:\n//.\n//.   - `S.reduce (S.add) (0) (xs)`\n//.\n//. Ramda functions are also curried, but in a complex manner. There are four\n//. ways to apply `R.reduce` to `R.add`, `0`, and `xs`:\n//.\n//.   - `R.reduce (R.add) (0) (xs)`\n//.   - `R.reduce (R.add) (0, xs)`\n//.   - `R.reduce (R.add, 0) (xs)`\n//.   - `R.reduce (R.add, 0, xs)`\n//.\n//. Ramda supports all these forms because curried functions enable partial\n//. application, one of the library's tenets, but `f(x)(y)(z)` is considered\n//. too unfamiliar and too unattractive to appeal to JavaScript programmers.\n//.\n//. Sanctuary's developers prefer a simple, unfamiliar construct to a complex,\n//. familiar one. Familiarity can be acquired; complexity is intrinsic.\n//.\n//. The lack of breathing room in `f(x)(y)(z)` impairs readability. The simple\n//. solution to this problem, proposed in [#438][], is to include a space when\n//. applying a function: `f (x) (y) (z)`.\n//.\n//. Ramda also provides a special placeholder value, [`R.__`][], that removes\n//. the restriction that a function must be applied to its arguments in order.\n//. The following expressions are equivalent:\n//.\n//.   - `R.reduce (R.__, 0, xs) (R.add)`\n//.   - `R.reduce (R.add, R.__, xs) (0)`\n//.   - `R.reduce (R.__, 0) (R.add) (xs)`\n//.   - `R.reduce (R.__, 0) (R.add, xs)`\n//.   - `R.reduce (R.__, R.__, xs) (R.add) (0)`\n//.   - `R.reduce (R.__, R.__, xs) (R.add, 0)`\n//.\n//. ### Variadic functions\n//.\n//. Ramda provides several functions that take any number of arguments. These\n//. are known as [variadic functions][]. Additionally, Ramda provides several\n//. functions that take variadic functions as arguments. Although natural in\n//. a dynamically typed language, variadic functions are at odds with the type\n//. notation Ramda and Sanctuary both use, leading to some indecipherable type\n//. signatures such as this one:\n//.\n//.     R.lift :: (*... -> *...) -> ([*]... -> [*])\n//.\n//. Sanctuary has no variadic functions, nor any functions that take variadic\n//. functions as arguments. Sanctuary provides two \"lift\" functions, each with\n//. a helpful type signature:\n//.\n//.     S.lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c\n//.     S.lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n//.\n//. ### Implicit context\n//.\n//. Ramda provides [`R.bind`][] and [`R.invoker`][] for working with methods.\n//. Additionally, many Ramda functions use `Function#call` or `Function#apply`\n//. to preserve context. Sanctuary makes no allowances for `this`.\n//.\n//. ### Transducers\n//.\n//. Several Ramda functions act as transducers. Sanctuary provides no support\n//. for transducers.\n//.\n//. ### Modularity\n//.\n//. Whereas Ramda has no dependencies, Sanctuary has a modular design:\n//. [sanctuary-def][] provides type checking, [sanctuary-type-classes][]\n//. provides Fantasy Land functions and type classes, [sanctuary-show][]\n//. provides string representations, and algebraic data types are provided\n//. by [sanctuary-either][], [sanctuary-maybe][], and [sanctuary-pair][].\n//. Not only does this approach reduce the complexity of Sanctuary itself,\n//. but it allows these components to be reused in other contexts.\n//.\n//. ## Types\n//.\n//. Sanctuary uses Haskell-like type signatures to describe the types of\n//. values, including functions. `'foo'`, for example, is a member of `String`;\n//. `[1, 2, 3]` is a member of `Array Number`. The double colon (`::`) is used\n//. to mean \"is a member of\", so one could write:\n//.\n//.     'foo' :: String\n//.     [1, 2, 3] :: Array Number\n//.\n//. An identifier may appear to the left of the double colon:\n//.\n//.     Math.PI :: Number\n//.\n//. The arrow (`->`) is used to express a function's type:\n//.\n//.     Math.abs :: Number -> Number\n//.\n//. That states that `Math.abs` is a unary function that takes an argument\n//. of type `Number` and returns a value of type `Number`.\n//.\n//. Some functions are parametrically polymorphic: their types are not fixed.\n//. Type variables are used in the representations of such functions:\n//.\n//.     S.I :: a -> a\n//.\n//. `a` is a type variable. Type variables are not capitalized, so they\n//. are differentiable from type identifiers (which are always capitalized).\n//. By convention type variables have single-character names. The signature\n//. above states that `S.I` takes a value of any type and returns a value of\n//. the same type. Some signatures feature multiple type variables:\n//.\n//.     S.K :: a -> b -> a\n//.\n//. It must be possible to replace all occurrences of `a` with a concrete type.\n//. The same applies for each other type variable. For the function above, the\n//. types with which `a` and `b` are replaced may be different, but needn't be.\n//.\n//. Since all Sanctuary functions are curried (they accept their arguments\n//. one at a time), a binary function is represented as a unary function that\n//. returns a unary function: `* -> * -> *`. This aligns neatly with Haskell,\n//. which uses curried functions exclusively. In JavaScript, though, we may\n//. wish to represent the types of functions with arities less than or greater\n//. than one. The general form is `(<input-types>) -> <output-type>`, where\n//. `<input-types>` comprises zero or more comma–space (<code>, </code>)\n//. -separated type representations:\n//.\n//.   - `() -> String`\n//.   - `(a, b) -> a`\n//.   - `(a, b, c) -> d`\n//.\n//. `Number -> Number` can thus be seen as shorthand for `(Number) -> Number`.\n//.\n//. Sanctuary embraces types. JavaScript doesn't support algebraic data types,\n//. but these can be simulated by providing a group of data constructors that\n//. return values with the same set of methods. A value of the Either type, for\n//. example, is created via the Left constructor or the Right constructor.\n//.\n//. It's necessary to extend Haskell's notation to describe implicit arguments\n//. to the *methods* provided by Sanctuary's types. In `x.map(y)`, for example,\n//. the `map` method takes an implicit argument `x` in addition to the explicit\n//. argument `y`. The type of the value upon which a method is invoked appears\n//. at the beginning of the signature, separated from the arguments and return\n//. value by a squiggly arrow (`~>`). The type of the `fantasy-land/map` method\n//. of the Maybe type is written `Maybe a ~> (a -> b) -> Maybe b`. One could\n//. read this as:\n//.\n//. _When the `fantasy-land/map` method is invoked on a value of type `Maybe a`\n//. (for any type `a`) with an argument of type `a -> b` (for any type `b`),\n//. it returns a value of type `Maybe b`._\n//.\n//. The squiggly arrow is also used when representing non-function properties.\n//. `Maybe a ~> Boolean`, for example, represents a Boolean property of a value\n//. of type `Maybe a`.\n//.\n//. Sanctuary supports type classes: constraints on type variables. Whereas\n//. `a -> a` implicitly supports every type, `Functor f => (a -> b) -> f a ->\n//. f b` requires that `f` be a type that satisfies the requirements of the\n//. Functor type class. Type-class constraints appear at the beginning of a\n//. type signature, separated from the rest of the signature by a fat arrow\n//. (`=>`).\n//.\n//. ## Type checking\n//.\n//. Sanctuary functions are defined via [sanctuary-def][] to provide run-time\n//. type checking. This is tremendously useful during development: type errors\n//. are reported immediately, avoiding circuitous stack traces (at best) and\n//. silent failures due to type coercion (at worst). For example:\n//.\n//. ```javascript\n//. S.add (2) (true);\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: FiniteNumber -> FiniteNumber -> FiniteNumber\n//. //                          ^^^^^^^^^^^^\n//. //                               1\n//. //\n//. //   1)  true :: Boolean\n//. //\n//. //   The value at position 1 is not a member of ‘FiniteNumber’.\n//. //\n//. //   See v:sanctuary-js/sanctuary-def#FiniteNumber for information about the FiniteNumber type.\n//. ```\n//.\n//. Compare this to the behaviour of Ramda's unchecked equivalent:\n//.\n//. ```javascript\n//. R.add (2) (true);\n//. // => 3\n//. ```\n//.\n//. There is a performance cost to run-time type checking. Type checking is\n//. disabled by default if `process.env.NODE_ENV` is `'production'`. If this\n//. rule is unsuitable for a given program, one may use [`create`](#create)\n//. to create a Sanctuary module based on a different rule. For example:\n//.\n//. ```javascript\n//. const S = sanctuary.create ({\n//.   checkTypes: localStorage.getItem ('SANCTUARY_CHECK_TYPES') === 'true',\n//.   env: sanctuary.env,\n//. });\n//. ```\n//.\n//. Occasionally one may wish to perform an operation that is not type safe,\n//. such as mapping over an object with heterogeneous values. This is possible\n//. via selective use of [`unchecked`](#unchecked) functions.\n//.\n//. ## Installation\n//.\n//. `npm install sanctuary` will install Sanctuary for use in Node.js.\n//.\n//. Running Sanctuary in the browser is more involved. One must include a\n//. `<script>` for each dependency in addition to one for Sanctuary itself:\n//.\n//. ```html\n//. <script src=\"vendor/sanctuary-show.js\"></script>\n//. <script src=\"vendor/sanctuary-type-identifiers.js\"></script>\n//. <script src=\"vendor/sanctuary-type-classes.js\"></script>\n//. <script src=\"vendor/sanctuary-either.js\"></script>\n//. <script src=\"vendor/sanctuary-maybe.js\"></script>\n//. <script src=\"vendor/sanctuary-pair.js\"></script>\n//. <script src=\"vendor/sanctuary-def.js\"></script>\n//. <script src=\"vendor/sanctuary.js\"></script>\n//. ```\n//.\n//. To ensure compatibility one should use the dependency versions specified\n//. in __package.json__.\n//.\n//. For convenience one could define aliases for various modules:\n//.\n//. ```javascript\n//. const S = window.sanctuary;\n//. const $ = window.sanctuaryDef;\n//. // ...\n//. ```\n//.\n//. ## API\n\n(function(f) {\n\n  /* istanbul ignore else */\n  {\n    module.exports = f (sanctuaryDef,\n                        sanctuaryEither,\n                        sanctuaryMaybe,\n                        sanctuaryPair,\n                        sanctuaryShow,\n                        sanctuaryTypeClasses,\n                        sanctuaryTypeIdentifiers);\n  }\n\n} (function($, Either, Maybe, Pair, show, Z, type) {\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    /* eslint-disable no-unused-vars */\n    var Descending = __doctest.require ('sanctuary-descending');\n    var Nil = (__doctest.require ('./test/internal/List')).Nil;\n    var Cons = (__doctest.require ('./test/internal/List')).Cons;\n    var Sum = __doctest.require ('./test/internal/Sum');\n    var S = (function(S) {\n      var S_ = S.create ({\n        checkTypes: true,\n        env: S.env.concat ([\n          (__doctest.require ('./test/internal/List')).Type ($.Unknown),\n          Sum.Type\n        ])\n      });\n      S_.env = S.env;  // see S.env doctest\n      return S_;\n    } (sanctuary));\n    /* eslint-enable no-unused-vars */\n  }\n\n  //  Left :: a -> Either a b\n  var Left = Either.Left;\n\n  //  Right :: b -> Either a b\n  var Right = Either.Right;\n\n  //  Nothing :: Maybe a\n  var Nothing = Maybe.Nothing;\n\n  //  Just :: a -> Maybe a\n  var Just = Maybe.Just;\n\n  //  B :: (b -> c) -> (a -> b) -> a -> c\n  function B(f) {\n    return function(g) {\n      return function(x) {\n        return f (g (x));\n      };\n    };\n  }\n\n  //  C :: (a -> b -> c) -> b -> a -> c\n  function C(f) {\n    return function(y) {\n      return function(x) {\n        return f (x) (y);\n      };\n    };\n  }\n\n  //  get_ :: String -> a -> Maybe b\n  function get_(key) {\n    return B (function(obj) { return key in obj ? Just (obj[key]) : Nothing; })\n             (toObject);\n  }\n\n  //  invoke0 :: String -> a -> b\n  function invoke0(name) {\n    return function(target) {\n      return target[name] ();\n    };\n  }\n\n  //  invoke1 :: String -> a -> b -> c\n  function invoke1(name) {\n    return function(x) {\n      return function(target) {\n        return target[name] (x);\n      };\n    };\n  }\n\n  //  toObject :: a -> Object\n  function toObject(x) {\n    return x == null ? Object.create (null) : Object (x);\n  }\n\n  //  :: Type\n  var a = $.TypeVariable ('a');\n  var b = $.TypeVariable ('b');\n  var c = $.TypeVariable ('c');\n  var d = $.TypeVariable ('d');\n  var e = $.TypeVariable ('e');\n  var g = $.TypeVariable ('g');\n  var r = $.TypeVariable ('r');\n\n  //  :: Type -> Type\n  var f = $.UnaryTypeVariable ('f');\n  var m = $.UnaryTypeVariable ('m');\n  var t = $.UnaryTypeVariable ('t');\n  var w = $.UnaryTypeVariable ('w');\n\n  //  :: Type -> Type -> Type\n  var p = $.BinaryTypeVariable ('p');\n  var s = $.BinaryTypeVariable ('s');\n\n  //  TypeRep :: Type -> Type\n  var TypeRep = $.UnaryType\n    ('TypeRep')\n    ('https://github.com/fantasyland/fantasy-land#type-representatives')\n    ([])\n    (function(x) {\n       return $.test ([]) ($.AnyFunction) (x) ||\n              x != null && $.test ([]) ($.String) (x['@@type']);\n     })\n    (K ([]));\n\n  //  Options :: Type\n  var Options = $.RecordType ({checkTypes: $.Boolean, env: $.Array ($.Any)});\n\n  var _ = {};\n\n  //. ### Configure\n\n  //# create :: { checkTypes :: Boolean, env :: Array Type } -> Module\n  //.\n  //. Takes an options record and returns a Sanctuary module. `checkTypes`\n  //. specifies whether to enable type checking. The module's polymorphic\n  //. functions (such as [`I`](#I)) require each value associated with a\n  //. type variable to be a member of at least one type in the environment.\n  //.\n  //. A well-typed application of a Sanctuary function will produce the same\n  //. result regardless of whether type checking is enabled. If type checking\n  //. is enabled, a badly typed application will produce an exception with a\n  //. descriptive error message.\n  //.\n  //. The following snippet demonstrates defining a custom type and using\n  //. `create` to produce a Sanctuary module that is aware of that type:\n  //.\n  //. ```javascript\n  //. const {create, env} = require ('sanctuary');\n  //. const $ = require ('sanctuary-def');\n  //. const type = require ('sanctuary-type-identifiers');\n  //.\n  //. //    Identity :: a -> Identity a\n  //. const Identity = x => {\n  //.   const identity = Object.create (Identity$prototype);\n  //.   identity.value = x;\n  //.   return identity;\n  //. };\n  //.\n  //. Identity['@@type'] = 'my-package/Identity@1';\n  //.\n  //. const Identity$prototype = {\n  //.   'constructor': Identity,\n  //.   '@@show': function() { return `Identity (${S.show (this.value)})`; },\n  //.   'fantasy-land/map': function(f) { return Identity (f (this.value)); },\n  //. };\n  //.\n  //. //    IdentityType :: Type -> Type\n  //. const IdentityType = $.UnaryType\n  //.   ('Identity')\n  //.   ('http://example.com/my-package#Identity')\n  //.   ([])\n  //.   (x => type (x) === Identity['@@type'])\n  //.   (identity => [identity.value]);\n  //.\n  //. const S = create ({\n  //.   checkTypes: process.env.NODE_ENV !== 'production',\n  //.   env: env.concat ([IdentityType ($.Unknown)]),\n  //. });\n  //.\n  //. S.map (S.sub (1)) (Identity (43));\n  //. // => Identity (42)\n  //. ```\n  //.\n  //. See also [`env`](#env).\n  function create(opts) {\n    var def = $.create (opts);\n    var S = {\n      env: opts.env,\n      is: def ('is') ({}) ([$.Type, $.Any, $.Boolean]) ($.test (opts.env)),\n      Maybe: Maybe,\n      Nothing: Nothing,\n      Either: Either\n    };\n    (Object.keys (_)).forEach (function(name) {\n      S[name] = def (name) (_[name].consts) (_[name].types) (_[name].impl);\n    });\n    S.unchecked = opts.checkTypes ? create ({checkTypes: false, env: opts.env})\n                                  : S;\n    return S;\n  }\n  _.create = {\n    consts: {},\n    types: [Options, $.Object],\n    impl: create\n  };\n\n  //# env :: Array Type\n  //.\n  //. The Sanctuary module's environment (`(S.create ({checkTypes, env})).env`\n  //. is a reference to `env`). Useful in conjunction with [`create`](#create).\n  //.\n  //. ```javascript\n  //. > S.env\n  //. [ $.AnyFunction,\n  //. . $.Arguments,\n  //. . $.Array ($.Unknown),\n  //. . $.Array2 ($.Unknown) ($.Unknown),\n  //. . $.Boolean,\n  //. . $.Date,\n  //. . $.Descending ($.Unknown),\n  //. . $.Either ($.Unknown) ($.Unknown),\n  //. . $.Error,\n  //. . $.Fn ($.Unknown) ($.Unknown),\n  //. . $.HtmlElement,\n  //. . $.Identity ($.Unknown),\n  //. . $.Maybe ($.Unknown),\n  //. . $.Null,\n  //. . $.Number,\n  //. . $.Object,\n  //. . $.Pair ($.Unknown) ($.Unknown),\n  //. . $.RegExp,\n  //. . $.StrMap ($.Unknown),\n  //. . $.String,\n  //. . $.Symbol,\n  //. . $.Type,\n  //. . $.TypeClass,\n  //. . $.Undefined ]\n  //. ```\n\n  //# unchecked :: Module\n  //.\n  //. A complete Sanctuary module that performs no type checking. This is\n  //. useful as it permits operations that Sanctuary's type checking would\n  //. disallow, such as mapping over an object with heterogeneous values.\n  //.\n  //. See also [`create`](#create).\n  //.\n  //. ```javascript\n  //. > S.unchecked.map (S.show) ({x: 'foo', y: true, z: 42})\n  //. {x: '\"foo\"', y: 'true', z: '42'}\n  //. ```\n  //.\n  //. Opting out of type checking may cause type errors to go unnoticed.\n  //.\n  //. ```javascript\n  //. > S.unchecked.add (2) ('2')\n  //. '22'\n  //. ```\n\n  //. ### Classify\n\n  //# type :: Any -> { namespace :: Maybe String, name :: String, version :: NonNegativeInteger }\n  //.\n  //. Returns the result of parsing the [type identifier][] of the given value.\n  //.\n  //. ```javascript\n  //. > S.type (S.Just (42))\n  //. {namespace: Just ('sanctuary-maybe'), name: 'Maybe', version: 1}\n  //.\n  //. > S.type ([1, 2, 3])\n  //. {namespace: Nothing, name: 'Array', version: 0}\n  //. ```\n  function type_(x) {\n    var r = type.parse (type (x));\n    r.namespace = Z.reject (equals (null), Just (r.namespace));\n    return r;\n  }\n  _.type = {\n    consts: {},\n    types: [$.Any,\n            $.RecordType ({namespace: $.Maybe ($.String),\n                           name: $.String,\n                           version: $.NonNegativeInteger})],\n    impl: type_\n  };\n\n  //# is :: Type -> Any -> Boolean\n  //.\n  //. Returns `true` [iff][] the given value is a member of the specified type.\n  //. See [`$.test`][] for details.\n  //.\n  //. ```javascript\n  //. > S.is ($.Array ($.Integer)) ([1, 2, 3])\n  //. true\n  //.\n  //. > S.is ($.Array ($.Integer)) ([1, 2, 3.14])\n  //. false\n  //. ```\n\n  //. ### Showable\n\n  //# show :: Any -> String\n  //.\n  //. Alias of [`show`][].\n  //.\n  //. ```javascript\n  //. > S.show (-0)\n  //. '-0'\n  //.\n  //. > S.show (['foo', 'bar', 'baz'])\n  //. '[\"foo\", \"bar\", \"baz\"]'\n  //.\n  //. > S.show ({x: 1, y: 2, z: 3})\n  //. '{\"x\": 1, \"y\": 2, \"z\": 3}'\n  //.\n  //. > S.show (S.Left (S.Right (S.Just (S.Nothing))))\n  //. 'Left (Right (Just (Nothing)))'\n  //. ```\n  _.show = {\n    consts: {},\n    types: [$.Any, $.String],\n    impl: show\n  };\n\n  //. ### Fantasy Land\n  //.\n  //. Sanctuary is compatible with the [Fantasy Land][] specification.\n\n  //# equals :: Setoid a => a -> a -> Boolean\n  //.\n  //. Curried version of [`Z.equals`][] that requires two arguments of the\n  //. same type.\n  //.\n  //. To compare values of different types first use [`create`](#create) to\n  //. create a Sanctuary module with type checking disabled, then use that\n  //. module's `equals` function.\n  //.\n  //. ```javascript\n  //. > S.equals (0) (-0)\n  //. true\n  //.\n  //. > S.equals (NaN) (NaN)\n  //. true\n  //.\n  //. > S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 4]))\n  //. false\n  //. ```\n  function equals(x) {\n    return function(y) {\n      return Z.equals (x, y);\n    };\n  }\n  _.equals = {\n    consts: {a: [Z.Setoid]},\n    types: [a, a, $.Boolean],\n    impl: equals\n  };\n\n  //# lt :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is less than the first\n  //. according to [`Z.lt`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.lt (3)) ([1, 2, 3, 4, 5])\n  //. [1, 2]\n  //. ```\n  function lt(y) {\n    return function(x) {\n      return Z.lt (x, y);\n    };\n  }\n  _.lt = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: lt\n  };\n\n  //# lte :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is less than or equal to\n  //. the first according to [`Z.lte`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.lte (3)) ([1, 2, 3, 4, 5])\n  //. [1, 2, 3]\n  //. ```\n  function lte(y) {\n    return function(x) {\n      return Z.lte (x, y);\n    };\n  }\n  _.lte = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: lte\n  };\n\n  //# gt :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is greater than the first\n  //. according to [`Z.gt`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.gt (3)) ([1, 2, 3, 4, 5])\n  //. [4, 5]\n  //. ```\n  function gt(y) {\n    return function(x) {\n      return Z.gt (x, y);\n    };\n  }\n  _.gt = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: gt\n  };\n\n  //# gte :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the *second* argument is greater than or equal\n  //. to the first according to [`Z.gte`][].\n  //.\n  //. ```javascript\n  //. > S.filter (S.gte (3)) ([1, 2, 3, 4, 5])\n  //. [3, 4, 5]\n  //. ```\n  function gte(y) {\n    return function(x) {\n      return Z.gte (x, y);\n    };\n  }\n  _.gte = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, $.Boolean],\n    impl: gte\n  };\n\n  //# min :: Ord a => a -> a -> a\n  //.\n  //. Returns the smaller of its two arguments (according to [`Z.lte`][]).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > S.min (10) (2)\n  //. 2\n  //.\n  //. > S.min (new Date ('1999-12-31')) (new Date ('2000-01-01'))\n  //. new Date ('1999-12-31')\n  //.\n  //. > S.min ('10') ('2')\n  //. '10'\n  //. ```\n  _.min = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, a],\n    impl: curry2 (Z.min)\n  };\n\n  //# max :: Ord a => a -> a -> a\n  //.\n  //. Returns the larger of its two arguments (according to [`Z.lte`][]).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > S.max (10) (2)\n  //. 10\n  //.\n  //. > S.max (new Date ('1999-12-31')) (new Date ('2000-01-01'))\n  //. new Date ('2000-01-01')\n  //.\n  //. > S.max ('10') ('2')\n  //. '2'\n  //. ```\n  _.max = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, a],\n    impl: curry2 (Z.max)\n  };\n\n  //# clamp :: Ord a => a -> a -> a -> a\n  //.\n  //. Takes a lower bound, an upper bound, and a value of the same type.\n  //. Returns the value if it is within the bounds; the nearer bound otherwise.\n  //.\n  //. See also [`min`](#min) and [`max`](#max).\n  //.\n  //. ```javascript\n  //. > S.clamp (0) (100) (42)\n  //. 42\n  //.\n  //. > S.clamp (0) (100) (-1)\n  //. 0\n  //.\n  //. > S.clamp ('A') ('Z') ('~')\n  //. 'Z'\n  //. ```\n  _.clamp = {\n    consts: {a: [Z.Ord]},\n    types: [a, a, a, a],\n    impl: curry3 (Z.clamp)\n  };\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.id`][].\n  //.\n  //. ```javascript\n  //. > S.id (Function) (42)\n  //. 42\n  //. ```\n  _.id = {\n    consts: {c: [Z.Category]},\n    types: [TypeRep (c), c],\n    impl: Z.id\n  };\n\n  //# concat :: Semigroup a => a -> a -> a\n  //.\n  //. Curried version of [`Z.concat`][].\n  //.\n  //. ```javascript\n  //. > S.concat ('abc') ('def')\n  //. 'abcdef'\n  //.\n  //. > S.concat ([1, 2, 3]) ([4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > S.concat ({x: 1, y: 2}) ({y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > S.concat (S.Just ([1, 2, 3])) (S.Just ([4, 5, 6]))\n  //. Just ([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat (Sum (18)) (Sum (24))\n  //. Sum (42)\n  //. ```\n  _.concat = {\n    consts: {a: [Z.Semigroup]},\n    types: [a, a, a],\n    impl: curry2 (Z.concat)\n  };\n\n  //# empty :: Monoid a => TypeRep a -> a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.empty`][].\n  //.\n  //. ```javascript\n  //. > S.empty (String)\n  //. ''\n  //.\n  //. > S.empty (Array)\n  //. []\n  //.\n  //. > S.empty (Object)\n  //. {}\n  //.\n  //. > S.empty (Sum)\n  //. Sum (0)\n  //. ```\n  _.empty = {\n    consts: {a: [Z.Monoid]},\n    types: [TypeRep (a), a],\n    impl: Z.empty\n  };\n\n  //# invert :: Group g => g -> g\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.invert`][].\n  //.\n  //. ```javascript\n  //. > S.invert (Sum (5))\n  //. Sum (-5)\n  //. ```\n  _.invert = {\n    consts: {g: [Z.Group]},\n    types: [g, g],\n    impl: Z.invert\n  };\n\n  //# filter :: Filterable f => (a -> Boolean) -> f a -> f a\n  //.\n  //. Curried version of [`Z.filter`][]. Discards every element that does not\n  //. satisfy the predicate.\n  //.\n  //. See also [`reject`](#reject).\n  //.\n  //. ```javascript\n  //. > S.filter (S.odd) ([1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > S.filter (S.odd) ({x: 1, y: 2, z: 3})\n  //. {x: 1, z: 3}\n  //.\n  //. > S.filter (S.odd) (S.Nothing)\n  //. Nothing\n  //.\n  //. > S.filter (S.odd) (S.Just (0))\n  //. Nothing\n  //.\n  //. > S.filter (S.odd) (S.Just (1))\n  //. Just (1)\n  //. ```\n  function filter(pred) {\n    return function(filterable) {\n      return Z.filter (pred, filterable);\n    };\n  }\n  _.filter = {\n    consts: {f: [Z.Filterable]},\n    types: [$.Predicate (a), f (a), f (a)],\n    impl: filter\n  };\n\n  //# reject :: Filterable f => (a -> Boolean) -> f a -> f a\n  //.\n  //. Curried version of [`Z.reject`][]. Discards every element that satisfies\n  //. the predicate.\n  //.\n  //. See also [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > S.reject (S.odd) ([1, 2, 3])\n  //. [2]\n  //.\n  //. > S.reject (S.odd) ({x: 1, y: 2, z: 3})\n  //. {y: 2}\n  //.\n  //. > S.reject (S.odd) (S.Nothing)\n  //. Nothing\n  //.\n  //. > S.reject (S.odd) (S.Just (0))\n  //. Just (0)\n  //.\n  //. > S.reject (S.odd) (S.Just (1))\n  //. Nothing\n  //. ```\n  function reject(pred) {\n    return function(filterable) {\n      return Z.reject (pred, filterable);\n    };\n  }\n  _.reject = {\n    consts: {f: [Z.Filterable]},\n    types: [$.Predicate (a), f (a), f (a)],\n    impl: reject\n  };\n\n  //# map :: Functor f => (a -> b) -> f a -> f b\n  //.\n  //. Curried version of [`Z.map`][].\n  //.\n  //. ```javascript\n  //. > S.map (Math.sqrt) ([1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > S.map (Math.sqrt) ({x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > S.map (Math.sqrt) (S.Just (9))\n  //. Just (3)\n  //.\n  //. > S.map (Math.sqrt) (S.Right (9))\n  //. Right (3)\n  //.\n  //. > S.map (Math.sqrt) (S.Pair (99980001) (99980001))\n  //. Pair (99980001) (9999)\n  //. ```\n  //.\n  //. Replacing `Functor f => f` with `Function x` produces the B combinator\n  //. from combinatory logic (i.e. [`compose`](#compose)):\n  //.\n  //.     Functor f => (a -> b) -> f a -> f b\n  //.     (a -> b) -> Function x a -> Function x b\n  //.     (a -> c) -> Function x a -> Function x c\n  //.     (b -> c) -> Function x b -> Function x c\n  //.     (b -> c) -> Function a b -> Function a c\n  //.     (b -> c) -> (a -> b) -> (a -> c)\n  //.\n  //. ```javascript\n  //. > S.map (Math.sqrt) (S.add (1)) (99)\n  //. 10\n  //. ```\n  function map(f) {\n    return function(functor) {\n      return Z.map (f, functor);\n    };\n  }\n  _.map = {\n    consts: {f: [Z.Functor]},\n    types: [$.Fn (a) (b), f (a), f (b)],\n    impl: map\n  };\n\n  //# flip :: Functor f => f (a -> b) -> a -> f b\n  //.\n  //. Curried version of [`Z.flip`][]. Maps over the given functions, applying\n  //. each to the given value.\n  //.\n  //. Replacing `Functor f => f` with `Function x` produces the C combinator\n  //. from combinatory logic:\n  //.\n  //.     Functor f => f (a -> b) -> a -> f b\n  //.     Function x (a -> b) -> a -> Function x b\n  //.     Function x (a -> c) -> a -> Function x c\n  //.     Function x (b -> c) -> b -> Function x c\n  //.     Function a (b -> c) -> b -> Function a c\n  //.     (a -> b -> c) -> b -> a -> c\n  //.\n  //. ```javascript\n  //. > S.flip (S.concat) ('!') ('foo')\n  //. 'foo!'\n  //.\n  //. > S.flip ([Math.floor, Math.ceil]) (1.5)\n  //. [1, 2]\n  //.\n  //. > S.flip ({floor: Math.floor, ceil: Math.ceil}) (1.5)\n  //. {floor: 1, ceil: 2}\n  //.\n  //. > S.flip (Cons (Math.floor) (Cons (Math.ceil) (Nil))) (1.5)\n  //. Cons (1) (Cons (2) (Nil))\n  //. ```\n  _.flip = {\n    consts: {f: [Z.Functor]},\n    types: [f ($.Fn (a) (b)), a, f (b)],\n    impl: curry2 (Z.flip)\n  };\n\n  //# bimap :: Bifunctor f => (a -> b) -> (c -> d) -> f a c -> f b d\n  //.\n  //. Curried version of [`Z.bimap`][].\n  //.\n  //. ```javascript\n  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Pair ('foo') (64))\n  //. Pair ('FOO') (8)\n  //.\n  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Left ('foo'))\n  //. Left ('FOO')\n  //.\n  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Right (64))\n  //. Right (8)\n  //. ```\n  _.bimap = {\n    consts: {p: [Z.Bifunctor]},\n    types: [$.Fn (a) (b), $.Fn (c) (d), p (a) (c), p (b) (d)],\n    impl: curry3 (Z.bimap)\n  };\n\n  //# mapLeft :: Bifunctor f => (a -> b) -> f a c -> f b c\n  //.\n  //. Curried version of [`Z.mapLeft`][]. Maps the given function over the left\n  //. side of a Bifunctor.\n  //.\n  //. ```javascript\n  //. > S.mapLeft (S.toUpper) (S.Pair ('foo') (64))\n  //. Pair ('FOO') (64)\n  //.\n  //. > S.mapLeft (S.toUpper) (S.Left ('foo'))\n  //. Left ('FOO')\n  //.\n  //. > S.mapLeft (S.toUpper) (S.Right (64))\n  //. Right (64)\n  //. ```\n  _.mapLeft = {\n    consts: {p: [Z.Bifunctor]},\n    types: [$.Fn (a) (b), p (a) (c), p (b) (c)],\n    impl: curry2 (Z.mapLeft)\n  };\n\n  //# promap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d\n  //.\n  //. Curried version of [`Z.promap`][].\n  //.\n  //. ```javascript\n  //. > S.promap (Math.abs) (S.add (1)) (Math.sqrt) (-100)\n  //. 11\n  //. ```\n  _.promap = {\n    consts: {p: [Z.Profunctor]},\n    types: [$.Fn (a) (b), $.Fn (c) (d), p (b) (c), p (a) (d)],\n    impl: curry3 (Z.promap)\n  };\n\n  //# alt :: Alt f => f a -> f a -> f a\n  //.\n  //. Curried version of [`Z.alt`][] with arguments flipped to facilitate\n  //. partial application.\n  //.\n  //. ```javascript\n  //. > S.alt (S.Just ('default')) (S.Nothing)\n  //. Just ('default')\n  //.\n  //. > S.alt (S.Just ('default')) (S.Just ('hello'))\n  //. Just ('hello')\n  //.\n  //. > S.alt (S.Right (0)) (S.Left ('X'))\n  //. Right (0)\n  //.\n  //. > S.alt (S.Right (0)) (S.Right (1))\n  //. Right (1)\n  //. ```\n  function alt(y) {\n    return function(x) {\n      return Z.alt (x, y);\n    };\n  }\n  _.alt = {\n    consts: {f: [Z.Alt]},\n    types: [f (a), f (a), f (a)],\n    impl: alt\n  };\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.zero`][].\n  //.\n  //. ```javascript\n  //. > S.zero (Array)\n  //. []\n  //.\n  //. > S.zero (Object)\n  //. {}\n  //.\n  //. > S.zero (S.Maybe)\n  //. Nothing\n  //. ```\n  _.zero = {\n    consts: {f: [Z.Plus]},\n    types: [TypeRep (f (a)), f (a)],\n    impl: Z.zero\n  };\n\n  //# reduce :: Foldable f => (b -> a -> b) -> b -> f a -> b\n  //.\n  //. Takes a curried binary function, an initial value, and a [Foldable][],\n  //. and applies the function to the initial value and the Foldable's first\n  //. value, then applies the function to the result of the previous\n  //. application and the Foldable's second value. Repeats this process\n  //. until each of the Foldable's values has been used. Returns the initial\n  //. value if the Foldable is empty; the result of the final application\n  //. otherwise.\n  //.\n  //. ```javascript\n  //. > S.reduce (S.add) (0) ([1, 2, 3, 4, 5])\n  //. 15\n  //.\n  //. > S.reduce (xs => x => S.prepend (x) (xs)) ([]) ([1, 2, 3, 4, 5])\n  //. [5, 4, 3, 2, 1]\n  //. ```\n  function reduce(f) {\n    return function(initial) {\n      return function(foldable) {\n        return Z.reduce (function(y, x) { return f (y) (x); },\n                         initial,\n                         foldable);\n      };\n    };\n  }\n  _.reduce = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Fn (a) ($.Fn (b) (a)), a, f (b), a],\n    impl: reduce\n  };\n\n  //# traverse :: (Applicative f, Traversable t) => TypeRep f -> (a -> f b) -> t a -> f (t b)\n  //.\n  //. Curried version of [`Z.traverse`][].\n  //.\n  //. ```javascript\n  //. > S.traverse (Array) (S.words) (S.Just ('foo bar baz'))\n  //. [Just ('foo'), Just ('bar'), Just ('baz')]\n  //.\n  //. > S.traverse (Array) (S.words) (S.Nothing)\n  //. [Nothing]\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C'])\n  //. Just ([10, 11, 12])\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C', 'X'])\n  //. Nothing\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C'})\n  //. Just ({a: 10, b: 11, c: 12})\n  //.\n  //. > S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C', x: 'X'})\n  //. Nothing\n  //. ```\n  _.traverse = {\n    consts: {f: [Z.Applicative], t: [Z.Traversable]},\n    types: [TypeRep (f (b)), $.Fn (a) (f (b)), t (a), f (t (b))],\n    impl: curry3 (Z.traverse)\n  };\n\n  //# sequence :: (Applicative f, Traversable t) => TypeRep f -> t (f a) -> f (t a)\n  //.\n  //. Curried version of [`Z.sequence`][]. Inverts the given `t (f a)`\n  //. to produce an `f (t a)`.\n  //.\n  //. ```javascript\n  //. > S.sequence (Array) (S.Just ([1, 2, 3]))\n  //. [Just (1), Just (2), Just (3)]\n  //.\n  //. > S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Just (3)])\n  //. Just ([1, 2, 3])\n  //.\n  //. > S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Nothing])\n  //. Nothing\n  //.\n  //. > S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Just (3)})\n  //. Just ({a: 1, b: 2, c: 3})\n  //.\n  //. > S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Nothing})\n  //. Nothing\n  //. ```\n  _.sequence = {\n    consts: {f: [Z.Applicative], t: [Z.Traversable]},\n    types: [TypeRep (f (a)), t (f (a)), f (t (a))],\n    impl: curry2 (Z.sequence)\n  };\n\n  //# ap :: Apply f => f (a -> b) -> f a -> f b\n  //.\n  //. Curried version of [`Z.ap`][].\n  //.\n  //. ```javascript\n  //. > S.ap ([Math.sqrt, x => x * x]) ([1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > S.ap ({x: Math.sqrt, y: S.add (1), z: S.sub (1)}) ({w: 4, x: 4, y: 4})\n  //. {x: 2, y: 5}\n  //.\n  //. > S.ap (S.Just (Math.sqrt)) (S.Just (64))\n  //. Just (8)\n  //. ```\n  //.\n  //. Replacing `Apply f => f` with `Function x` produces the S combinator\n  //. from combinatory logic:\n  //.\n  //.     Apply f => f (a -> b) -> f a -> f b\n  //.     Function x (a -> b) -> Function x a -> Function x b\n  //.     Function x (a -> c) -> Function x a -> Function x c\n  //.     Function x (b -> c) -> Function x b -> Function x c\n  //.     Function a (b -> c) -> Function a b -> Function a c\n  //.     (a -> b -> c) -> (a -> b) -> (a -> c)\n  //.\n  //. ```javascript\n  //. > S.ap (s => n => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('Haskell')\n  //. 'Hask'\n  //. ```\n  _.ap = {\n    consts: {f: [Z.Apply]},\n    types: [f ($.Fn (a) (b)), f (a), f (b)],\n    impl: curry2 (Z.ap)\n  };\n\n  //# lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c\n  //.\n  //. Promotes a curried binary function to a function that operates on two\n  //. [Apply][]s.\n  //.\n  //. ```javascript\n  //. > S.lift2 (S.add) (S.Just (2)) (S.Just (3))\n  //. Just (5)\n  //.\n  //. > S.lift2 (S.add) (S.Just (2)) (S.Nothing)\n  //. Nothing\n  //.\n  //. > S.lift2 (S.and) (S.Just (true)) (S.Just (true))\n  //. Just (true)\n  //.\n  //. > S.lift2 (S.and) (S.Just (true)) (S.Just (false))\n  //. Just (false)\n  //. ```\n  _.lift2 = {\n    consts: {f: [Z.Apply]},\n    types: [$.Fn (a) ($.Fn (b) (c)), f (a), f (b), f (c)],\n    impl: curry3 (Z.lift2)\n  };\n\n  //# lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n  //.\n  //. Promotes a curried ternary function to a function that operates on three\n  //. [Apply][]s.\n  //.\n  //. ```javascript\n  //. > S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Just ([1, 2, 3]))\n  //. Just (6)\n  //.\n  //. > S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Nothing)\n  //. Nothing\n  //. ```\n  _.lift3 = {\n    consts: {f: [Z.Apply]},\n    types: [$.Fn (a) ($.Fn (b) ($.Fn (c) (d))), f (a), f (b), f (c), f (d)],\n    impl: curry4 (Z.lift3)\n  };\n\n  //# apFirst :: Apply f => f a -> f b -> f a\n  //.\n  //. Curried version of [`Z.apFirst`][]. Combines two effectful actions,\n  //. keeping only the result of the first. Equivalent to Haskell's `(<*)`\n  //. function.\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > S.apFirst ([1, 2]) ([3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > S.apFirst (S.Just (1)) (S.Just (2))\n  //. Just (1)\n  //. ```\n  _.apFirst = {\n    consts: {f: [Z.Apply]},\n    types: [f (a), f (b), f (a)],\n    impl: curry2 (Z.apFirst)\n  };\n\n  //# apSecond :: Apply f => f a -> f b -> f b\n  //.\n  //. Curried version of [`Z.apSecond`][]. Combines two effectful actions,\n  //. keeping only the result of the second. Equivalent to Haskell's `(*>)`\n  //. function.\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > S.apSecond ([1, 2]) ([3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > S.apSecond (S.Just (1)) (S.Just (2))\n  //. Just (2)\n  //. ```\n  _.apSecond = {\n    consts: {f: [Z.Apply]},\n    types: [f (a), f (b), f (b)],\n    impl: curry2 (Z.apSecond)\n  };\n\n  //# of :: Applicative f => TypeRep f -> a -> f a\n  //.\n  //. Curried version of [`Z.of`][].\n  //.\n  //. ```javascript\n  //. > S.of (Array) (42)\n  //. [42]\n  //.\n  //. > S.of (Function) (42) (null)\n  //. 42\n  //.\n  //. > S.of (S.Maybe) (42)\n  //. Just (42)\n  //.\n  //. > S.of (S.Either) (42)\n  //. Right (42)\n  //. ```\n  function of(typeRep) {\n    return function(x) {\n      return Z.of (typeRep, x);\n    };\n  }\n  _.of = {\n    consts: {f: [Z.Applicative]},\n    types: [TypeRep (f (a)), a, f (a)],\n    impl: of\n  };\n\n  //# chain :: Chain m => (a -> m b) -> m a -> m b\n  //.\n  //. Curried version of [`Z.chain`][].\n  //.\n  //. ```javascript\n  //. > S.chain (x => [x, x]) ([1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > S.chain (n => s => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('slice')\n  //. 'sli'\n  //.\n  //. > S.chain (S.parseInt (10)) (S.Just ('123'))\n  //. Just (123)\n  //.\n  //. > S.chain (S.parseInt (10)) (S.Just ('XXX'))\n  //. Nothing\n  //. ```\n  _.chain = {\n    consts: {m: [Z.Chain]},\n    types: [$.Fn (a) (m (b)), m (a), m (b)],\n    impl: curry2 (Z.chain)\n  };\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.join`][].\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. ```javascript\n  //. > S.join ([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > S.join ([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > S.join (S.Just (S.Just (1)))\n  //. Just (1)\n  //.\n  //. > S.join (S.Pair ('foo') (S.Pair ('bar') ('baz')))\n  //. Pair ('foobar') ('baz')\n  //. ```\n  //.\n  //. Replacing `Chain m => m` with `Function x` produces the W combinator\n  //. from combinatory logic:\n  //.\n  //.     Chain m => m (m a) -> m a\n  //.     Function x (Function x a) -> Function x a\n  //.     (x -> x -> a) -> (x -> a)\n  //.\n  //. ```javascript\n  //. > S.join (S.concat) ('abc')\n  //. 'abcabc'\n  //. ```\n  _.join = {\n    consts: {m: [Z.Chain]},\n    types: [m (m (a)), m (a)],\n    impl: Z.join\n  };\n\n  //# chainRec :: ChainRec m => TypeRep m -> (a -> m (Either a b)) -> a -> m b\n  //.\n  //. Performs a [`chain`](#chain)-like computation with constant stack usage.\n  //. Similar to [`Z.chainRec`][], but curried and more convenient due to the\n  //. use of the Either type to indicate completion (via a Right).\n  //.\n  //. ```javascript\n  //. > S.chainRec (Array)\n  //. .            (s => s.length === 2 ? S.map (S.Right) ([s + '!', s + '?'])\n  //. .                                 : S.map (S.Left) ([s + 'o', s + 'n']))\n  //. .            ('')\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  function chainRec(typeRep) {\n    return function(f) {\n      return function(x) {\n        return Z.chainRec (typeRep, step, x);\n      };\n      function step(next, done, x) {\n        return Z.map (either (next) (done), f (x));\n      }\n    };\n  }\n  _.chainRec = {\n    consts: {m: [Z.ChainRec]},\n    types: [TypeRep (m (b)), $.Fn (a) (m ($.Either (a) (b))), a, m (b)],\n    impl: chainRec\n  };\n\n  //# extend :: Extend w => (w a -> b) -> w a -> w b\n  //.\n  //. Curried version of [`Z.extend`][].\n  //.\n  //. ```javascript\n  //. > S.extend (S.joinWith ('')) (['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //.\n  //. > S.extend (f => f ([3, 4])) (S.reverse) ([1, 2])\n  //. [4, 3, 2, 1]\n  //. ```\n  _.extend = {\n    consts: {w: [Z.Extend]},\n    types: [$.Fn (w (a)) (b), w (a), w (b)],\n    impl: curry2 (Z.extend)\n  };\n\n  //# duplicate :: Extend w => w a -> w (w a)\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.duplicate`][].\n  //. Adds one level of nesting to a comonadic structure.\n  //.\n  //. ```javascript\n  //. > S.duplicate (S.Just (1))\n  //. Just (Just (1))\n  //.\n  //. > S.duplicate ([1])\n  //. [[1]]\n  //.\n  //. > S.duplicate ([1, 2, 3])\n  //. [[1, 2, 3], [2, 3], [3]]\n  //.\n  //. > S.duplicate (S.reverse) ([1, 2]) ([3, 4])\n  //. [4, 3, 2, 1]\n  //. ```\n  _.duplicate = {\n    consts: {w: [Z.Extend]},\n    types: [w (a), w (w (a))],\n    impl: Z.duplicate\n  };\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.extract`][].\n  //.\n  //. ```javascript\n  //. > S.extract (S.Pair ('foo') ('bar'))\n  //. 'bar'\n  //. ```\n  _.extract = {\n    consts: {w: [Z.Comonad]},\n    types: [w (a), a],\n    impl: Z.extract\n  };\n\n  //# contramap :: Contravariant f => (b -> a) -> f a -> f b\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.contramap`][].\n  //.\n  //. ```javascript\n  //. > S.contramap (s => s.length) (Math.sqrt) ('Sanctuary')\n  //. 3\n  //. ```\n  _.contramap = {\n    consts: {f: [Z.Contravariant]},\n    types: [$.Fn (b) (a), f (a), f (b)],\n    impl: curry2 (Z.contramap)\n  };\n\n  //. ### Combinator\n\n  //# I :: a -> a\n  //.\n  //. The I combinator. Returns its argument. Equivalent to Haskell's `id`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.I ('foo')\n  //. 'foo'\n  //. ```\n  function I(x) {\n    return x;\n  }\n  _.I = {\n    consts: {},\n    types: [a, a],\n    impl: I\n  };\n\n  //# K :: a -> b -> a\n  //.\n  //. The K combinator. Takes two values and returns the first. Equivalent to\n  //. Haskell's `const` function.\n  //.\n  //. ```javascript\n  //. > S.K ('foo') ('bar')\n  //. 'foo'\n  //.\n  //. > S.map (S.K (42)) (S.range (0) (5))\n  //. [42, 42, 42, 42, 42]\n  //. ```\n  function K(x) {\n    return function(y) {\n      return x;\n    };\n  }\n  _.K = {\n    consts: {},\n    types: [a, b, a],\n    impl: K\n  };\n\n  //# T :: a -> (a -> b) -> b\n  //.\n  //. The T ([thrush][]) combinator. Takes a value and a function, and returns\n  //. the result of applying the function to the value. Equivalent to Haskell's\n  //. `(&)` function.\n  //.\n  //. ```javascript\n  //. > S.T (42) (S.add (1))\n  //. 43\n  //.\n  //. > S.map (S.T (100)) ([S.add (1), Math.sqrt])\n  //. [101, 10]\n  //. ```\n  function T(x) {\n    return function(f) {\n      return f (x);\n    };\n  }\n  _.T = {\n    consts: {},\n    types: [a, $.Fn (a) (b), b],\n    impl: T\n  };\n\n  //. ### Function\n\n  //# curry2 :: ((a, b) -> c) -> a -> b -> c\n  //.\n  //. Curries the given binary function.\n  //.\n  //. ```javascript\n  //. > S.map (S.curry2 (Math.pow) (10)) ([1, 2, 3])\n  //. [10, 100, 1000]\n  //. ```\n  function curry2(f) {\n    return function(x) {\n      return function(y) {\n        return f (x, y);\n      };\n    };\n  }\n  _.curry2 = {\n    consts: {},\n    types: [$.Function ([a, b, c]), a, b, c],\n    impl: curry2\n  };\n\n  //# curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d\n  //.\n  //. Curries the given ternary function.\n  //.\n  //. ```javascript\n  //. > const replaceString = S.curry3 ((what, replacement, string) =>\n  //. .   string.replace (what, replacement)\n  //. . )\n  //.\n  //. > replaceString ('banana') ('orange') ('banana icecream')\n  //. 'orange icecream'\n  //. ```\n  function curry3(f) {\n    return function(x) {\n      return function(y) {\n        return function(z) {\n          return f (x, y, z);\n        };\n      };\n    };\n  }\n  _.curry3 = {\n    consts: {},\n    types: [$.Function ([a, b, c, d]), a, b, c, d],\n    impl: curry3\n  };\n\n  //# curry4 :: ((a, b, c, d) -> e) -> a -> b -> c -> d -> e\n  //.\n  //. Curries the given quaternary function.\n  //.\n  //. ```javascript\n  //. > const createRect = S.curry4 ((x, y, width, height) =>\n  //. .   ({x, y, width, height})\n  //. . )\n  //.\n  //. > createRect (0) (0) (10) (10)\n  //. {x: 0, y: 0, width: 10, height: 10}\n  //. ```\n  function curry4(f) {\n    return function(w) {\n      return function(x) {\n        return function(y) {\n          return function(z) {\n            return f (w, x, y, z);\n          };\n        };\n      };\n    };\n  }\n  _.curry4 = {\n    consts: {},\n    types: [$.Function ([a, b, c, d, e]), a, b, c, d, e],\n    impl: curry4\n  };\n\n  //# curry5 :: ((a, b, c, d, e) -> f) -> a -> b -> c -> d -> e -> f\n  //.\n  //. Curries the given quinary function.\n  //.\n  //. ```javascript\n  //. > const toUrl = S.curry5 ((protocol, creds, hostname, port, pathname) =>\n  //. .   protocol + '//' +\n  //. .   S.maybe ('') (S.flip (S.concat) ('@')) (creds) +\n  //. .   hostname +\n  //. .   S.maybe ('') (S.concat (':')) (port) +\n  //. .   pathname\n  //. . )\n  //.\n  //. > toUrl ('https:') (S.Nothing) ('example.com') (S.Just ('443')) ('/foo/bar')\n  //. 'https://example.com:443/foo/bar'\n  //. ```\n  function curry5(f) {\n    return function(v) {\n      return function(w) {\n        return function(x) {\n          return function(y) {\n            return function(z) {\n              return f (v, w, x, y, z);\n            };\n          };\n        };\n      };\n    };\n  }\n  _.curry5 = {\n    consts: {},\n    types: [$.Function ([a, b, c, d, e, r]), a, b, c, d, e, r],\n    impl: curry5\n  };\n\n  //. ### Composition\n\n  //# compose :: Semigroupoid s => s b c -> s a b -> s a c\n  //.\n  //. Curried version of [`Z.compose`][].\n  //.\n  //. When specialized to Function, `compose` composes two unary functions,\n  //. from right to left (this is the B combinator from combinatory logic).\n  //.\n  //. The generalized type signature indicates that `compose` is compatible\n  //. with any [Semigroupoid][].\n  //.\n  //. See also [`pipe`](#pipe).\n  //.\n  //. ```javascript\n  //. > S.compose (Math.sqrt) (S.add (1)) (99)\n  //. 10\n  //. ```\n  _.compose = {\n    consts: {s: [Z.Semigroupoid]},\n    types: [s (b) (c), s (a) (b), s (a) (c)],\n    impl: curry2 (Z.compose)\n  };\n\n  //# pipe :: Foldable f => f (Any -> Any) -> a -> b\n  //.\n  //. Takes a sequence of functions assumed to be unary and a value of any\n  //. type, and returns the result of applying the sequence of transformations\n  //. to the initial value.\n  //.\n  //. In general terms, `pipe` performs left-to-right composition of a sequence\n  //. of functions. `pipe ([f, g, h]) (x)` is equivalent to `h (g (f (x)))`.\n  //.\n  //. ```javascript\n  //. > S.pipe ([S.add (1), Math.sqrt, S.sub (1)]) (99)\n  //. 9\n  //. ```\n  function pipe(fs) {\n    return function(x) {\n      return reduce (T) (x) (fs);\n    };\n  }\n  _.pipe = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.Fn ($.Any) ($.Any)), a, b],\n    impl: pipe\n  };\n\n  //# pipeK :: (Foldable f, Chain m) => f (Any -> m Any) -> m a -> m b\n  //.\n  //. Takes a sequence of functions assumed to be unary that return values\n  //. with a [Chain][], and a value of that Chain, and returns the result\n  //. of applying the sequence of transformations to the initial value.\n  //.\n  //. In general terms, `pipeK` performs left-to-right [Kleisli][] composition\n  //. of an sequence of functions. `pipeK ([f, g, h]) (x)` is equivalent to\n  //. `chain (h) (chain (g) (chain (f) (x)))`.\n  //.\n  //. ```javascript\n  //. > S.pipeK ([S.tail, S.tail, S.head]) (S.Just ([1, 2, 3, 4]))\n  //. Just (3)\n  //. ```\n  function pipeK(fs) {\n    return function(x) {\n      return Z.reduce (function(x, f) { return Z.chain (f, x); }, x, fs);\n    };\n  }\n  _.pipeK = {\n    consts: {f: [Z.Foldable], m: [Z.Chain]},\n    types: [f ($.Fn ($.Any) (m ($.Any))), m (a), m (b)],\n    impl: pipeK\n  };\n\n  //# on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\n  //.\n  //. Takes a binary function `f`, a unary function `g`, and two\n  //. values `x` and `y`. Returns `f (g (x)) (g (y))`.\n  //.\n  //. This is the P combinator from combinatory logic.\n  //.\n  //. ```javascript\n  //. > S.on (S.concat) (S.reverse) ([1, 2, 3]) ([4, 5, 6])\n  //. [3, 2, 1, 6, 5, 4]\n  //. ```\n  function on(f) {\n    return function(g) {\n      return function(x) {\n        return function(y) {\n          return f (g (x)) (g (y));\n        };\n      };\n    };\n  }\n  _.on = {\n    consts: {},\n    types: [$.Fn (b) ($.Fn (b) (c)), $.Fn (a) (b), a, a, c],\n    impl: on\n  };\n\n  //. ### Pair type\n  //.\n  //. Pair is the canonical product type: a value of type `Pair a b` always\n  //. contains exactly two values: one of type `a`; one of type `b`.\n  //.\n  //. The implementation is provided by [sanctuary-pair][].\n\n  //# Pair :: a -> b -> Pair a b\n  //.\n  //. Pair's sole data constructor. Additionally, it serves as the\n  //. Pair [type representative][].\n  //.\n  //. ```javascript\n  //. > S.Pair ('foo') (42)\n  //. Pair ('foo') (42)\n  //. ```\n  _.Pair = {\n    consts: {},\n    types: [a, b, $.Pair (a) (b)],\n    impl: Pair\n  };\n\n  //# pair :: (a -> b -> c) -> Pair a b -> c\n  //.\n  //. Case analysis for the `Pair a b` type.\n  //.\n  //. ```javascript\n  //. > S.pair (S.concat) (S.Pair ('foo') ('bar'))\n  //. 'foobar'\n  //. ```\n  function pair(f) {\n    return function(pair) {\n      return f (pair.fst) (pair.snd);\n    };\n  }\n  _.pair = {\n    consts: {},\n    types: [$.Fn (a) ($.Fn (b) (c)), $.Pair (a) (b), c],\n    impl: pair\n  };\n\n  //# fst :: Pair a b -> a\n  //.\n  //. `fst (Pair (x) (y))` is equivalent to `x`.\n  //.\n  //. ```javascript\n  //. > S.fst (S.Pair ('foo') (42))\n  //. 'foo'\n  //. ```\n  _.fst = {\n    consts: {},\n    types: [$.Pair (a) (b), a],\n    impl: pair (K)\n  };\n\n  //# snd :: Pair a b -> b\n  //.\n  //. `snd (Pair (x) (y))` is equivalent to `y`.\n  //.\n  //. ```javascript\n  //. > S.snd (S.Pair ('foo') (42))\n  //. 42\n  //. ```\n  _.snd = {\n    consts: {},\n    types: [$.Pair (a) (b), b],\n    impl: pair (C (K))\n  };\n\n  //# swap :: Pair a b -> Pair b a\n  //.\n  //. `swap (Pair (x) (y))` is equivalent to `Pair (y) (x)`.\n  //.\n  //. ```javascript\n  //. > S.swap (S.Pair ('foo') (42))\n  //. Pair (42) ('foo')\n  //. ```\n  _.swap = {\n    consts: {},\n    types: [$.Pair (a) (b), $.Pair (b) (a)],\n    impl: pair (C (Pair))\n  };\n\n  //. ### Maybe type\n  //.\n  //. The Maybe type represents optional values: a value of type `Maybe a` is\n  //. either Nothing (the empty value) or a Just whose value is of type `a`.\n  //.\n  //. The implementation is provided by [sanctuary-maybe][].\n\n  //# Maybe :: TypeRep Maybe\n  //.\n  //. Maybe [type representative][].\n\n  //# Nothing :: Maybe a\n  //.\n  //. The empty value of type `Maybe a`.\n  //.\n  //. ```javascript\n  //. > S.Nothing\n  //. Nothing\n  //. ```\n\n  //# Just :: a -> Maybe a\n  //.\n  //. Constructs a value of type `Maybe a` from a value of type `a`.\n  //.\n  //. ```javascript\n  //. > S.Just (42)\n  //. Just (42)\n  //. ```\n  _.Just = {\n    consts: {},\n    types: [a, $.Maybe (a)],\n    impl: Just\n  };\n\n  //# isNothing :: Maybe a -> Boolean\n  //.\n  //. Returns `true` if the given Maybe is Nothing; `false` if it is a Just.\n  //.\n  //. ```javascript\n  //. > S.isNothing (S.Nothing)\n  //. true\n  //.\n  //. > S.isNothing (S.Just (42))\n  //. false\n  //. ```\n  function isNothing(maybe) {\n    return maybe.isNothing;\n  }\n  _.isNothing = {\n    consts: {},\n    types: [$.Maybe (a), $.Boolean],\n    impl: isNothing\n  };\n\n  //# isJust :: Maybe a -> Boolean\n  //.\n  //. Returns `true` if the given Maybe is a Just; `false` if it is Nothing.\n  //.\n  //. ```javascript\n  //. > S.isJust (S.Just (42))\n  //. true\n  //.\n  //. > S.isJust (S.Nothing)\n  //. false\n  //. ```\n  function isJust(maybe) {\n    return maybe.isJust;\n  }\n  _.isJust = {\n    consts: {},\n    types: [$.Maybe (a), $.Boolean],\n    impl: isJust\n  };\n\n  //# fromMaybe :: a -> Maybe a -> a\n  //.\n  //. Takes a default value and a Maybe, and returns the Maybe's value\n  //. if the Maybe is a Just; the default value otherwise.\n  //.\n  //. See also [`fromMaybe_`](#fromMaybe_) and\n  //. [`maybeToNullable`](#maybeToNullable).\n  //.\n  //. ```javascript\n  //. > S.fromMaybe (0) (S.Just (42))\n  //. 42\n  //.\n  //. > S.fromMaybe (0) (S.Nothing)\n  //. 0\n  //. ```\n  _.fromMaybe = {\n    consts: {},\n    types: [a, $.Maybe (a), a],\n    impl: C (maybe) (I)\n  };\n\n  //# fromMaybe_ :: (() -> a) -> Maybe a -> a\n  //.\n  //. Variant of [`fromMaybe`](#fromMaybe) that takes a thunk so the default\n  //. value is only computed if required.\n  //.\n  //. ```javascript\n  //. > function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }\n  //.\n  //. > S.fromMaybe_ (() => fib (30)) (S.Just (1000000))\n  //. 1000000\n  //.\n  //. > S.fromMaybe_ (() => fib (30)) (S.Nothing)\n  //. 832040\n  //. ```\n  _.fromMaybe_ = {\n    consts: {},\n    types: [$.Thunk (a), $.Maybe (a), a],\n    impl: C (maybe_) (I)\n  };\n\n  //# maybeToNullable :: Maybe a -> Nullable a\n  //.\n  //. Returns the given Maybe's value if the Maybe is a Just; `null` otherwise.\n  //. [Nullable][] is defined in [sanctuary-def][].\n  //.\n  //. See also [`fromMaybe`](#fromMaybe).\n  //.\n  //. ```javascript\n  //. > S.maybeToNullable (S.Just (42))\n  //. 42\n  //.\n  //. > S.maybeToNullable (S.Nothing)\n  //. null\n  //. ```\n  function maybeToNullable(maybe) {\n    return maybe.isJust ? maybe.value : null;\n  }\n  _.maybeToNullable = {\n    consts: {},\n    types: [$.Maybe (a), $.Nullable (a)],\n    impl: maybeToNullable\n  };\n\n  //# maybe :: b -> (a -> b) -> Maybe a -> b\n  //.\n  //. Takes a value of any type, a function, and a Maybe. If the Maybe is\n  //. a Just, the return value is the result of applying the function to\n  //. the Just's value. Otherwise, the first argument is returned.\n  //.\n  //. See also [`maybe_`](#maybe_).\n  //.\n  //. ```javascript\n  //. > S.maybe (0) (S.prop ('length')) (S.Just ('refuge'))\n  //. 6\n  //.\n  //. > S.maybe (0) (S.prop ('length')) (S.Nothing)\n  //. 0\n  //. ```\n  function maybe(x) {\n    return function(f) {\n      return function(maybe) {\n        return maybe.isJust ? f (maybe.value) : x;\n      };\n    };\n  }\n  _.maybe = {\n    consts: {},\n    types: [b, $.Fn (a) (b), $.Maybe (a), b],\n    impl: maybe\n  };\n\n  //# maybe_ :: (() -> b) -> (a -> b) -> Maybe a -> b\n  //.\n  //. Variant of [`maybe`](#maybe) that takes a thunk so the default value\n  //. is only computed if required.\n  //.\n  //. ```javascript\n  //. > function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }\n  //.\n  //. > S.maybe_ (() => fib (30)) (Math.sqrt) (S.Just (1000000))\n  //. 1000\n  //.\n  //. > S.maybe_ (() => fib (30)) (Math.sqrt) (S.Nothing)\n  //. 832040\n  //. ```\n  function maybe_(thunk) {\n    return function(f) {\n      return function(maybe) {\n        return maybe.isJust ? f (maybe.value) : thunk ();\n      };\n    };\n  }\n  _.maybe_ = {\n    consts: {},\n    types: [$.Thunk (b), $.Fn (a) (b), $.Maybe (a), b],\n    impl: maybe_\n  };\n\n  //# justs :: (Filterable f, Functor f) => f (Maybe a) -> f a\n  //.\n  //. Discards each element that is Nothing, and unwraps each element that is\n  //. a Just. Related to Haskell's `catMaybes` function.\n  //.\n  //. See also [`lefts`](#lefts) and [`rights`](#rights).\n  //.\n  //. ```javascript\n  //. > S.justs ([S.Just ('foo'), S.Nothing, S.Just ('baz')])\n  //. ['foo', 'baz']\n  //. ```\n  function justs(maybes) {\n    return map (prop ('value')) (filter (isJust) (maybes));\n  }\n  _.justs = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [f ($.Maybe (a)), f (a)],\n    impl: justs\n  };\n\n  //# mapMaybe :: (Filterable f, Functor f) => (a -> Maybe b) -> f a -> f b\n  //.\n  //. Takes a function and a structure, applies the function to each element\n  //. of the structure, and returns the \"successful\" results. If the result of\n  //. applying the function to an element is Nothing, the result is discarded;\n  //. if the result is a Just, the Just's value is included.\n  //.\n  //. ```javascript\n  //. > S.mapMaybe (S.head) ([[], [1, 2, 3], [], [4, 5, 6], []])\n  //. [1, 4]\n  //.\n  //. > S.mapMaybe (S.head) ({x: [1, 2, 3], y: [], z: [4, 5, 6]})\n  //. {x: 1, z: 4}\n  //. ```\n  _.mapMaybe = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [$.Fn (a) ($.Maybe (b)), f (a), f (b)],\n    impl: B (B (justs)) (map)\n  };\n\n  //# maybeToEither :: a -> Maybe b -> Either a b\n  //.\n  //. Converts a Maybe to an Either. Nothing becomes a Left (containing the\n  //. first argument); a Just becomes a Right.\n  //.\n  //. See also [`eitherToMaybe`](#eitherToMaybe).\n  //.\n  //. ```javascript\n  //. > S.maybeToEither ('Expecting an integer') (S.parseInt (10) ('xyz'))\n  //. Left ('Expecting an integer')\n  //.\n  //. > S.maybeToEither ('Expecting an integer') (S.parseInt (10) ('42'))\n  //. Right (42)\n  //. ```\n  function maybeToEither(x) {\n    return maybe (Left (x)) (Right);\n  }\n  _.maybeToEither = {\n    consts: {},\n    types: [a, $.Maybe (b), $.Either (a) (b)],\n    impl: maybeToEither\n  };\n\n  //. ### Either type\n  //.\n  //. The Either type represents values with two possibilities: a value of type\n  //. `Either a b` is either a Left whose value is of type `a` or a Right whose\n  //. value is of type `b`.\n  //.\n  //. The implementation is provided by [sanctuary-either][].\n\n  //# Either :: TypeRep Either\n  //.\n  //. Either [type representative][].\n\n  //# Left :: a -> Either a b\n  //.\n  //. Constructs a value of type `Either a b` from a value of type `a`.\n  //.\n  //. ```javascript\n  //. > S.Left ('Cannot divide by zero')\n  //. Left ('Cannot divide by zero')\n  //. ```\n  _.Left = {\n    consts: {},\n    types: [a, $.Either (a) (b)],\n    impl: Left\n  };\n\n  //# Right :: b -> Either a b\n  //.\n  //. Constructs a value of type `Either a b` from a value of type `b`.\n  //.\n  //. ```javascript\n  //. > S.Right (42)\n  //. Right (42)\n  //. ```\n  _.Right = {\n    consts: {},\n    types: [b, $.Either (a) (b)],\n    impl: Right\n  };\n\n  //# isLeft :: Either a b -> Boolean\n  //.\n  //. Returns `true` if the given Either is a Left; `false` if it is a Right.\n  //.\n  //. ```javascript\n  //. > S.isLeft (S.Left ('Cannot divide by zero'))\n  //. true\n  //.\n  //. > S.isLeft (S.Right (42))\n  //. false\n  //. ```\n  function isLeft(either) {\n    return either.isLeft;\n  }\n  _.isLeft = {\n    consts: {},\n    types: [$.Either (a) (b), $.Boolean],\n    impl: isLeft\n  };\n\n  //# isRight :: Either a b -> Boolean\n  //.\n  //. Returns `true` if the given Either is a Right; `false` if it is a Left.\n  //.\n  //. ```javascript\n  //. > S.isRight (S.Right (42))\n  //. true\n  //.\n  //. > S.isRight (S.Left ('Cannot divide by zero'))\n  //. false\n  //. ```\n  function isRight(either) {\n    return either.isRight;\n  }\n  _.isRight = {\n    consts: {},\n    types: [$.Either (a) (b), $.Boolean],\n    impl: isRight\n  };\n\n  //# fromEither :: b -> Either a b -> b\n  //.\n  //. Takes a default value and an Either, and returns the Right value\n  //. if the Either is a Right; the default value otherwise.\n  //.\n  //. ```javascript\n  //. > S.fromEither (0) (S.Right (42))\n  //. 42\n  //.\n  //. > S.fromEither (0) (S.Left (42))\n  //. 0\n  //. ```\n  function fromEither(x) {\n    return either (K (x)) (I);\n  }\n  _.fromEither = {\n    consts: {},\n    types: [b, $.Either (a) (b), b],\n    impl: fromEither\n  };\n\n  //# either :: (a -> c) -> (b -> c) -> Either a b -> c\n  //.\n  //. Takes two functions and an Either, and returns the result of\n  //. applying the first function to the Left's value, if the Either\n  //. is a Left, or the result of applying the second function to the\n  //. Right's value, if the Either is a Right.\n  //.\n  //. ```javascript\n  //. > S.either (S.toUpper) (S.show) (S.Left ('Cannot divide by zero'))\n  //. 'CANNOT DIVIDE BY ZERO'\n  //.\n  //. > S.either (S.toUpper) (S.show) (S.Right (42))\n  //. '42'\n  //. ```\n  function either(l) {\n    return function(r) {\n      return function(either) {\n        return (either.isLeft ? l : r) (either.value);\n      };\n    };\n  }\n  _.either = {\n    consts: {},\n    types: [$.Fn (a) (c), $.Fn (b) (c), $.Either (a) (b), c],\n    impl: either\n  };\n\n  //# lefts :: (Filterable f, Functor f) => f (Either a b) -> f a\n  //.\n  //. Discards each element that is a Right, and unwraps each element that is\n  //. a Left.\n  //.\n  //. See also [`rights`](#rights).\n  //.\n  //. ```javascript\n  //. > S.lefts ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])\n  //. ['foo', 'bar']\n  //. ```\n  _.lefts = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [f ($.Either (a) (b)), f (a)],\n    impl: B (map (prop ('value'))) (filter (isLeft))\n  };\n\n  //# rights :: (Filterable f, Functor f) => f (Either a b) -> f b\n  //.\n  //. Discards each element that is a Left, and unwraps each element that is\n  //. a Right.\n  //.\n  //. See also [`lefts`](#lefts).\n  //.\n  //. ```javascript\n  //. > S.rights ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])\n  //. [20, 10]\n  //. ```\n  _.rights = {\n    consts: {f: [Z.Filterable, Z.Functor]},\n    types: [f ($.Either (a) (b)), f (b)],\n    impl: B (map (prop ('value'))) (filter (isRight))\n  };\n\n  //# tagBy :: (a -> Boolean) -> a -> Either a a\n  //.\n  //. Takes a predicate and a value, and returns a Right of the value if it\n  //. satisfies the predicate; a Left of the value otherwise.\n  //.\n  //. ```javascript\n  //. > S.tagBy (S.odd) (0)\n  //. Left (0)\n  //\n  //. > S.tagBy (S.odd) (1)\n  //. Right (1)\n  //. ```\n  function tagBy(pred) {\n    return ifElse (pred) (Right) (Left);\n  }\n  _.tagBy = {\n    consts: {},\n    types: [$.Predicate (a), a, $.Either (a) (a)],\n    impl: tagBy\n  };\n\n  //# encase :: (a -> b) -> a -> Either Error b\n  //.\n  //. Takes a function that may throw and returns a pure function.\n  //.\n  //. ```javascript\n  //. > S.encase (JSON.parse) ('[\"foo\",\"bar\",\"baz\"]')\n  //. Right (['foo', 'bar', 'baz'])\n  //.\n  //. > S.encase (JSON.parse) ('[')\n  //. Left (new SyntaxError ('Unexpected end of JSON input'))\n  //. ```\n  function encase(f) {\n    return function(x) {\n      try {\n        return Right (f (x));\n      } catch (err) {\n        return Left (err);\n      }\n    };\n  }\n  _.encase = {\n    consts: {},\n    types: [$.Fn (a) (b), a, $.Either ($.Error) (b)],\n    impl: encase\n  };\n\n  //# eitherToMaybe :: Either a b -> Maybe b\n  //.\n  //. Converts an Either to a Maybe. A Left becomes Nothing; a Right becomes\n  //. a Just.\n  //.\n  //. See also [`maybeToEither`](#maybeToEither).\n  //.\n  //. ```javascript\n  //. > S.eitherToMaybe (S.Left ('Cannot divide by zero'))\n  //. Nothing\n  //.\n  //. > S.eitherToMaybe (S.Right (42))\n  //. Just (42)\n  //. ```\n  function eitherToMaybe(either) {\n    return either.isLeft ? Nothing : Just (either.value);\n  }\n  _.eitherToMaybe = {\n    consts: {},\n    types: [$.Either (a) (b), $.Maybe (b)],\n    impl: eitherToMaybe\n  };\n\n  //. ### Logic\n\n  //# and :: Boolean -> Boolean -> Boolean\n  //.\n  //. Boolean \"and\".\n  //.\n  //. ```javascript\n  //. > S.and (false) (false)\n  //. false\n  //.\n  //. > S.and (false) (true)\n  //. false\n  //.\n  //. > S.and (true) (false)\n  //. false\n  //.\n  //. > S.and (true) (true)\n  //. true\n  //. ```\n  function and(x) {\n    return function(y) {\n      return x && y;\n    };\n  }\n  _.and = {\n    consts: {},\n    types: [$.Boolean, $.Boolean, $.Boolean],\n    impl: and\n  };\n\n  //# or :: Boolean -> Boolean -> Boolean\n  //.\n  //. Boolean \"or\".\n  //.\n  //. ```javascript\n  //. > S.or (false) (false)\n  //. false\n  //.\n  //. > S.or (false) (true)\n  //. true\n  //.\n  //. > S.or (true) (false)\n  //. true\n  //.\n  //. > S.or (true) (true)\n  //. true\n  //. ```\n  function or(x) {\n    return function(y) {\n      return x || y;\n    };\n  }\n  _.or = {\n    consts: {},\n    types: [$.Boolean, $.Boolean, $.Boolean],\n    impl: or\n  };\n\n  //# not :: Boolean -> Boolean\n  //.\n  //. Boolean \"not\".\n  //.\n  //. See also [`complement`](#complement).\n  //.\n  //. ```javascript\n  //. > S.not (false)\n  //. true\n  //.\n  //. > S.not (true)\n  //. false\n  //. ```\n  function not(x) {\n    return !x;\n  }\n  _.not = {\n    consts: {},\n    types: [$.Boolean, $.Boolean],\n    impl: not\n  };\n\n  //# complement :: (a -> Boolean) -> a -> Boolean\n  //.\n  //. Takes a unary predicate and a value of any type, and returns the logical\n  //. negation of applying the predicate to the value.\n  //.\n  //. See also [`not`](#not).\n  //.\n  //. ```javascript\n  //. > Number.isInteger (42)\n  //. true\n  //.\n  //. > S.complement (Number.isInteger) (42)\n  //. false\n  //. ```\n  _.complement = {\n    consts: {},\n    types: [$.Predicate (a), a, $.Boolean],\n    impl: B (not)\n  };\n\n  //# boolean :: a -> a -> Boolean -> a\n  //.\n  //. Case analysis for the `Boolean` type. `boolean (x) (y) (b)` evaluates\n  //. to `x` if `b` is `false`; to `y` if `b` is `true`.\n  //.\n  //. ```javascript\n  //. > S.boolean ('no') ('yes') (false)\n  //. 'no'\n  //.\n  //. > S.boolean ('no') ('yes') (true)\n  //. 'yes'\n  //. ```\n  function boolean(x) {\n    return function(y) {\n      return function(b) {\n        return b ? y : x;\n      };\n    };\n  }\n  _.boolean = {\n    consts: {},\n    types: [a, a, $.Boolean, a],\n    impl: boolean\n  };\n\n  //# ifElse :: (a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b\n  //.\n  //. Takes a unary predicate, a unary \"if\" function, a unary \"else\"\n  //. function, and a value of any type, and returns the result of\n  //. applying the \"if\" function to the value if the value satisfies\n  //. the predicate; the result of applying the \"else\" function to the\n  //. value otherwise.\n  //.\n  //. See also [`when`](#when) and [`unless`](#unless).\n  //.\n  //. ```javascript\n  //. > S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (-1)\n  //. 1\n  //.\n  //. > S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (16)\n  //. 4\n  //. ```\n  function ifElse(pred) {\n    return function(f) {\n      return function(g) {\n        return function(x) {\n          return (pred (x) ? f : g) (x);\n        };\n      };\n    };\n  }\n  _.ifElse = {\n    consts: {},\n    types: [$.Predicate (a), $.Fn (a) (b), $.Fn (a) (b), a, b],\n    impl: ifElse\n  };\n\n  //# when :: (a -> Boolean) -> (a -> a) -> a -> a\n  //.\n  //. Takes a unary predicate, a unary function, and a value of any type, and\n  //. returns the result of applying the function to the value if the value\n  //. satisfies the predicate; the value otherwise.\n  //.\n  //. See also [`unless`](#unless) and [`ifElse`](#ifElse).\n  //.\n  //. ```javascript\n  //. > S.when (x => x >= 0) (Math.sqrt) (16)\n  //. 4\n  //.\n  //. > S.when (x => x >= 0) (Math.sqrt) (-1)\n  //. -1\n  //. ```\n  function when(pred) {\n    return C (ifElse (pred)) (I);\n  }\n  _.when = {\n    consts: {},\n    types: [$.Predicate (a), $.Fn (a) (a), a, a],\n    impl: when\n  };\n\n  //# unless :: (a -> Boolean) -> (a -> a) -> a -> a\n  //.\n  //. Takes a unary predicate, a unary function, and a value of any type, and\n  //. returns the result of applying the function to the value if the value\n  //. does not satisfy the predicate; the value otherwise.\n  //.\n  //. See also [`when`](#when) and [`ifElse`](#ifElse).\n  //.\n  //. ```javascript\n  //. > S.unless (x => x < 0) (Math.sqrt) (16)\n  //. 4\n  //.\n  //. > S.unless (x => x < 0) (Math.sqrt) (-1)\n  //. -1\n  //. ```\n  function unless(pred) {\n    return ifElse (pred) (I);\n  }\n  _.unless = {\n    consts: {},\n    types: [$.Predicate (a), $.Fn (a) (a), a, a],\n    impl: unless\n  };\n\n  //. ### Array\n\n  //# array :: b -> (a -> Array a -> b) -> Array a -> b\n  //.\n  //. Case analysis for the `Array a` type.\n  //.\n  //. ```javascript\n  //. > S.array (S.Nothing) (head => tail => S.Just (head)) ([])\n  //. Nothing\n  //.\n  //. > S.array (S.Nothing) (head => tail => S.Just (head)) ([1, 2, 3])\n  //. Just (1)\n  //.\n  //. > S.array (S.Nothing) (head => tail => S.Just (tail)) ([])\n  //. Nothing\n  //.\n  //. > S.array (S.Nothing) (head => tail => S.Just (tail)) ([1, 2, 3])\n  //. Just ([2, 3])\n  //. ```\n  function array(y) {\n    return function(f) {\n      return function(xs) {\n        return xs.length === 0 ? y : f (xs[0]) (xs.slice (1));\n      };\n    };\n  }\n  _.array = {\n    consts: {},\n    types: [b, $.Fn (a) ($.Fn ($.Array (a)) (b)), $.Array (a), b],\n    impl: array\n  };\n\n  //# head :: Foldable f => f a -> Maybe a\n  //.\n  //. Returns Just the first element of the given structure if the structure\n  //. contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.head ([1, 2, 3])\n  //. Just (1)\n  //.\n  //. > S.head ([])\n  //. Nothing\n  //.\n  //. > S.head (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (1)\n  //.\n  //. > S.head (Nil)\n  //. Nothing\n  //. ```\n  function head(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable[0]) : Nothing;\n    }\n    return Z.reduce (function(m, x) { return m.isJust ? m : Just (x); },\n                     Nothing,\n                     foldable);\n  }\n  _.head = {\n    consts: {f: [Z.Foldable]},\n    types: [f (a), $.Maybe (a)],\n    impl: head\n  };\n\n  //# last :: Foldable f => f a -> Maybe a\n  //.\n  //. Returns Just the last element of the given structure if the structure\n  //. contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.last ([1, 2, 3])\n  //. Just (3)\n  //.\n  //. > S.last ([])\n  //. Nothing\n  //.\n  //. > S.last (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (3)\n  //.\n  //. > S.last (Nil)\n  //. Nothing\n  //. ```\n  function last(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable[foldable.length - 1])\n                                 : Nothing;\n    }\n    return Z.reduce (function(_, x) { return Just (x); }, Nothing, foldable);\n  }\n  _.last = {\n    consts: {f: [Z.Foldable]},\n    types: [f (a), $.Maybe (a)],\n    impl: last\n  };\n\n  //# tail :: (Applicative f, Foldable f, Monoid (f a)) => f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the first of the given structure's elements if the\n  //. structure contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.tail ([1, 2, 3])\n  //. Just ([2, 3])\n  //.\n  //. > S.tail ([])\n  //. Nothing\n  //.\n  //. > S.tail (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (Cons (2) (Cons (3) (Nil)))\n  //\n  //. > S.tail (Nil)\n  //. Nothing\n  //. ```\n  function tail(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable.slice (1)) : Nothing;\n    }\n    var empty = Z.empty (foldable.constructor);\n    return Z.reduce (function(m, x) {\n      return Just (maybe (empty) (append (x)) (m));\n    }, Nothing, foldable);\n  }\n  _.tail = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [f (a), $.Maybe (f (a))],\n    impl: tail\n  };\n\n  //# init :: (Applicative f, Foldable f, Monoid (f a)) => f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the last of the given structure's elements if the\n  //. structure contains at least one element; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.init ([1, 2, 3])\n  //. Just ([1, 2])\n  //.\n  //. > S.init ([])\n  //. Nothing\n  //.\n  //. > S.init (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Just (Cons (1) (Cons (2) (Nil)))\n  //.\n  //. > S.init (Nil)\n  //. Nothing\n  //. ```\n  function init(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray (foldable)) {\n      return foldable.length > 0 ? Just (foldable.slice (0, -1)) : Nothing;\n    }\n    var empty = Z.empty (foldable.constructor);\n    return Z.map (Pair.snd, Z.reduce (function(m, x) {\n      return Just (Pair (x) (maybe (empty) (pair (append)) (m)));\n    }, Nothing, foldable));\n  }\n  _.init = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [f (a), $.Maybe (f (a))],\n    impl: init\n  };\n\n  //# take :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just the first N elements of the given structure if N is\n  //. non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.take (0) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.take (1) (['foo', 'bar'])\n  //. Just (['foo'])\n  //.\n  //. > S.take (2) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.take (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.take (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Cons (5) (Nil))))))\n  //. Just (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. ```\n  function _takeDrop(arrayCase, generalCase) {\n    return function(n) {\n      return function(xs) {\n        if (n < 0) return Nothing;\n\n        //  Fast path for arrays.\n        if (Array.isArray (xs)) {\n          return n <= xs.length ? Just (arrayCase (n, xs)) : Nothing;\n        }\n\n        //  m :: Maybe (Pair Integer (f a))\n        var m = Z.reduce (function(m, x) {\n          return Z.map (function(pair) {\n            var n = pair.fst;\n            var xs = pair.snd;\n            return Pair (n - 1) (generalCase (n, xs, x));\n          }, m);\n        }, Just (Pair (n) (Z.empty (xs.constructor))), xs);\n\n        return Z.map (Pair.snd, Z.reject (B (gt (0)) (Pair.fst), m));\n      };\n    };\n  }\n  var take = _takeDrop (\n    function(n, xs) { return xs.slice (0, n); },\n    function(n, xs, x) { return n > 0 ? Z.append (x, xs) : xs; }\n  );\n  _.take = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: take\n  };\n\n  //# drop :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the first N elements of the given structure if\n  //. N is non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.drop (0) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.drop (1) (['foo', 'bar'])\n  //. Just (['bar'])\n  //.\n  //. > S.drop (2) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.drop (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.drop (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Cons (5) (Nil))))))\n  //. Just (Cons (4) (Cons (5) (Nil)))\n  //. ```\n  var drop = _takeDrop (\n    function(n, xs) { return xs.slice (n); },\n    function(n, xs, x) { return n > 0 ? xs : Z.append (x, xs); }\n  );\n  _.drop = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: drop\n  };\n\n  //# takeLast :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just the last N elements of the given structure if N is\n  //. non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.takeLast (0) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.takeLast (1) (['foo', 'bar'])\n  //. Just (['bar'])\n  //.\n  //. > S.takeLast (2) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.takeLast (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.takeLast (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Nil)))))\n  //. Just (Cons (2) (Cons (3) (Cons (4) (Nil))))\n  //. ```\n  function takeLast(n) {\n    return function(xs) {\n      return Z.map (Z.reverse, take (n) (Z.reverse (xs)));\n    };\n  }\n  _.takeLast = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: takeLast\n  };\n\n  //# dropLast :: (Applicative f, Foldable f, Monoid (f a)) => Integer -> f a -> Maybe (f a)\n  //.\n  //. Returns Just all but the last N elements of the given structure if\n  //. N is non-negative and less than or equal to the size of the structure;\n  //. Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.dropLast (0) (['foo', 'bar'])\n  //. Just (['foo', 'bar'])\n  //.\n  //. > S.dropLast (1) (['foo', 'bar'])\n  //. Just (['foo'])\n  //.\n  //. > S.dropLast (2) (['foo', 'bar'])\n  //. Just ([])\n  //.\n  //. > S.dropLast (3) (['foo', 'bar'])\n  //. Nothing\n  //.\n  //. > S.dropLast (3) (Cons (1) (Cons (2) (Cons (3) (Cons (4) (Nil)))))\n  //. Just (Cons (1) (Nil))\n  //. ```\n  function dropLast(n) {\n    return function(xs) {\n      return Z.map (Z.reverse, drop (n) (Z.reverse (xs)));\n    };\n  }\n  _.dropLast = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Integer, f (a), $.Maybe (f (a))],\n    impl: dropLast\n  };\n\n  //# takeWhile :: (a -> Boolean) -> Array a -> Array a\n  //.\n  //. Discards the first element that does not satisfy the predicate,\n  //. and all subsequent elements.\n  //.\n  //. See also [`dropWhile`](#dropWhile).\n  //.\n  //. ```javascript\n  //. > S.takeWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. [3, 3, 3, 7]\n  //.\n  //. > S.takeWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. []\n  //. ```\n  function takeWhile(pred) {\n    return function(xs) {\n      var idx = 0;\n      while (idx < xs.length && pred (xs[idx])) idx += 1;\n      return xs.slice (0, idx);\n    };\n  }\n  _.takeWhile = {\n    consts: {},\n    types: [$.Predicate (a), $.Array (a), $.Array (a)],\n    impl: takeWhile\n  };\n\n  //# dropWhile :: (a -> Boolean) -> Array a -> Array a\n  //.\n  //. Retains the first element that does not satisfy the predicate,\n  //. and all subsequent elements.\n  //.\n  //. See also [`takeWhile`](#takeWhile).\n  //.\n  //. ```javascript\n  //. > S.dropWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. [6, 3, 5, 4]\n  //.\n  //. > S.dropWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])\n  //. [3, 3, 3, 7, 6, 3, 5, 4]\n  //. ```\n  function dropWhile(pred) {\n    return function(xs) {\n      var idx = 0;\n      while (idx < xs.length && pred (xs[idx])) idx += 1;\n      return xs.slice (idx);\n    };\n  }\n  _.dropWhile = {\n    consts: {},\n    types: [$.Predicate (a), $.Array (a), $.Array (a)],\n    impl: dropWhile\n  };\n\n  //# size :: Foldable f => f a -> NonNegativeInteger\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. ```javascript\n  //. > S.size ([])\n  //. 0\n  //.\n  //. > S.size (['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > S.size (Nil)\n  //. 0\n  //.\n  //. > S.size (Cons ('foo') (Cons ('bar') (Cons ('baz') (Nil))))\n  //. 3\n  //.\n  //. > S.size (S.Nothing)\n  //. 0\n  //.\n  //. > S.size (S.Just ('quux'))\n  //. 1\n  //.\n  //. > S.size (S.Pair ('ignored!') ('counted!'))\n  //. 1\n  //. ```\n  _.size = {\n    consts: {f: [Z.Foldable]},\n    types: [f (a), $.NonNegativeInteger],\n    impl: Z.size\n  };\n\n  //# all :: Foldable f => (a -> Boolean) -> f a -> Boolean\n  //.\n  //. Returns `true` [iff][] all the elements of the structure satisfy the\n  //. predicate.\n  //.\n  //. See also [`any`](#any) and [`none`](#none).\n  //.\n  //. ```javascript\n  //. > S.all (S.odd) ([])\n  //. true\n  //.\n  //. > S.all (S.odd) ([1, 3, 5])\n  //. true\n  //.\n  //. > S.all (S.odd) ([1, 2, 3])\n  //. false\n  //. ```\n  _.all = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Boolean],\n    impl: curry2 (Z.all)\n  };\n\n  //# any :: Foldable f => (a -> Boolean) -> f a -> Boolean\n  //.\n  //. Returns `true` [iff][] any element of the structure satisfies the\n  //. predicate.\n  //.\n  //. See also [`all`](#all) and [`none`](#none).\n  //.\n  //. ```javascript\n  //. > S.any (S.odd) ([])\n  //. false\n  //.\n  //. > S.any (S.odd) ([2, 4, 6])\n  //. false\n  //.\n  //. > S.any (S.odd) ([1, 2, 3])\n  //. true\n  //. ```\n  _.any = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Boolean],\n    impl: curry2 (Z.any)\n  };\n\n  //# none :: Foldable f => (a -> Boolean) -> f a -> Boolean\n  //.\n  //. Returns `true` [iff][] none of the elements of the structure satisfies\n  //. the predicate.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall p :: a -> Boolean, xs :: Foldable f => f a.\n  //.      S.none (p) (xs) = S.not (S.any (p) (xs))`\n  //.\n  //.   - `forall p :: a -> Boolean, xs :: Foldable f => f a.\n  //.      S.none (p) (xs) = S.all (S.complement (p)) (xs)`\n  //.\n  //. See also [`all`](#all) and [`any`](#any).\n  //.\n  //. ```javascript\n  //. > S.none (S.odd) ([])\n  //. true\n  //.\n  //. > S.none (S.odd) ([2, 4, 6])\n  //. true\n  //.\n  //. > S.none (S.odd) ([1, 2, 3])\n  //. false\n  //. ```\n  _.none = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Boolean],\n    impl: curry2 (Z.none)\n  };\n\n  //# append :: (Applicative f, Semigroup (f a)) => a -> f a -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > S.append (3) ([1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > S.append (3) (Cons (1) (Cons (2) (Nil)))\n  //. Cons (1) (Cons (2) (Cons (3) (Nil)))\n  //.\n  //. > S.append ([1]) (S.Nothing)\n  //. Just ([1])\n  //.\n  //. > S.append ([3]) (S.Just ([1, 2]))\n  //. Just ([1, 2, 3])\n  //. ```\n  function append(x) {\n    return function(xs) {\n      return Z.append (x, xs);\n    };\n  }\n  _.append = {\n    consts: {f: [Z.Applicative, Z.Semigroup]},\n    types: [a, f (a), f (a)],\n    impl: append\n  };\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => a -> f a -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > S.prepend (1) ([2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > S.prepend (1) (Cons (2) (Cons (3) (Nil)))\n  //. Cons (1) (Cons (2) (Cons (3) (Nil)))\n  //.\n  //. > S.prepend ([1]) (S.Nothing)\n  //. Just ([1])\n  //.\n  //. > S.prepend ([1]) (S.Just ([2, 3]))\n  //. Just ([1, 2, 3])\n  //. ```\n  _.prepend = {\n    consts: {f: [Z.Applicative, Z.Semigroup]},\n    types: [a, f (a), f (a)],\n    impl: curry2 (Z.prepend)\n  };\n\n  //# joinWith :: String -> Array String -> String\n  //.\n  //. Joins the strings of the second argument separated by the first argument.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String, t :: String.\n  //.      S.joinWith (s) (S.splitOn (s) (t)) = t`\n  //.\n  //. See also [`splitOn`](#splitOn).\n  //.\n  //. ```javascript\n  //. > S.joinWith (':') (['foo', 'bar', 'baz'])\n  //. 'foo:bar:baz'\n  //. ```\n  _.joinWith = {\n    consts: {},\n    types: [$.String, $.Array ($.String), $.String],\n    impl: invoke1 ('join')\n  };\n\n  //# elem :: (Setoid a, Foldable f) => a -> f a -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` [iff][] the value is an\n  //. element of the structure.\n  //.\n  //. See also [`find`](#find).\n  //.\n  //. ```javascript\n  //. > S.elem ('c') (['a', 'b', 'c'])\n  //. true\n  //.\n  //. > S.elem ('x') (['a', 'b', 'c'])\n  //. false\n  //.\n  //. > S.elem (3) ({x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > S.elem (8) ({x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > S.elem (0) (S.Just (0))\n  //. true\n  //.\n  //. > S.elem (0) (S.Just (1))\n  //. false\n  //.\n  //. > S.elem (0) (S.Nothing)\n  //. false\n  //. ```\n  _.elem = {\n    consts: {a: [Z.Setoid], f: [Z.Foldable]},\n    types: [a, f (a), $.Boolean],\n    impl: curry2 (Z.elem)\n  };\n\n  //# find :: Foldable f => (a -> Boolean) -> f a -> Maybe a\n  //.\n  //. Takes a predicate and a structure and returns Just the leftmost element\n  //. of the structure that satisfies the predicate; Nothing if there is no\n  //. such element.\n  //.\n  //. See also [`elem`](#elem).\n  //.\n  //. ```javascript\n  //. > S.find (S.lt (0)) ([1, -2, 3, -4, 5])\n  //. Just (-2)\n  //.\n  //. > S.find (S.lt (0)) ([1, 2, 3, 4, 5])\n  //. Nothing\n  //. ```\n  function find(pred) {\n    return function(xs) {\n      return Z.reduce (\n        function(m, x) {\n          return m.isJust ? m : pred (x) ? Just (x) : Nothing;\n        },\n        Nothing,\n        xs\n      );\n    };\n  }\n  _.find = {\n    consts: {f: [Z.Foldable]},\n    types: [$.Predicate (a), f (a), $.Maybe (a)],\n    impl: find\n  };\n\n  //# foldMap :: (Monoid m, Foldable f) => TypeRep m -> (a -> m) -> f a -> m\n  //.\n  //. Curried version of [`Z.foldMap`][]. Deconstructs a foldable by mapping\n  //. every element to a monoid and concatenating the results.\n  //.\n  //. ```javascript\n  //. > S.foldMap (String) (f => f.name) ([Math.sin, Math.cos, Math.tan])\n  //. 'sincostan'\n  //.\n  //. > S.foldMap (Array) (x => [x + 1, x + 2]) ([10, 20, 30])\n  //. [11, 12, 21, 22, 31, 32]\n  //. ```\n  _.foldMap = {\n    consts: {b: [Z.Monoid], f: [Z.Foldable]},\n    types: [TypeRep (b), $.Fn (a) (b), f (a), b],\n    impl: curry3 (Z.foldMap)\n  };\n\n  //# unfoldr :: (b -> Maybe (Pair a b)) -> b -> Array a\n  //.\n  //. Takes a function and a seed value, and returns an array generated by\n  //. applying the function repeatedly. The array is initially empty. The\n  //. function is initially applied to the seed value. Each application\n  //. of the function should result in either:\n  //.\n  //.   - Nothing, in which case the array is returned; or\n  //.\n  //.   - Just a pair, in which case the first element is appended to\n  //.     the array and the function is applied to the second element.\n  //.\n  //. ```javascript\n  //. > S.unfoldr (n => n < 1000 ? S.Just (S.Pair (n) (2 * n)) : S.Nothing) (1)\n  //. [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n  //. ```\n  function unfoldr(f) {\n    return function(x) {\n      var result = [];\n      for (var m = f (x); m.isJust; m = f (m.value.snd)) {\n        result.push (m.value.fst);\n      }\n      return result;\n    };\n  }\n  _.unfoldr = {\n    consts: {},\n    types: [$.Fn (b) ($.Maybe ($.Pair (a) (b))), b, $.Array (a)],\n    impl: unfoldr\n  };\n\n  //# range :: Integer -> Integer -> Array Integer\n  //.\n  //. Returns an array of consecutive integers starting with the first argument\n  //. and ending with the second argument minus one. Returns `[]` if the second\n  //. argument is less than or equal to the first argument.\n  //.\n  //. ```javascript\n  //. > S.range (0) (10)\n  //. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  //.\n  //. > S.range (-5) (0)\n  //. [-5, -4, -3, -2, -1]\n  //.\n  //. > S.range (0) (-5)\n  //. []\n  //. ```\n  function range(from) {\n    return function(to) {\n      var result = [];\n      for (var n = from; n < to; n += 1) result.push (n);\n      return result;\n    };\n  }\n  _.range = {\n    consts: {},\n    types: [$.Integer, $.Integer, $.Array ($.Integer)],\n    impl: range\n  };\n\n  //# groupBy :: (a -> a -> Boolean) -> Array a -> Array (Array a)\n  //.\n  //. Splits its array argument into an array of arrays of equal,\n  //. adjacent elements. Equality is determined by the function\n  //. provided as the first argument. Its behaviour can be surprising\n  //. for functions that aren't reflexive, transitive, and symmetric\n  //. (see [equivalence][] relation).\n  //.\n  //. Properties:\n  //.\n  //.   - `forall f :: a -> a -> Boolean, xs :: Array a.\n  //.      S.join (S.groupBy (f) (xs)) = xs`\n  //.\n  //. ```javascript\n  //. > S.groupBy (S.equals) ([1, 1, 2, 1, 1])\n  //. [[1, 1], [2], [1, 1]]\n  //.\n  //. > S.groupBy (x => y => x + y === 0) ([2, -3, 3, 3, 3, 4, -4, 4])\n  //. [[2], [-3, 3, 3, 3], [4, -4], [4]]\n  //. ```\n  function groupBy(f) {\n    return function(xs) {\n      if (xs.length === 0) return [];\n      var x0 = xs[0];         // :: a\n      var active = [x0];      // :: Array a\n      var result = [active];  // :: Array (Array a)\n      for (var idx = 1; idx < xs.length; idx += 1) {\n        var x = xs[idx];\n        if (f (x0) (x)) active.push (x); else result.push (active = [x0 = x]);\n      }\n      return result;\n    };\n  }\n  _.groupBy = {\n    consts: {},\n    types: [$.Fn (a) ($.Predicate (a)), $.Array (a), $.Array ($.Array (a))],\n    impl: groupBy\n  };\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. ```javascript\n  //. > S.reverse ([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > S.reverse (Cons (1) (Cons (2) (Cons (3) (Nil))))\n  //. Cons (3) (Cons (2) (Cons (1) (Nil)))\n  //.\n  //. > S.pipe ([S.splitOn (''), S.reverse, S.joinWith ('')]) ('abc')\n  //. 'cba'\n  //. ```\n  _.reverse = {\n    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [f (a), f (a)],\n    impl: Z.reverse\n  };\n\n  //# sort :: (Ord a, Applicative m, Foldable m, Monoid (m a)) => m a -> m a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure, using\n  //. [`Z.lte`][] for comparisons.\n  //.\n  //. Properties:\n  //.\n  //.   - `S.sort (S.sort (m)) = S.sort (m)` (idempotence)\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > S.sort (['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > S.sort ([S.Left (4), S.Right (3), S.Left (2), S.Right (1)])\n  //. [Left (2), Left (4), Right (1), Right (3)]\n  //. ```\n  _.sort = {\n    consts: {a: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [m (a), m (a)],\n    impl: Z.sort\n  };\n\n  //# sortBy :: (Ord b, Applicative m, Foldable m, Monoid (m a)) => (a -> b) -> m a -> m a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure, using\n  //. [`Z.lte`][] to compare the values produced by applying the given function\n  //. to each element of the structure.\n  //.\n  //. Properties:\n  //.\n  //.   - `S.sortBy (f) (S.sortBy (f) (m)) = S.sortBy (f) (m)` (idempotence)\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > S.sortBy (S.prop ('rank')) ([\n  //. .   {rank: 7, suit: 'spades'},\n  //. .   {rank: 5, suit: 'hearts'},\n  //. .   {rank: 2, suit: 'hearts'},\n  //. .   {rank: 5, suit: 'spades'},\n  //. . ])\n  //. [ {rank: 2, suit: 'hearts'},\n  //. . {rank: 5, suit: 'hearts'},\n  //. . {rank: 5, suit: 'spades'},\n  //. . {rank: 7, suit: 'spades'} ]\n  //.\n  //. > S.sortBy (S.prop ('suit')) ([\n  //. .   {rank: 7, suit: 'spades'},\n  //. .   {rank: 5, suit: 'hearts'},\n  //. .   {rank: 2, suit: 'hearts'},\n  //. .   {rank: 5, suit: 'spades'},\n  //. . ])\n  //. [ {rank: 5, suit: 'hearts'},\n  //. . {rank: 2, suit: 'hearts'},\n  //. . {rank: 7, suit: 'spades'},\n  //. . {rank: 5, suit: 'spades'} ]\n  //. ```\n  //.\n  //. If descending order is desired, one may use [`Descending`][]:\n  //.\n  //. ```javascript\n  //. > S.sortBy (Descending) ([83, 97, 110, 99, 116, 117, 97, 114, 121])\n  //. [121, 117, 116, 114, 110, 99, 97, 97, 83]\n  //. ```\n  _.sortBy = {\n    consts: {b: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},\n    types: [$.Fn (a) (b), m (a), m (a)],\n    impl: curry2 (Z.sortBy)\n  };\n\n  //# zip :: Array a -> Array b -> Array (Pair a b)\n  //.\n  //. Returns an array of pairs of corresponding elements from the given\n  //. arrays. The length of the resulting array is equal to the length of\n  //. the shorter input array.\n  //.\n  //. See also [`zipWith`](#zipWith).\n  //.\n  //. ```javascript\n  //. > S.zip (['a', 'b']) (['x', 'y', 'z'])\n  //. [Pair ('a') ('x'), Pair ('b') ('y')]\n  //.\n  //. > S.zip ([1, 3, 5]) ([2, 4])\n  //. [Pair (1) (2), Pair (3) (4)]\n  //. ```\n  _.zip = {\n    consts: {},\n    types: [$.Array (a), $.Array (b), $.Array ($.Pair (a) (b))],\n    impl: zipWith (Pair)\n  };\n\n  //# zipWith :: (a -> b -> c) -> Array a -> Array b -> Array c\n  //.\n  //. Returns the result of combining, pairwise, the given arrays using the\n  //. given binary function. The length of the resulting array is equal to the\n  //. length of the shorter input array.\n  //.\n  //. See also [`zip`](#zip).\n  //.\n  //. ```javascript\n  //. > S.zipWith (a => b => a + b) (['a', 'b']) (['x', 'y', 'z'])\n  //. ['ax', 'by']\n  //.\n  //. > S.zipWith (a => b => [a, b]) ([1, 3, 5]) ([2, 4])\n  //. [[1, 2], [3, 4]]\n  //. ```\n  function zipWith(f) {\n    return function(xs) {\n      return function(ys) {\n        var result = [];\n        var len = Math.min (xs.length, ys.length);\n        for (var idx = 0; idx < len; idx += 1) {\n          result.push (f (xs[idx]) (ys[idx]));\n        }\n        return result;\n      };\n    };\n  }\n  _.zipWith = {\n    consts: {},\n    types: [$.Fn (a) ($.Fn (b) (c)), $.Array (a), $.Array (b), $.Array (c)],\n    impl: zipWith\n  };\n\n  //. ### Object\n\n  //# prop :: String -> a -> b\n  //.\n  //. Takes a property name and an object with known properties and returns\n  //. the value of the specified property. If for some reason the object\n  //. lacks the specified property, a type error is thrown.\n  //.\n  //. For accessing properties of uncertain objects, use [`get`](#get) instead.\n  //. For accessing string map values by key, use [`value`](#value) instead.\n  //.\n  //. ```javascript\n  //. > S.prop ('a') ({a: 1, b: 2})\n  //. 1\n  //. ```\n  function prop(key) {\n    return function(x) {\n      var obj = toObject (x);\n      if (key in obj) return obj[key];\n      throw new TypeError ('‘prop’ expected object to have a property named ' +\n                           '‘' + key + '’; ' + show (x) + ' does not');\n    };\n  }\n  _.prop = {\n    consts: {},\n    types: [$.String, a, b],\n    impl: prop\n  };\n\n  //# props :: Array String -> a -> b\n  //.\n  //. Takes a property path (an array of property names) and an object with\n  //. known structure and returns the value at the given path. If for some\n  //. reason the path does not exist, a type error is thrown.\n  //.\n  //. For accessing property paths of uncertain objects, use [`gets`](#gets)\n  //. instead.\n  //.\n  //. ```javascript\n  //. > S.props (['a', 'b', 'c']) ({a: {b: {c: 1}}})\n  //. 1\n  //. ```\n  function props(path) {\n    return function(x) {\n      return path.reduce (function(x, key) {\n        var obj = toObject (x);\n        if (key in obj) return obj[key];\n        throw new TypeError ('‘props’ expected object to have a property at ' +\n                             show (path) + '; ' + show (x) + ' does not');\n      }, x);\n    };\n  }\n  _.props = {\n    consts: {},\n    types: [$.Array ($.String), a, b],\n    impl: props\n  };\n\n  //# get :: (Any -> Boolean) -> String -> a -> Maybe b\n  //.\n  //. Takes a predicate, a property name, and an object and returns Just the\n  //. value of the specified object property if it exists and the value\n  //. satisfies the given predicate; Nothing otherwise.\n  //.\n  //. See also [`gets`](#gets), [`prop`](#prop), and [`value`](#value).\n  //.\n  //. ```javascript\n  //. > S.get (S.is ($.Number)) ('x') ({x: 1, y: 2})\n  //. Just (1)\n  //.\n  //. > S.get (S.is ($.Number)) ('x') ({x: '1', y: '2'})\n  //. Nothing\n  //.\n  //. > S.get (S.is ($.Number)) ('x') ({})\n  //. Nothing\n  //.\n  //. > S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3]})\n  //. Just ([1, 2, 3])\n  //.\n  //. > S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3, null]})\n  //. Nothing\n  //. ```\n  function get(pred) {\n    return B (B (filter (pred))) (get_);\n  }\n  _.get = {\n    consts: {},\n    types: [$.Predicate ($.Any), $.String, a, $.Maybe (b)],\n    impl: get\n  };\n\n  //# gets :: (Any -> Boolean) -> Array String -> a -> Maybe b\n  //.\n  //. Takes a predicate, a property path (an array of property names), and\n  //. an object and returns Just the value at the given path if such a path\n  //. exists and the value satisfies the given predicate; Nothing otherwise.\n  //.\n  //. See also [`get`](#get).\n  //.\n  //. ```javascript\n  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: 42}}})\n  //. Just (42)\n  //.\n  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: '42'}}})\n  //. Nothing\n  //.\n  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({})\n  //. Nothing\n  //. ```\n  function gets(pred) {\n    return function(keys) {\n      return function(x) {\n        return Z.filter (pred, keys.reduce (function(maybe, key) {\n          return Z.chain (get_ (key), maybe);\n        }, Just (x)));\n      };\n    };\n  }\n  _.gets = {\n    consts: {},\n    types: [$.Predicate ($.Any), $.Array ($.String), a, $.Maybe (b)],\n    impl: gets\n  };\n\n  //. ### StrMap\n  //.\n  //. StrMap is an abbreviation of _string map_. A string map is an object,\n  //. such as `{foo: 1, bar: 2, baz: 3}`, whose values are all members of\n  //. the same type. Formally, a value is a member of type `StrMap a` if its\n  //. [type identifier][] is `'Object'` and the values of its enumerable own\n  //. properties are all members of type `a`.\n\n  //# value :: String -> StrMap a -> Maybe a\n  //.\n  //. Retrieve the value associated with the given key in the given string map.\n  //.\n  //. Formally, `value (k) (m)` evaluates to `Just (m[k])` if `k` is an\n  //. enumerable own property of `m`; `Nothing` otherwise.\n  //.\n  //. See also [`prop`](#prop) and [`get`](#get).\n  //.\n  //. ```javascript\n  //. > S.value ('foo') ({foo: 1, bar: 2})\n  //. Just (1)\n  //.\n  //. > S.value ('bar') ({foo: 1, bar: 2})\n  //. Just (2)\n  //.\n  //. > S.value ('baz') ({foo: 1, bar: 2})\n  //. Nothing\n  //. ```\n  function value(key) {\n    return function(strMap) {\n      return Object.prototype.propertyIsEnumerable.call (strMap, key) ?\n             Just (strMap[key]) :\n             Nothing;\n    };\n  }\n  _.value = {\n    consts: {},\n    types: [$.String, $.StrMap (a), $.Maybe (a)],\n    impl: value\n  };\n\n  //# singleton :: String -> a -> StrMap a\n  //.\n  //. Takes a string and a value of any type, and returns a string map with\n  //. a single entry (mapping the key to the value).\n  //.\n  //. ```javascript\n  //. > S.singleton ('foo') (42)\n  //. {foo: 42}\n  //. ```\n  function singleton(key) {\n    return function(val) {\n      var strMap = {};\n      strMap[key] = val;\n      return strMap;\n    };\n  }\n  _.singleton = {\n    consts: {},\n    types: [$.String, a, $.StrMap (a)],\n    impl: singleton\n  };\n\n  //# insert :: String -> a -> StrMap a -> StrMap a\n  //.\n  //. Takes a string, a value of any type, and a string map, and returns a\n  //. string map comprising all the entries of the given string map plus the\n  //. entry specified by the first two arguments (which takes precedence).\n  //.\n  //. Equivalent to Haskell's `insert` function. Similar to Clojure's `assoc`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.insert ('c') (3) ({a: 1, b: 2})\n  //. {a: 1, b: 2, c: 3}\n  //.\n  //. > S.insert ('a') (4) ({a: 1, b: 2})\n  //. {a: 4, b: 2}\n  //. ```\n  function insert(key) {\n    return function(val) {\n      return function(strMap) {\n        return Z.concat (strMap, singleton (key) (val));\n      };\n    };\n  }\n  _.insert = {\n    consts: {},\n    types: [$.String, a, $.StrMap (a), $.StrMap (a)],\n    impl: insert\n  };\n\n  //# remove :: String -> StrMap a -> StrMap a\n  //.\n  //. Takes a string and a string map, and returns a string map comprising all\n  //. the entries of the given string map except the one whose key matches the\n  //. given string (if such a key exists).\n  //.\n  //. Equivalent to Haskell's `delete` function. Similar to Clojure's `dissoc`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.remove ('c') ({a: 1, b: 2, c: 3})\n  //. {a: 1, b: 2}\n  //.\n  //. > S.remove ('c') ({})\n  //. {}\n  //. ```\n  function remove(key) {\n    return function(strMap) {\n      var result = Z.concat (strMap, {});\n      delete result[key];\n      return result;\n    };\n  }\n  _.remove = {\n    consts: {},\n    types: [$.String, $.StrMap (a), $.StrMap (a)],\n    impl: remove\n  };\n\n  //# keys :: StrMap a -> Array String\n  //.\n  //. Returns the keys of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.sort (S.keys ({b: 2, c: 3, a: 1}))\n  //. ['a', 'b', 'c']\n  //. ```\n  _.keys = {\n    consts: {},\n    types: [$.StrMap (a), $.Array ($.String)],\n    impl: Object.keys\n  };\n\n  //# values :: StrMap a -> Array a\n  //.\n  //. Returns the values of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.sort (S.values ({a: 1, c: 3, b: 2}))\n  //. [1, 2, 3]\n  //. ```\n  function values(strMap) {\n    return Z.map (function(k) { return strMap[k]; }, Object.keys (strMap));\n  }\n  _.values = {\n    consts: {},\n    types: [$.StrMap (a), $.Array (a)],\n    impl: values\n  };\n\n  //# pairs :: StrMap a -> Array (Pair String a)\n  //.\n  //. Returns the key–value pairs of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.sort (S.pairs ({b: 2, a: 1, c: 3}))\n  //. [Pair ('a') (1), Pair ('b') (2), Pair ('c') (3)]\n  //. ```\n  function pairs(strMap) {\n    return Z.map (function(k) { return Pair (k) (strMap[k]); },\n                  Object.keys (strMap));\n  }\n  _.pairs = {\n    consts: {},\n    types: [$.StrMap (a), $.Array ($.Pair ($.String) (a))],\n    impl: pairs\n  };\n\n  //# fromPairs :: Foldable f => f (Pair String a) -> StrMap a\n  //.\n  //. Returns a string map containing the key–value pairs specified by the\n  //. given [Foldable][]. If a key appears in multiple pairs, the rightmost\n  //. pair takes precedence.\n  //.\n  //. ```javascript\n  //. > S.fromPairs ([S.Pair ('a') (1), S.Pair ('b') (2), S.Pair ('c') (3)])\n  //. {a: 1, b: 2, c: 3}\n  //.\n  //. > S.fromPairs ([S.Pair ('x') (1), S.Pair ('x') (2)])\n  //. {x: 2}\n  //. ```\n  function fromPairs(pairs) {\n    return Z.reduce (function(strMap, pair) {\n      strMap[pair.fst] = pair.snd;\n      return strMap;\n    }, {}, pairs);\n  }\n  _.fromPairs = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.Pair ($.String) (a)), $.StrMap (a)],\n    impl: fromPairs\n  };\n\n  //. ### Number\n\n  //# negate :: ValidNumber -> ValidNumber\n  //.\n  //. Negates its argument.\n  //.\n  //. ```javascript\n  //. > S.negate (12.5)\n  //. -12.5\n  //.\n  //. > S.negate (-42)\n  //. 42\n  //. ```\n  function negate(n) {\n    return -n;\n  }\n  _.negate = {\n    consts: {},\n    types: [$.ValidNumber, $.ValidNumber],\n    impl: negate\n  };\n\n  //# add :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the sum of two (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.add (1) (1)\n  //. 2\n  //. ```\n  function add(x) {\n    return function(y) {\n      return x + y;\n    };\n  }\n  _.add = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: add\n  };\n\n  //# sum :: Foldable f => f FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the sum of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.sum ([1, 2, 3, 4, 5])\n  //. 15\n  //.\n  //. > S.sum ([])\n  //. 0\n  //.\n  //. > S.sum (S.Just (42))\n  //. 42\n  //.\n  //. > S.sum (S.Nothing)\n  //. 0\n  //. ```\n  _.sum = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.FiniteNumber), $.FiniteNumber],\n    impl: reduce (add) (0)\n  };\n\n  //# sub :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Takes a finite number `n` and returns the _subtract `n`_ function.\n  //.\n  //. ```javascript\n  //. > S.map (S.sub (1)) ([1, 2, 3])\n  //. [0, 1, 2]\n  //. ```\n  function sub(y) {\n    return function(x) {\n      return x - y;\n    };\n  }\n  _.sub = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: sub\n  };\n\n  //# mult :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the product of two (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.mult (4) (2)\n  //. 8\n  //. ```\n  function mult(x) {\n    return function(y) {\n      return x * y;\n    };\n  }\n  _.mult = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: mult\n  };\n\n  //# product :: Foldable f => f FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the product of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.product ([1, 2, 3, 4, 5])\n  //. 120\n  //.\n  //. > S.product ([])\n  //. 1\n  //.\n  //. > S.product (S.Just (42))\n  //. 42\n  //.\n  //. > S.product (S.Nothing)\n  //. 1\n  //. ```\n  _.product = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.FiniteNumber), $.FiniteNumber],\n    impl: reduce (mult) (1)\n  };\n\n  //# div :: NonZeroFiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Takes a non-zero finite number `n` and returns the _divide by `n`_\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.map (S.div (2)) ([0, 1, 2, 3])\n  //. [0, 0.5, 1, 1.5]\n  //. ```\n  function div(y) {\n    return function(x) {\n      return x / y;\n    };\n  }\n  _.div = {\n    consts: {},\n    types: [$.NonZeroFiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: div\n  };\n\n  //# pow :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Takes a finite number `n` and returns the _power of `n`_ function.\n  //.\n  //. ```javascript\n  //. > S.map (S.pow (2)) ([-3, -2, -1, 0, 1, 2, 3])\n  //. [9, 4, 1, 0, 1, 4, 9]\n  //.\n  //. > S.map (S.pow (0.5)) ([1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5]\n  //. ```\n  function pow(exp) {\n    return function(base) {\n      return Math.pow (base, exp);\n    };\n  }\n  _.pow = {\n    consts: {},\n    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],\n    impl: pow\n  };\n\n  //# mean :: Foldable f => f FiniteNumber -> Maybe FiniteNumber\n  //.\n  //. Returns the mean of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.mean ([1, 2, 3, 4, 5])\n  //. Just (3)\n  //.\n  //. > S.mean ([])\n  //. Nothing\n  //.\n  //. > S.mean (S.Just (42))\n  //. Just (42)\n  //.\n  //. > S.mean (S.Nothing)\n  //. Nothing\n  //. ```\n  function mean(foldable) {\n    var result = Z.reduce (\n      function(acc, n) {\n        acc.total += n;\n        acc.count += 1;\n        return acc;\n      },\n      {total: 0, count: 0},\n      foldable\n    );\n    return result.count > 0 ? Just (result.total / result.count) : Nothing;\n  }\n  _.mean = {\n    consts: {f: [Z.Foldable]},\n    types: [f ($.FiniteNumber), $.Maybe ($.FiniteNumber)],\n    impl: mean\n  };\n\n  //. ### Integer\n\n  //# even :: Integer -> Boolean\n  //.\n  //. Returns `true` if the given integer is even; `false` if it is odd.\n  //.\n  //. ```javascript\n  //. > S.even (42)\n  //. true\n  //.\n  //. > S.even (99)\n  //. false\n  //. ```\n  function even(n) {\n    return n % 2 === 0;\n  }\n  _.even = {\n    consts: {},\n    types: [$.Integer, $.Boolean],\n    impl: even\n  };\n\n  //# odd :: Integer -> Boolean\n  //.\n  //. Returns `true` if the given integer is odd; `false` if it is even.\n  //.\n  //. ```javascript\n  //. > S.odd (99)\n  //. true\n  //.\n  //. > S.odd (42)\n  //. false\n  //. ```\n  function odd(n) {\n    return n % 2 !== 0;\n  }\n  _.odd = {\n    consts: {},\n    types: [$.Integer, $.Boolean],\n    impl: odd\n  };\n\n  //. ### Parse\n\n  //# parseDate :: String -> Maybe ValidDate\n  //.\n  //. Takes a string `s` and returns `Just (new Date (s))` if `new Date (s)`\n  //. evaluates to a [`ValidDate`][ValidDate] value; Nothing otherwise.\n  //.\n  //. As noted in [#488][], this function's behaviour is unspecified for some\n  //. inputs! [MDN][date parsing] warns against using the `Date` constructor\n  //. to parse date strings:\n  //.\n  //. > __Note:__ parsing of date strings with the `Date` constructor […] is\n  //. > strongly discouraged due to browser differences and inconsistencies.\n  //. > Support for RFC 2822 format strings is by convention only. Support for\n  //. > ISO 8601 formats differs in that date-only strings (e.g. \"1970-01-01\")\n  //. > are treated as UTC, not local.\n  //.\n  //. ```javascript\n  //. > S.parseDate ('2011-01-19T17:40:00Z')\n  //. Just (new Date ('2011-01-19T17:40:00.000Z'))\n  //.\n  //. > S.parseDate ('today')\n  //. Nothing\n  //. ```\n  function parseDate(s) {\n    var date = new Date (s);\n    return isNaN (date.valueOf ()) ? Nothing : Just (date);\n  }\n  _.parseDate = {\n    consts: {},\n    types: [$.String, $.Maybe ($.ValidDate)],\n    impl: parseDate\n  };\n\n  //  requiredNonCapturingGroup :: Array String -> String\n  function requiredNonCapturingGroup(xs) {\n    return '(?:' + xs.join ('|') + ')';\n  }\n\n  //  optionalNonCapturingGroup :: Array String -> String\n  function optionalNonCapturingGroup(xs) {\n    return requiredNonCapturingGroup (xs) + '?';\n  }\n\n  //  validFloatRepr :: RegExp\n  var validFloatRepr = new RegExp (\n    '^' +                     // start-of-string anchor\n    '\\\\s*' +                  // any number of leading whitespace characters\n    '[+-]?' +                 // optional sign\n    requiredNonCapturingGroup ([\n      'Infinity',             // \"Infinity\"\n      'NaN',                  // \"NaN\"\n      requiredNonCapturingGroup ([\n        '[0-9]+',             // number\n        '[0-9]+[.][0-9]+',    // number with interior decimal point\n        '[0-9]+[.]',          // number with trailing decimal point\n        '[.][0-9]+'           // number with leading decimal point\n      ]) +\n      optionalNonCapturingGroup ([\n        '[Ee]' +              // \"E\" or \"e\"\n        '[+-]?' +             // optional sign\n        '[0-9]+'              // exponent\n      ])\n    ]) +\n    '\\\\s*' +                  // any number of trailing whitespace characters\n    '$'                       // end-of-string anchor\n  );\n\n  //# parseFloat :: String -> Maybe Number\n  //.\n  //. Takes a string and returns Just the number represented by the string\n  //. if it does in fact represent a number; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseFloat ('-123.45')\n  //. Just (-123.45)\n  //.\n  //. > S.parseFloat ('foo.bar')\n  //. Nothing\n  //. ```\n  function parseFloat_(s) {\n    return validFloatRepr.test (s) ? Just (parseFloat (s)) : Nothing;\n  }\n  _.parseFloat = {\n    consts: {},\n    types: [$.String, $.Maybe ($.Number)],\n    impl: parseFloat_\n  };\n\n  //  Radix :: Type\n  var Radix = $.NullaryType\n    ('Radix')\n    ('')\n    ([$.Integer])\n    (function(x) { return x >= 2 && x <= 36; });\n\n  //# parseInt :: Radix -> String -> Maybe Integer\n  //.\n  //. Takes a radix (an integer between 2 and 36 inclusive) and a string,\n  //. and returns Just the number represented by the string if it does in\n  //. fact represent a number in the base specified by the radix; Nothing\n  //. otherwise.\n  //.\n  //. This function is stricter than [`parseInt`][parseInt]: a string\n  //. is considered to represent an integer only if all its non-prefix\n  //. characters are members of the character set specified by the radix.\n  //.\n  //. ```javascript\n  //. > S.parseInt (10) ('-42')\n  //. Just (-42)\n  //.\n  //. > S.parseInt (16) ('0xFF')\n  //. Just (255)\n  //.\n  //. > S.parseInt (16) ('0xGG')\n  //. Nothing\n  //. ```\n  function parseInt_(radix) {\n    return function(s) {\n      var charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice (0, radix);\n      var pattern = new RegExp ('^[' + charset + ']+$', 'i');\n\n      var t = s.replace (/^[+-]/, '');\n      if (pattern.test (radix === 16 ? t.replace (/^0x/i, '') : t)) {\n        var n = parseInt (s, radix);\n        if ($.test ([]) ($.Integer) (n)) return Just (n);\n      }\n      return Nothing;\n    };\n  }\n  _.parseInt = {\n    consts: {},\n    types: [Radix, $.String, $.Maybe ($.Integer)],\n    impl: parseInt_\n  };\n\n  //# parseJson :: (Any -> Boolean) -> String -> Maybe a\n  //.\n  //. Takes a predicate and a string that may or may not be valid JSON, and\n  //. returns Just the result of applying `JSON.parse` to the string *if* the\n  //. result satisfies the predicate; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[')\n  //. Nothing\n  //.\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[\"1\",\"2\",\"3\"]')\n  //. Nothing\n  //.\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[0,1.5,3,4.5]')\n  //. Nothing\n  //.\n  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[1,2,3]')\n  //. Just ([1, 2, 3])\n  //. ```\n  function parseJson(pred) {\n    return B (filter (pred)) (B (eitherToMaybe) (encase (JSON.parse)));\n  }\n  _.parseJson = {\n    consts: {},\n    types: [$.Predicate ($.Any), $.String, $.Maybe (a)],\n    impl: parseJson\n  };\n\n  //. ### RegExp\n\n  //  Match :: Type\n  var Match = $.RecordType ({\n    match: $.String,\n    groups: $.Array ($.Maybe ($.String))\n  });\n\n  //  toMatch :: Array String? -> Match\n  function toMatch(ss) {\n    return {\n      match: ss[0],\n      groups: Z.map (B (reject (equals (undefined))) (Just), ss.slice (1))\n    };\n  }\n\n  //  withRegex :: (RegExp, () -> a) -> a\n  function withRegex(pattern, thunk) {\n    var lastIndex = pattern.lastIndex;\n    var result = thunk ();\n    pattern.lastIndex = lastIndex;\n    return result;\n  }\n\n  //# regex :: RegexFlags -> String -> RegExp\n  //.\n  //. Takes a [RegexFlags][] and a pattern, and returns a RegExp.\n  //.\n  //. ```javascript\n  //. > S.regex ('g') (':\\\\d+:')\n  //. /:\\d+:/g\n  //. ```\n  function regex(flags) {\n    return function(source) {\n      return new RegExp (source, flags);\n    };\n  }\n  _.regex = {\n    consts: {},\n    types: [$.RegexFlags, $.String, $.RegExp],\n    impl: regex\n  };\n\n  //# regexEscape :: String -> String\n  //.\n  //. Takes a string that may contain regular expression metacharacters,\n  //. and returns a string with those metacharacters escaped.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String.\n  //.      S.test (S.regex ('') (S.regexEscape (s))) (s) = true`\n  //.\n  //. ```javascript\n  //. > S.regexEscape ('-=*{XYZ}*=-')\n  //. '\\\\-=\\\\*\\\\{XYZ\\\\}\\\\*=\\\\-'\n  //. ```\n  function regexEscape(s) {\n    return s.replace (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n  }\n  _.regexEscape = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: regexEscape\n  };\n\n  //# test :: RegExp -> String -> Boolean\n  //.\n  //. Takes a pattern and a string, and returns `true` [iff][] the pattern\n  //. matches the string.\n  //.\n  //. ```javascript\n  //. > S.test (/^a/) ('abacus')\n  //. true\n  //.\n  //. > S.test (/^a/) ('banana')\n  //. false\n  //. ```\n  function test(pattern) {\n    return function(s) {\n      return withRegex (pattern, function() { return pattern.test (s); });\n    };\n  }\n  _.test = {\n    consts: {},\n    types: [$.RegExp, $.String, $.Boolean],\n    impl: test\n  };\n\n  //# match :: NonGlobalRegExp -> String -> Maybe { match :: String, groups :: Array (Maybe String) }\n  //.\n  //. Takes a pattern and a string, and returns Just a match record if the\n  //. pattern matches the string; Nothing otherwise.\n  //.\n  //. `groups :: Array (Maybe String)` acknowledges the existence of optional\n  //. capturing groups.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall p :: Pattern, s :: String.\n  //.      S.head (S.matchAll (S.regex ('g') (p)) (s))\n  //.      = S.match (S.regex ('') (p)) (s)`\n  //.\n  //. See also [`matchAll`](#matchAll).\n  //.\n  //. ```javascript\n  //. > S.match (/(good)?bye/) ('goodbye')\n  //. Just ({match: 'goodbye', groups: [Just ('good')]})\n  //.\n  //. > S.match (/(good)?bye/) ('bye')\n  //. Just ({match: 'bye', groups: [Nothing]})\n  //. ```\n  function match(pattern) {\n    return function(s) {\n      return Z.map (toMatch,\n                    Z.reject (equals (null), Just (s.match (pattern))));\n    };\n  }\n  _.match = {\n    consts: {},\n    types: [$.NonGlobalRegExp, $.String, $.Maybe (Match)],\n    impl: match\n  };\n\n  //# matchAll :: GlobalRegExp -> String -> Array { match :: String, groups :: Array (Maybe String) }\n  //.\n  //. Takes a pattern and a string, and returns an array of match records.\n  //.\n  //. `groups :: Array (Maybe String)` acknowledges the existence of optional\n  //. capturing groups.\n  //.\n  //. See also [`match`](#match).\n  //.\n  //. ```javascript\n  //. > S.matchAll (/@([a-z]+)/g) ('Hello, world!')\n  //. []\n  //.\n  //. > S.matchAll (/@([a-z]+)/g) ('Hello, @foo! Hello, @bar! Hello, @baz!')\n  //. [ {match: '@foo', groups: [Just ('foo')]},\n  //. . {match: '@bar', groups: [Just ('bar')]},\n  //. . {match: '@baz', groups: [Just ('baz')]} ]\n  //. ```\n  function matchAll(pattern) {\n    return function(s) {\n      return withRegex (pattern, function() {\n        return unfoldr (function(_) {\n          return Z.map (function(ss) {\n            return Pair (toMatch (ss)) (null);\n          }, Z.reject (equals (null), Just (pattern.exec (s))));\n        }) ([]);\n      });\n    };\n  }\n  _.matchAll = {\n    consts: {},\n    types: [$.GlobalRegExp, $.String, $.Array (Match)],\n    impl: matchAll\n  };\n\n  //. ### String\n\n  //# toUpper :: String -> String\n  //.\n  //. Returns the upper-case equivalent of its argument.\n  //.\n  //. See also [`toLower`](#toLower).\n  //.\n  //. ```javascript\n  //. > S.toUpper ('ABC def 123')\n  //. 'ABC DEF 123'\n  //. ```\n  _.toUpper = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: invoke0 ('toUpperCase')\n  };\n\n  //# toLower :: String -> String\n  //.\n  //. Returns the lower-case equivalent of its argument.\n  //.\n  //. See also [`toUpper`](#toUpper).\n  //.\n  //. ```javascript\n  //. > S.toLower ('ABC def 123')\n  //. 'abc def 123'\n  //. ```\n  _.toLower = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: invoke0 ('toLowerCase')\n  };\n\n  //# trim :: String -> String\n  //.\n  //. Strips leading and trailing whitespace characters.\n  //.\n  //. ```javascript\n  //. > S.trim ('\\t\\t foo bar \\n')\n  //. 'foo bar'\n  //. ```\n  _.trim = {\n    consts: {},\n    types: [$.String, $.String],\n    impl: invoke0 ('trim')\n  };\n\n  //# stripPrefix :: String -> String -> Maybe String\n  //.\n  //. Returns Just the portion of the given string (the second argument) left\n  //. after removing the given prefix (the first argument) if the string starts\n  //. with the prefix; Nothing otherwise.\n  //.\n  //. See also [`stripSuffix`](#stripSuffix).\n  //.\n  //. ```javascript\n  //. > S.stripPrefix ('https://') ('https://sanctuary.js.org')\n  //. Just ('sanctuary.js.org')\n  //.\n  //. > S.stripPrefix ('https://') ('http://sanctuary.js.org')\n  //. Nothing\n  //. ```\n  function stripPrefix(prefix) {\n    return function(s) {\n      var idx = prefix.length;\n      return s.slice (0, idx) === prefix ? Just (s.slice (idx)) : Nothing;\n    };\n  }\n  _.stripPrefix = {\n    consts: {},\n    types: [$.String, $.String, $.Maybe ($.String)],\n    impl: stripPrefix\n  };\n\n  //# stripSuffix :: String -> String -> Maybe String\n  //.\n  //. Returns Just the portion of the given string (the second argument) left\n  //. after removing the given suffix (the first argument) if the string ends\n  //. with the suffix; Nothing otherwise.\n  //.\n  //. See also [`stripPrefix`](#stripPrefix).\n  //.\n  //. ```javascript\n  //. > S.stripSuffix ('.md') ('README.md')\n  //. Just ('README')\n  //.\n  //. > S.stripSuffix ('.md') ('README')\n  //. Nothing\n  //. ```\n  function stripSuffix(suffix) {\n    return function(s) {\n      var idx = s.length - suffix.length;  // value may be negative\n      return s.slice (idx) === suffix ? Just (s.slice (0, idx)) : Nothing;\n    };\n  }\n  _.stripSuffix = {\n    consts: {},\n    types: [$.String, $.String, $.Maybe ($.String)],\n    impl: stripSuffix\n  };\n\n  //# words :: String -> Array String\n  //.\n  //. Takes a string and returns the array of words the string contains\n  //. (words are delimited by whitespace characters).\n  //.\n  //. See also [`unwords`](#unwords).\n  //.\n  //. ```javascript\n  //. > S.words (' foo bar baz ')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function words(s) {\n    var words = s.split (/\\s+/);\n    var len = words.length;\n    return words.slice (words[0] === '' ? 1 : 0,\n                        words[len - 1] === '' ? len - 1 : len);\n  }\n  _.words = {\n    consts: {},\n    types: [$.String, $.Array ($.String)],\n    impl: words\n  };\n\n  //# unwords :: Array String -> String\n  //.\n  //. Takes an array of words and returns the result of joining the words\n  //. with separating spaces.\n  //.\n  //. See also [`words`](#words).\n  //.\n  //. ```javascript\n  //. > S.unwords (['foo', 'bar', 'baz'])\n  //. 'foo bar baz'\n  //. ```\n  _.unwords = {\n    consts: {},\n    types: [$.Array ($.String), $.String],\n    impl: invoke1 ('join') (' ')\n  };\n\n  //# lines :: String -> Array String\n  //.\n  //. Takes a string and returns the array of lines the string contains\n  //. (lines are delimited by newlines: `'\\n'` or `'\\r\\n'` or `'\\r'`).\n  //. The resulting strings do not contain newlines.\n  //.\n  //. See also [`unlines`](#unlines).\n  //.\n  //. ```javascript\n  //. > S.lines ('foo\\nbar\\nbaz\\n')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function lines(s) {\n    return s === '' ? []\n                    : (s.replace (/\\r\\n?/g, '\\n')).match (/^(?=[\\s\\S]).*/gm);\n  }\n  _.lines = {\n    consts: {},\n    types: [$.String, $.Array ($.String)],\n    impl: lines\n  };\n\n  //# unlines :: Array String -> String\n  //.\n  //. Takes an array of lines and returns the result of joining the lines\n  //. after appending a terminating line feed (`'\\n'`) to each.\n  //.\n  //. See also [`lines`](#lines).\n  //.\n  //. ```javascript\n  //. > S.unlines (['foo', 'bar', 'baz'])\n  //. 'foo\\nbar\\nbaz\\n'\n  //. ```\n  function unlines(xs) {\n    return xs.reduce (function(s, x) { return s + x + '\\n'; }, '');\n  }\n  _.unlines = {\n    consts: {},\n    types: [$.Array ($.String), $.String],\n    impl: unlines\n  };\n\n  //# splitOn :: String -> String -> Array String\n  //.\n  //. Returns the substrings of its second argument separated by occurrences\n  //. of its first argument.\n  //.\n  //. See also [`joinWith`](#joinWith) and [`splitOnRegex`](#splitOnRegex).\n  //.\n  //. ```javascript\n  //. > S.splitOn ('::') ('foo::bar::baz')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  _.splitOn = {\n    consts: {},\n    types: [$.String, $.String, $.Array ($.String)],\n    impl: invoke1 ('split')\n  };\n\n  //# splitOnRegex :: GlobalRegExp -> String -> Array String\n  //.\n  //. Takes a pattern and a string, and returns the result of splitting the\n  //. string at every non-overlapping occurrence of the pattern.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String, t :: String.\n  //.      S.joinWith (s)\n  //.                 (S.splitOnRegex (S.regex ('g') (S.regexEscape (s))) (t))\n  //.      = t`\n  //.\n  //. See also [`splitOn`](#splitOn).\n  //.\n  //. ```javascript\n  //. > S.splitOnRegex (/[,;][ ]*/g) ('foo, bar, baz')\n  //. ['foo', 'bar', 'baz']\n  //.\n  //. > S.splitOnRegex (/[,;][ ]*/g) ('foo;bar;baz')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function splitOnRegex(pattern) {\n    return function(s) {\n      return withRegex (pattern, function() {\n        var result = [];\n        var lastIndex = 0;\n        var match;\n        while ((match = pattern.exec (s)) != null) {\n          if (pattern.lastIndex === lastIndex && match[0] === '') {\n            if (pattern.lastIndex === s.length) return result;\n            pattern.lastIndex += 1;\n          } else {\n            result.push (s.slice (lastIndex, match.index));\n            lastIndex = match.index + match[0].length;\n          }\n        }\n        result.push (s.slice (lastIndex));\n        return result;\n      });\n    };\n  }\n  _.splitOnRegex = {\n    consts: {},\n    types: [$.GlobalRegExp, $.String, $.Array ($.String)],\n    impl: splitOnRegex\n  };\n\n  return create ({\n    checkTypes: typeof process === 'undefined'\n                || process == null\n                || process.env == null\n                || process.env.NODE_ENV !== 'production',\n    env: $.env\n  });\n\n}));\n\n//. [#438]:                     https://github.com/sanctuary-js/sanctuary/issues/438\n//. [#488]:                     https://github.com/sanctuary-js/sanctuary/issues/488\n//. [Apply]:                    v:fantasyland/fantasy-land#apply\n//. [Chain]:                    v:fantasyland/fantasy-land#chain\n//. [Either]:                   #either-type\n//. [Fantasy Land]:             v:fantasyland/fantasy-land\n//. [Foldable]:                 v:fantasyland/fantasy-land#foldable\n//. [Folktale]:                 https://folktale.origamitower.com/\n//. [GIGO]:                     https://en.wikipedia.org/wiki/Garbage_in,_garbage_out\n//. [Haskell]:                  https://www.haskell.org/\n//. [Kleisli]:                  https://en.wikipedia.org/wiki/Kleisli_category\n//. [Maybe]:                    #maybe-type\n//. [Nullable]:                 v:sanctuary-js/sanctuary-def#Nullable\n//. [PureScript]:               http://www.purescript.org/\n//. [Ramda]:                    http://ramdajs.com/\n//. [RegexFlags]:               v:sanctuary-js/sanctuary-def#RegexFlags\n//. [Semigroupoid]:             v:fantasyland/fantasy-land#semigroupoid\n//. [ValidDate]:                v:sanctuary-js/sanctuary-def#ValidDate\n//. [`$.test`]:                 v:sanctuary-js/sanctuary-def#test\n//. [`Descending`]:             v:sanctuary-js/sanctuary-descending#Descending\n//. [`R.__`]:                   http://ramdajs.com/docs/#__\n//. [`R.bind`]:                 http://ramdajs.com/docs/#bind\n//. [`R.invoker`]:              http://ramdajs.com/docs/#invoker\n//. [`Z.alt`]:                  v:sanctuary-js/sanctuary-type-classes#alt\n//. [`Z.ap`]:                   v:sanctuary-js/sanctuary-type-classes#ap\n//. [`Z.apFirst`]:              v:sanctuary-js/sanctuary-type-classes#apFirst\n//. [`Z.apSecond`]:             v:sanctuary-js/sanctuary-type-classes#apSecond\n//. [`Z.bimap`]:                v:sanctuary-js/sanctuary-type-classes#bimap\n//. [`Z.chain`]:                v:sanctuary-js/sanctuary-type-classes#chain\n//. [`Z.chainRec`]:             v:sanctuary-js/sanctuary-type-classes#chainRec\n//. [`Z.compose`]:              v:sanctuary-js/sanctuary-type-classes#compose\n//. [`Z.concat`]:               v:sanctuary-js/sanctuary-type-classes#concat\n//. [`Z.contramap`]:            v:sanctuary-js/sanctuary-type-classes#contramap\n//. [`Z.duplicate`]:            v:sanctuary-js/sanctuary-type-classes#duplicate\n//. [`Z.empty`]:                v:sanctuary-js/sanctuary-type-classes#empty\n//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals\n//. [`Z.extend`]:               v:sanctuary-js/sanctuary-type-classes#extend\n//. [`Z.extract`]:              v:sanctuary-js/sanctuary-type-classes#extract\n//. [`Z.filter`]:               v:sanctuary-js/sanctuary-type-classes#filter\n//. [`Z.flip`]:                 v:sanctuary-js/sanctuary-type-classes#flip\n//. [`Z.foldMap`]:              v:sanctuary-js/sanctuary-type-classes#foldMap\n//. [`Z.gt`]:                   v:sanctuary-js/sanctuary-type-classes#gt\n//. [`Z.gte`]:                  v:sanctuary-js/sanctuary-type-classes#gte\n//. [`Z.id`]:                   v:sanctuary-js/sanctuary-type-classes#id\n//. [`Z.invert`]:               v:sanctuary-js/sanctuary-type-classes#invert\n//. [`Z.join`]:                 v:sanctuary-js/sanctuary-type-classes#join\n//. [`Z.lt`]:                   v:sanctuary-js/sanctuary-type-classes#lt\n//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte\n//. [`Z.map`]:                  v:sanctuary-js/sanctuary-type-classes#map\n//. [`Z.mapLeft`]:              v:sanctuary-js/sanctuary-type-classes#mapLeft\n//. [`Z.of`]:                   v:sanctuary-js/sanctuary-type-classes#of\n//. [`Z.promap`]:               v:sanctuary-js/sanctuary-type-classes#promap\n//. [`Z.reject`]:               v:sanctuary-js/sanctuary-type-classes#reject\n//. [`Z.sequence`]:             v:sanctuary-js/sanctuary-type-classes#sequence\n//. [`Z.traverse`]:             v:sanctuary-js/sanctuary-type-classes#traverse\n//. [`Z.zero`]:                 v:sanctuary-js/sanctuary-type-classes#zero\n//. [`show`]:                   v:sanctuary-js/sanctuary-show#show\n//. [date parsing]:             https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date\n//. [equivalence]:              https://en.wikipedia.org/wiki/Equivalence_relation\n//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if\n//. [parseInt]:                 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n//. [partial functions]:        https://en.wikipedia.org/wiki/Partial_function\n//. [ramda/ramda#683]:          https://github.com/ramda/ramda/issues/683\n//. [ramda/ramda#1413]:         https://github.com/ramda/ramda/issues/1413\n//. [ramda/ramda#1419]:         https://github.com/ramda/ramda/pull/1419\n//. [sanctuary-def]:            v:sanctuary-js/sanctuary-def\n//. [sanctuary-either]:         v:sanctuary-js/sanctuary-either\n//. [sanctuary-maybe]:          v:sanctuary-js/sanctuary-maybe\n//. [sanctuary-pair]:           v:sanctuary-js/sanctuary-pair\n//. [sanctuary-show]:           v:sanctuary-js/sanctuary-show\n//. [sanctuary-type-classes]:   v:sanctuary-js/sanctuary-type-classes\n//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [thrush]:                   https://github.com/raganwald-deprecated/homoiconic/blob/master/2008-10-30/thrush.markdown\n//. [total functions]:          https://en.wikipedia.org/wiki/Partial_function#Total_function\n//. [type checking]:            #type-checking\n//. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers\n//. [type representative]:      v:fantasyland/fantasy-land#type-representatives\n//. [variadic functions]:       https://en.wikipedia.org/wiki/Variadic_function\n});\n\nvar BigInteger = createCommonjsModule(function (module) {\nvar bigInt = (function (undefined$1) {\r\n\r\n    var BASE = 1e7,\r\n        LOG_BASE = 7,\r\n        MAX_INT = 9007199254740992,\r\n        MAX_INT_ARR = smallToArray(MAX_INT),\r\n        DEFAULT_ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\";\r\n\r\n    var supportsNativeBigInt = typeof BigInt === \"function\";\r\n\r\n    function Integer(v, radix, alphabet, caseSensitive) {\r\n        if (typeof v === \"undefined\") return Integer[0];\r\n        if (typeof radix !== \"undefined\") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);\r\n        return parseValue(v);\r\n    }\r\n\r\n    function BigInteger(value, sign) {\r\n        this.value = value;\r\n        this.sign = sign;\r\n        this.isSmall = false;\r\n    }\r\n    BigInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function SmallInteger(value) {\r\n        this.value = value;\r\n        this.sign = value < 0;\r\n        this.isSmall = true;\r\n    }\r\n    SmallInteger.prototype = Object.create(Integer.prototype);\r\n\r\n    function NativeBigInt(value) {\r\n        this.value = value;\r\n    }\r\n    NativeBigInt.prototype = Object.create(Integer.prototype);\r\n\r\n    function isPrecise(n) {\r\n        return -MAX_INT < n && n < MAX_INT;\r\n    }\r\n\r\n    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes\r\n        if (n < 1e7)\r\n            return [n];\r\n        if (n < 1e14)\r\n            return [n % 1e7, Math.floor(n / 1e7)];\r\n        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];\r\n    }\r\n\r\n    function arrayToSmall(arr) { // If BASE changes this function may need to change\r\n        trim(arr);\r\n        var length = arr.length;\r\n        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {\r\n            switch (length) {\r\n                case 0: return 0;\r\n                case 1: return arr[0];\r\n                case 2: return arr[0] + arr[1] * BASE;\r\n                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    function trim(v) {\r\n        var i = v.length;\r\n        while (v[--i] === 0);\r\n        v.length = i + 1;\r\n    }\r\n\r\n    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger\r\n        var x = new Array(length);\r\n        var i = -1;\r\n        while (++i < length) {\r\n            x[i] = 0;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    function truncate(n) {\r\n        if (n > 0) return Math.floor(n);\r\n        return Math.ceil(n);\r\n    }\r\n\r\n    function add(a, b) { // assumes a and b are arrays with a.length >= b.length\r\n        var l_a = a.length,\r\n            l_b = b.length,\r\n            r = new Array(l_a),\r\n            carry = 0,\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l_b; i++) {\r\n            sum = a[i] + b[i] + carry;\r\n            carry = sum >= base ? 1 : 0;\r\n            r[i] = sum - carry * base;\r\n        }\r\n        while (i < l_a) {\r\n            sum = a[i] + carry;\r\n            carry = sum === base ? 1 : 0;\r\n            r[i++] = sum - carry * base;\r\n        }\r\n        if (carry > 0) r.push(carry);\r\n        return r;\r\n    }\r\n\r\n    function addAny(a, b) {\r\n        if (a.length >= b.length) return add(a, b);\r\n        return add(b, a);\r\n    }\r\n\r\n    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            sum, i;\r\n        for (i = 0; i < l; i++) {\r\n            sum = a[i] - base + carry;\r\n            carry = Math.floor(sum / base);\r\n            r[i] = sum - carry * base;\r\n            carry += 1;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall) {\r\n            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);\r\n        }\r\n        return new BigInteger(addAny(a, b), this.sign);\r\n    };\r\n    BigInteger.prototype.plus = BigInteger.prototype.add;\r\n\r\n    SmallInteger.prototype.add = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.subtract(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            if (isPrecise(a + b)) return new SmallInteger(a + b);\r\n            b = smallToArray(Math.abs(b));\r\n        }\r\n        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);\r\n    };\r\n    SmallInteger.prototype.plus = SmallInteger.prototype.add;\r\n\r\n    NativeBigInt.prototype.add = function (v) {\r\n        return new NativeBigInt(this.value + parseValue(v).value);\r\n    };\r\n    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;\r\n\r\n    function subtract(a, b) { // assumes a and b are arrays with a >= b\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            r = new Array(a_l),\r\n            borrow = 0,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < b_l; i++) {\r\n            difference = a[i] - borrow - b[i];\r\n            if (difference < 0) {\r\n                difference += base;\r\n                borrow = 1;\r\n            } else borrow = 0;\r\n            r[i] = difference;\r\n        }\r\n        for (i = b_l; i < a_l; i++) {\r\n            difference = a[i] - borrow;\r\n            if (difference < 0) difference += base;\r\n            else {\r\n                r[i++] = difference;\r\n                break;\r\n            }\r\n            r[i] = difference;\r\n        }\r\n        for (; i < a_l; i++) {\r\n            r[i] = a[i];\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function subtractAny(a, b, sign) {\r\n        var value;\r\n        if (compareAbs(a, b) >= 0) {\r\n            value = subtract(a, b);\r\n        } else {\r\n            value = subtract(b, a);\r\n            sign = !sign;\r\n        }\r\n        value = arrayToSmall(value);\r\n        if (typeof value === \"number\") {\r\n            if (sign) value = -value;\r\n            return new SmallInteger(value);\r\n        }\r\n        return new BigInteger(value, sign);\r\n    }\r\n\r\n    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            carry = -b,\r\n            base = BASE,\r\n            i, difference;\r\n        for (i = 0; i < l; i++) {\r\n            difference = a[i] + carry;\r\n            carry = Math.floor(difference / base);\r\n            difference %= base;\r\n            r[i] = difference < 0 ? difference + base : difference;\r\n        }\r\n        r = arrayToSmall(r);\r\n        if (typeof r === \"number\") {\r\n            if (sign) r = -r;\r\n            return new SmallInteger(r);\r\n        } return new BigInteger(r, sign);\r\n    }\r\n\r\n    BigInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        if (this.sign !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var a = this.value, b = n.value;\r\n        if (n.isSmall)\r\n            return subtractSmall(a, Math.abs(b), this.sign);\r\n        return subtractAny(a, b, this.sign);\r\n    };\r\n    BigInteger.prototype.minus = BigInteger.prototype.subtract;\r\n\r\n    SmallInteger.prototype.subtract = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value;\r\n        if (a < 0 !== n.sign) {\r\n            return this.add(n.negate());\r\n        }\r\n        var b = n.value;\r\n        if (n.isSmall) {\r\n            return new SmallInteger(a - b);\r\n        }\r\n        return subtractSmall(b, Math.abs(a), a >= 0);\r\n    };\r\n    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;\r\n\r\n    NativeBigInt.prototype.subtract = function (v) {\r\n        return new NativeBigInt(this.value - parseValue(v).value);\r\n    };\r\n    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;\r\n\r\n    BigInteger.prototype.negate = function () {\r\n        return new BigInteger(this.value, !this.sign);\r\n    };\r\n    SmallInteger.prototype.negate = function () {\r\n        var sign = this.sign;\r\n        var small = new SmallInteger(-this.value);\r\n        small.sign = !sign;\r\n        return small;\r\n    };\r\n    NativeBigInt.prototype.negate = function () {\r\n        return new NativeBigInt(-this.value);\r\n    };\r\n\r\n    BigInteger.prototype.abs = function () {\r\n        return new BigInteger(this.value, false);\r\n    };\r\n    SmallInteger.prototype.abs = function () {\r\n        return new SmallInteger(Math.abs(this.value));\r\n    };\r\n    NativeBigInt.prototype.abs = function () {\r\n        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);\r\n    };\r\n\r\n\r\n    function multiplyLong(a, b) {\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            l = a_l + b_l,\r\n            r = createArray(l),\r\n            base = BASE,\r\n            product, carry, i, a_i, b_j;\r\n        for (i = 0; i < a_l; ++i) {\r\n            a_i = a[i];\r\n            for (var j = 0; j < b_l; ++j) {\r\n                b_j = b[j];\r\n                product = a_i * b_j + r[i + j];\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n                r[i + j + 1] += carry;\r\n            }\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE\r\n        var l = a.length,\r\n            r = new Array(l),\r\n            base = BASE,\r\n            carry = 0,\r\n            product, i;\r\n        for (i = 0; i < l; i++) {\r\n            product = a[i] * b + carry;\r\n            carry = Math.floor(product / base);\r\n            r[i] = product - carry * base;\r\n        }\r\n        while (carry > 0) {\r\n            r[i++] = carry % base;\r\n            carry = Math.floor(carry / base);\r\n        }\r\n        return r;\r\n    }\r\n\r\n    function shiftLeft(x, n) {\r\n        var r = [];\r\n        while (n-- > 0) r.push(0);\r\n        return r.concat(x);\r\n    }\r\n\r\n    function multiplyKaratsuba(x, y) {\r\n        var n = Math.max(x.length, y.length);\r\n\r\n        if (n <= 30) return multiplyLong(x, y);\r\n        n = Math.ceil(n / 2);\r\n\r\n        var b = x.slice(n),\r\n            a = x.slice(0, n),\r\n            d = y.slice(n),\r\n            c = y.slice(0, n);\r\n\r\n        var ac = multiplyKaratsuba(a, c),\r\n            bd = multiplyKaratsuba(b, d),\r\n            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));\r\n\r\n        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));\r\n        trim(product);\r\n        return product;\r\n    }\r\n\r\n    // The following function is derived from a surface fit of a graph plotting the performance difference\r\n    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.\r\n    function useKaratsuba(l1, l2) {\r\n        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;\r\n    }\r\n\r\n    BigInteger.prototype.multiply = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value, b = n.value,\r\n            sign = this.sign !== n.sign,\r\n            abs;\r\n        if (n.isSmall) {\r\n            if (b === 0) return Integer[0];\r\n            if (b === 1) return this;\r\n            if (b === -1) return this.negate();\r\n            abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                return new BigInteger(multiplySmall(a, abs), sign);\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes\r\n            return new BigInteger(multiplyKaratsuba(a, b), sign);\r\n        return new BigInteger(multiplyLong(a, b), sign);\r\n    };\r\n\r\n    BigInteger.prototype.times = BigInteger.prototype.multiply;\r\n\r\n    function multiplySmallAndArray(a, b, sign) { // a >= 0\r\n        if (a < BASE) {\r\n            return new BigInteger(multiplySmall(b, a), sign);\r\n        }\r\n        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);\r\n    }\r\n    SmallInteger.prototype._multiplyBySmall = function (a) {\r\n        if (isPrecise(a.value * this.value)) {\r\n            return new SmallInteger(a.value * this.value);\r\n        }\r\n        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);\r\n    };\r\n    BigInteger.prototype._multiplyBySmall = function (a) {\r\n        if (a.value === 0) return Integer[0];\r\n        if (a.value === 1) return this;\r\n        if (a.value === -1) return this.negate();\r\n        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);\r\n    };\r\n    SmallInteger.prototype.multiply = function (v) {\r\n        return parseValue(v)._multiplyBySmall(this);\r\n    };\r\n    SmallInteger.prototype.times = SmallInteger.prototype.multiply;\r\n\r\n    NativeBigInt.prototype.multiply = function (v) {\r\n        return new NativeBigInt(this.value * parseValue(v).value);\r\n    };\r\n    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;\r\n\r\n    function square(a) {\r\n        //console.assert(2 * BASE * BASE < MAX_INT);\r\n        var l = a.length,\r\n            r = createArray(l + l),\r\n            base = BASE,\r\n            product, carry, i, a_i, a_j;\r\n        for (i = 0; i < l; i++) {\r\n            a_i = a[i];\r\n            carry = 0 - a_i * a_i;\r\n            for (var j = i; j < l; j++) {\r\n                a_j = a[j];\r\n                product = 2 * (a_i * a_j) + r[i + j] + carry;\r\n                carry = Math.floor(product / base);\r\n                r[i + j] = product - carry * base;\r\n            }\r\n            r[i + l] = carry;\r\n        }\r\n        trim(r);\r\n        return r;\r\n    }\r\n\r\n    BigInteger.prototype.square = function () {\r\n        return new BigInteger(square(this.value), false);\r\n    };\r\n\r\n    SmallInteger.prototype.square = function () {\r\n        var value = this.value * this.value;\r\n        if (isPrecise(value)) return new SmallInteger(value);\r\n        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);\r\n    };\r\n\r\n    NativeBigInt.prototype.square = function (v) {\r\n        return new NativeBigInt(this.value * this.value);\r\n    };\r\n\r\n    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            base = BASE,\r\n            result = createArray(b.length),\r\n            divisorMostSignificantDigit = b[b_l - 1],\r\n            // normalization\r\n            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),\r\n            remainder = multiplySmall(a, lambda),\r\n            divisor = multiplySmall(b, lambda),\r\n            quotientDigit, shift, carry, borrow, i, l, q;\r\n        if (remainder.length <= a_l) remainder.push(0);\r\n        divisor.push(0);\r\n        divisorMostSignificantDigit = divisor[b_l - 1];\r\n        for (shift = a_l - b_l; shift >= 0; shift--) {\r\n            quotientDigit = base - 1;\r\n            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {\r\n                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);\r\n            }\r\n            // quotientDigit <= base - 1\r\n            carry = 0;\r\n            borrow = 0;\r\n            l = divisor.length;\r\n            for (i = 0; i < l; i++) {\r\n                carry += quotientDigit * divisor[i];\r\n                q = Math.floor(carry / base);\r\n                borrow += remainder[shift + i] - (carry - q * base);\r\n                carry = q;\r\n                if (borrow < 0) {\r\n                    remainder[shift + i] = borrow + base;\r\n                    borrow = -1;\r\n                } else {\r\n                    remainder[shift + i] = borrow;\r\n                    borrow = 0;\r\n                }\r\n            }\r\n            while (borrow !== 0) {\r\n                quotientDigit -= 1;\r\n                carry = 0;\r\n                for (i = 0; i < l; i++) {\r\n                    carry += remainder[shift + i] - base + divisor[i];\r\n                    if (carry < 0) {\r\n                        remainder[shift + i] = carry + base;\r\n                        carry = 0;\r\n                    } else {\r\n                        remainder[shift + i] = carry;\r\n                        carry = 1;\r\n                    }\r\n                }\r\n                borrow += carry;\r\n            }\r\n            result[shift] = quotientDigit;\r\n        }\r\n        // denormalization\r\n        remainder = divModSmall(remainder, lambda)[0];\r\n        return [arrayToSmall(result), arrayToSmall(remainder)];\r\n    }\r\n\r\n    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/\r\n        // Performs faster than divMod1 on larger input sizes.\r\n        var a_l = a.length,\r\n            b_l = b.length,\r\n            result = [],\r\n            part = [],\r\n            base = BASE,\r\n            guess, xlen, highx, highy, check;\r\n        while (a_l) {\r\n            part.unshift(a[--a_l]);\r\n            trim(part);\r\n            if (compareAbs(part, b) < 0) {\r\n                result.push(0);\r\n                continue;\r\n            }\r\n            xlen = part.length;\r\n            highx = part[xlen - 1] * base + part[xlen - 2];\r\n            highy = b[b_l - 1] * base + b[b_l - 2];\r\n            if (xlen > b_l) {\r\n                highx = (highx + 1) * base;\r\n            }\r\n            guess = Math.ceil(highx / highy);\r\n            do {\r\n                check = multiplySmall(b, guess);\r\n                if (compareAbs(check, part) <= 0) break;\r\n                guess--;\r\n            } while (guess);\r\n            result.push(guess);\r\n            part = subtract(part, check);\r\n        }\r\n        result.reverse();\r\n        return [arrayToSmall(result), arrayToSmall(part)];\r\n    }\r\n\r\n    function divModSmall(value, lambda) {\r\n        var length = value.length,\r\n            quotient = createArray(length),\r\n            base = BASE,\r\n            i, q, remainder, divisor;\r\n        remainder = 0;\r\n        for (i = length - 1; i >= 0; --i) {\r\n            divisor = remainder * base + value[i];\r\n            q = truncate(divisor / lambda);\r\n            remainder = divisor - q * lambda;\r\n            quotient[i] = q | 0;\r\n        }\r\n        return [quotient, remainder | 0];\r\n    }\r\n\r\n    function divModAny(self, v) {\r\n        var value, n = parseValue(v);\r\n        if (supportsNativeBigInt) {\r\n            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];\r\n        }\r\n        var a = self.value, b = n.value;\r\n        var quotient;\r\n        if (b === 0) throw new Error(\"Cannot divide by zero\");\r\n        if (self.isSmall) {\r\n            if (n.isSmall) {\r\n                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];\r\n            }\r\n            return [Integer[0], self];\r\n        }\r\n        if (n.isSmall) {\r\n            if (b === 1) return [self, Integer[0]];\r\n            if (b == -1) return [self.negate(), Integer[0]];\r\n            var abs = Math.abs(b);\r\n            if (abs < BASE) {\r\n                value = divModSmall(a, abs);\r\n                quotient = arrayToSmall(value[0]);\r\n                var remainder = value[1];\r\n                if (self.sign) remainder = -remainder;\r\n                if (typeof quotient === \"number\") {\r\n                    if (self.sign !== n.sign) quotient = -quotient;\r\n                    return [new SmallInteger(quotient), new SmallInteger(remainder)];\r\n                }\r\n                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];\r\n            }\r\n            b = smallToArray(abs);\r\n        }\r\n        var comparison = compareAbs(a, b);\r\n        if (comparison === -1) return [Integer[0], self];\r\n        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];\r\n\r\n        // divMod1 is faster on smaller input sizes\r\n        if (a.length + b.length <= 200)\r\n            value = divMod1(a, b);\r\n        else value = divMod2(a, b);\r\n\r\n        quotient = value[0];\r\n        var qSign = self.sign !== n.sign,\r\n            mod = value[1],\r\n            mSign = self.sign;\r\n        if (typeof quotient === \"number\") {\r\n            if (qSign) quotient = -quotient;\r\n            quotient = new SmallInteger(quotient);\r\n        } else quotient = new BigInteger(quotient, qSign);\r\n        if (typeof mod === \"number\") {\r\n            if (mSign) mod = -mod;\r\n            mod = new SmallInteger(mod);\r\n        } else mod = new BigInteger(mod, mSign);\r\n        return [quotient, mod];\r\n    }\r\n\r\n    BigInteger.prototype.divmod = function (v) {\r\n        var result = divModAny(this, v);\r\n        return {\r\n            quotient: result[0],\r\n            remainder: result[1]\r\n        };\r\n    };\r\n    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;\r\n\r\n\r\n    BigInteger.prototype.divide = function (v) {\r\n        return divModAny(this, v)[0];\r\n    };\r\n    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {\r\n        return new NativeBigInt(this.value / parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;\r\n\r\n    BigInteger.prototype.mod = function (v) {\r\n        return divModAny(this, v)[1];\r\n    };\r\n    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {\r\n        return new NativeBigInt(this.value % parseValue(v).value);\r\n    };\r\n    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;\r\n\r\n    BigInteger.prototype.pow = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value,\r\n            value, x, y;\r\n        if (b === 0) return Integer[1];\r\n        if (a === 0) return Integer[0];\r\n        if (a === 1) return Integer[1];\r\n        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.sign) {\r\n            return Integer[0];\r\n        }\r\n        if (!n.isSmall) throw new Error(\"The exponent \" + n.toString() + \" is too large.\");\r\n        if (this.isSmall) {\r\n            if (isPrecise(value = Math.pow(a, b)))\r\n                return new SmallInteger(truncate(value));\r\n        }\r\n        x = this;\r\n        y = Integer[1];\r\n        while (true) {\r\n            if (b & 1 === 1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === 0) break;\r\n            b /= 2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n    SmallInteger.prototype.pow = BigInteger.prototype.pow;\r\n\r\n    NativeBigInt.prototype.pow = function (v) {\r\n        var n = parseValue(v);\r\n        var a = this.value, b = n.value;\r\n        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);\r\n        if (b === _0) return Integer[1];\r\n        if (a === _0) return Integer[0];\r\n        if (a === _1) return Integer[1];\r\n        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];\r\n        if (n.isNegative()) return new NativeBigInt(_0);\r\n        var x = this;\r\n        var y = Integer[1];\r\n        while (true) {\r\n            if ((b & _1) === _1) {\r\n                y = y.times(x);\r\n                --b;\r\n            }\r\n            if (b === _0) break;\r\n            b /= _2;\r\n            x = x.square();\r\n        }\r\n        return y;\r\n    };\r\n\r\n    BigInteger.prototype.modPow = function (exp, mod) {\r\n        exp = parseValue(exp);\r\n        mod = parseValue(mod);\r\n        if (mod.isZero()) throw new Error(\"Cannot take modPow with modulus 0\");\r\n        var r = Integer[1],\r\n            base = this.mod(mod);\r\n        if (exp.isNegative()) {\r\n            exp = exp.multiply(Integer[-1]);\r\n            base = base.modInv(mod);\r\n        }\r\n        while (exp.isPositive()) {\r\n            if (base.isZero()) return Integer[0];\r\n            if (exp.isOdd()) r = r.multiply(base).mod(mod);\r\n            exp = exp.divide(2);\r\n            base = base.square().mod(mod);\r\n        }\r\n        return r;\r\n    };\r\n    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;\r\n\r\n    function compareAbs(a, b) {\r\n        if (a.length !== b.length) {\r\n            return a.length > b.length ? 1 : -1;\r\n        }\r\n        for (var i = a.length - 1; i >= 0; i--) {\r\n            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    BigInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) return 1;\r\n        return compareAbs(a, b);\r\n    };\r\n    SmallInteger.prototype.compareAbs = function (v) {\r\n        var n = parseValue(v),\r\n            a = Math.abs(this.value),\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            b = Math.abs(b);\r\n            return a === b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        return -1;\r\n    };\r\n    NativeBigInt.prototype.compareAbs = function (v) {\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        a = a >= 0 ? a : -a;\r\n        b = b >= 0 ? b : -b;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    };\r\n\r\n    BigInteger.prototype.compare = function (v) {\r\n        // See discussion about comparison with Infinity:\r\n        // https://github.com/peterolson/BigInteger.js/issues/61\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (this.sign !== n.sign) {\r\n            return n.sign ? 1 : -1;\r\n        }\r\n        if (n.isSmall) {\r\n            return this.sign ? -1 : 1;\r\n        }\r\n        return compareAbs(a, b) * (this.sign ? -1 : 1);\r\n    };\r\n    BigInteger.prototype.compareTo = BigInteger.prototype.compare;\r\n\r\n    SmallInteger.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n\r\n        var n = parseValue(v),\r\n            a = this.value,\r\n            b = n.value;\r\n        if (n.isSmall) {\r\n            return a == b ? 0 : a > b ? 1 : -1;\r\n        }\r\n        if (a < 0 !== n.sign) {\r\n            return a < 0 ? -1 : 1;\r\n        }\r\n        return a < 0 ? 1 : -1;\r\n    };\r\n    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;\r\n\r\n    NativeBigInt.prototype.compare = function (v) {\r\n        if (v === Infinity) {\r\n            return -1;\r\n        }\r\n        if (v === -Infinity) {\r\n            return 1;\r\n        }\r\n        var a = this.value;\r\n        var b = parseValue(v).value;\r\n        return a === b ? 0 : a > b ? 1 : -1;\r\n    };\r\n    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;\r\n\r\n    BigInteger.prototype.equals = function (v) {\r\n        return this.compare(v) === 0;\r\n    };\r\n    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;\r\n\r\n    BigInteger.prototype.notEquals = function (v) {\r\n        return this.compare(v) !== 0;\r\n    };\r\n    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;\r\n\r\n    BigInteger.prototype.greater = function (v) {\r\n        return this.compare(v) > 0;\r\n    };\r\n    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;\r\n\r\n    BigInteger.prototype.lesser = function (v) {\r\n        return this.compare(v) < 0;\r\n    };\r\n    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;\r\n\r\n    BigInteger.prototype.greaterOrEquals = function (v) {\r\n        return this.compare(v) >= 0;\r\n    };\r\n    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;\r\n\r\n    BigInteger.prototype.lesserOrEquals = function (v) {\r\n        return this.compare(v) <= 0;\r\n    };\r\n    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;\r\n\r\n    BigInteger.prototype.isEven = function () {\r\n        return (this.value[0] & 1) === 0;\r\n    };\r\n    SmallInteger.prototype.isEven = function () {\r\n        return (this.value & 1) === 0;\r\n    };\r\n    NativeBigInt.prototype.isEven = function () {\r\n        return (this.value & BigInt(1)) === BigInt(0);\r\n    };\r\n\r\n    BigInteger.prototype.isOdd = function () {\r\n        return (this.value[0] & 1) === 1;\r\n    };\r\n    SmallInteger.prototype.isOdd = function () {\r\n        return (this.value & 1) === 1;\r\n    };\r\n    NativeBigInt.prototype.isOdd = function () {\r\n        return (this.value & BigInt(1)) === BigInt(1);\r\n    };\r\n\r\n    BigInteger.prototype.isPositive = function () {\r\n        return !this.sign;\r\n    };\r\n    SmallInteger.prototype.isPositive = function () {\r\n        return this.value > 0;\r\n    };\r\n    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;\r\n\r\n    BigInteger.prototype.isNegative = function () {\r\n        return this.sign;\r\n    };\r\n    SmallInteger.prototype.isNegative = function () {\r\n        return this.value < 0;\r\n    };\r\n    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;\r\n\r\n    BigInteger.prototype.isUnit = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isUnit = function () {\r\n        return Math.abs(this.value) === 1;\r\n    };\r\n    NativeBigInt.prototype.isUnit = function () {\r\n        return this.abs().value === BigInt(1);\r\n    };\r\n\r\n    BigInteger.prototype.isZero = function () {\r\n        return false;\r\n    };\r\n    SmallInteger.prototype.isZero = function () {\r\n        return this.value === 0;\r\n    };\r\n    NativeBigInt.prototype.isZero = function () {\r\n        return this.value === BigInt(0);\r\n    };\r\n\r\n    BigInteger.prototype.isDivisibleBy = function (v) {\r\n        var n = parseValue(v);\r\n        if (n.isZero()) return false;\r\n        if (n.isUnit()) return true;\r\n        if (n.compareAbs(2) === 0) return this.isEven();\r\n        return this.mod(n).isZero();\r\n    };\r\n    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;\r\n\r\n    function isBasicPrime(v) {\r\n        var n = v.abs();\r\n        if (n.isUnit()) return false;\r\n        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;\r\n        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;\r\n        if (n.lesser(49)) return true;\r\n        // we don't know if it's prime: let the other functions figure it out\r\n    }\r\n\r\n    function millerRabinTest(n, a) {\r\n        var nPrev = n.prev(),\r\n            b = nPrev,\r\n            r = 0,\r\n            d, i, x;\r\n        while (b.isEven()) b = b.divide(2), r++;\r\n        next: for (i = 0; i < a.length; i++) {\r\n            if (n.lesser(a[i])) continue;\r\n            x = bigInt(a[i]).modPow(b, n);\r\n            if (x.isUnit() || x.equals(nPrev)) continue;\r\n            for (d = r - 1; d != 0; d--) {\r\n                x = x.square().mod(n);\r\n                if (x.isUnit()) return false;\r\n                if (x.equals(nPrev)) continue next;\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // Set \"strict\" to true to force GRH-supported lower bound of 2*log(N)^2\r\n    BigInteger.prototype.isPrime = function (strict) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined$1) return isPrime;\r\n        var n = this.abs();\r\n        var bits = n.bitLength();\r\n        if (bits <= 64)\r\n            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);\r\n        var logN = Math.log(2) * bits.toJSNumber();\r\n        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt(i + 2));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;\r\n\r\n    BigInteger.prototype.isProbablePrime = function (iterations, rng) {\r\n        var isPrime = isBasicPrime(this);\r\n        if (isPrime !== undefined$1) return isPrime;\r\n        var n = this.abs();\r\n        var t = iterations === undefined$1 ? 5 : iterations;\r\n        for (var a = [], i = 0; i < t; i++) {\r\n            a.push(bigInt.randBetween(2, n.minus(2), rng));\r\n        }\r\n        return millerRabinTest(n, a);\r\n    };\r\n    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;\r\n\r\n    BigInteger.prototype.modInv = function (n) {\r\n        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;\r\n        while (!newR.isZero()) {\r\n            q = r.divide(newR);\r\n            lastT = t;\r\n            lastR = r;\r\n            t = newT;\r\n            r = newR;\r\n            newT = lastT.subtract(q.multiply(newT));\r\n            newR = lastR.subtract(q.multiply(newR));\r\n        }\r\n        if (!r.isUnit()) throw new Error(this.toString() + \" and \" + n.toString() + \" are not co-prime\");\r\n        if (t.compare(0) === -1) {\r\n            t = t.add(n);\r\n        }\r\n        if (this.isNegative()) {\r\n            return t.negate();\r\n        }\r\n        return t;\r\n    };\r\n\r\n    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;\r\n\r\n    BigInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return subtractSmall(value, 1, this.sign);\r\n        }\r\n        return new BigInteger(addSmall(value, 1), this.sign);\r\n    };\r\n    SmallInteger.prototype.next = function () {\r\n        var value = this.value;\r\n        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);\r\n        return new BigInteger(MAX_INT_ARR, false);\r\n    };\r\n    NativeBigInt.prototype.next = function () {\r\n        return new NativeBigInt(this.value + BigInt(1));\r\n    };\r\n\r\n    BigInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (this.sign) {\r\n            return new BigInteger(addSmall(value, 1), true);\r\n        }\r\n        return subtractSmall(value, 1, this.sign);\r\n    };\r\n    SmallInteger.prototype.prev = function () {\r\n        var value = this.value;\r\n        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);\r\n        return new BigInteger(MAX_INT_ARR, true);\r\n    };\r\n    NativeBigInt.prototype.prev = function () {\r\n        return new NativeBigInt(this.value - BigInt(1));\r\n    };\r\n\r\n    var powersOfTwo = [1];\r\n    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);\r\n    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];\r\n\r\n    function shift_isSmall(n) {\r\n        return Math.abs(n) <= BASE;\r\n    }\r\n\r\n    BigInteger.prototype.shiftLeft = function (v) {\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftRight(-n);\r\n        var result = this;\r\n        if (result.isZero()) return result;\r\n        while (n >= powers2Length) {\r\n            result = result.multiply(highestPower2);\r\n            n -= powers2Length - 1;\r\n        }\r\n        return result.multiply(powersOfTwo[n]);\r\n    };\r\n    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;\r\n\r\n    BigInteger.prototype.shiftRight = function (v) {\r\n        var remQuo;\r\n        var n = parseValue(v).toJSNumber();\r\n        if (!shift_isSmall(n)) {\r\n            throw new Error(String(n) + \" is too large for shifting.\");\r\n        }\r\n        if (n < 0) return this.shiftLeft(-n);\r\n        var result = this;\r\n        while (n >= powers2Length) {\r\n            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;\r\n            remQuo = divModAny(result, highestPower2);\r\n            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n            n -= powers2Length - 1;\r\n        }\r\n        remQuo = divModAny(result, powersOfTwo[n]);\r\n        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];\r\n    };\r\n    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;\r\n\r\n    function bitwise(x, y, fn) {\r\n        y = parseValue(y);\r\n        var xSign = x.isNegative(), ySign = y.isNegative();\r\n        var xRem = xSign ? x.not() : x,\r\n            yRem = ySign ? y.not() : y;\r\n        var xDigit = 0, yDigit = 0;\r\n        var xDivMod = null, yDivMod = null;\r\n        var result = [];\r\n        while (!xRem.isZero() || !yRem.isZero()) {\r\n            xDivMod = divModAny(xRem, highestPower2);\r\n            xDigit = xDivMod[1].toJSNumber();\r\n            if (xSign) {\r\n                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            yDivMod = divModAny(yRem, highestPower2);\r\n            yDigit = yDivMod[1].toJSNumber();\r\n            if (ySign) {\r\n                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers\r\n            }\r\n\r\n            xRem = xDivMod[0];\r\n            yRem = yDivMod[0];\r\n            result.push(fn(xDigit, yDigit));\r\n        }\r\n        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);\r\n        for (var i = result.length - 1; i >= 0; i -= 1) {\r\n            sum = sum.multiply(highestPower2).add(bigInt(result[i]));\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    BigInteger.prototype.not = function () {\r\n        return this.negate().prev();\r\n    };\r\n    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;\r\n\r\n    BigInteger.prototype.and = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a & b; });\r\n    };\r\n    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;\r\n\r\n    BigInteger.prototype.or = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a | b; });\r\n    };\r\n    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;\r\n\r\n    BigInteger.prototype.xor = function (n) {\r\n        return bitwise(this, n, function (a, b) { return a ^ b; });\r\n    };\r\n    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;\r\n\r\n    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;\r\n    function roughLOB(n) { // get lowestOneBit (rough)\r\n        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)\r\n        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]\r\n        var v = n.value,\r\n            x = typeof v === \"number\" ? v | LOBMASK_I :\r\n                typeof v === \"bigint\" ? v | BigInt(LOBMASK_I) :\r\n                    v[0] + v[1] * BASE | LOBMASK_BI;\r\n        return x & -x;\r\n    }\r\n\r\n    function integerLogarithm(value, base) {\r\n        if (base.compareTo(value) <= 0) {\r\n            var tmp = integerLogarithm(value, base.square(base));\r\n            var p = tmp.p;\r\n            var e = tmp.e;\r\n            var t = p.multiply(base);\r\n            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };\r\n        }\r\n        return { p: bigInt(1), e: 0 };\r\n    }\r\n\r\n    BigInteger.prototype.bitLength = function () {\r\n        var n = this;\r\n        if (n.compareTo(bigInt(0)) < 0) {\r\n            n = n.negate().subtract(bigInt(1));\r\n        }\r\n        if (n.compareTo(bigInt(0)) === 0) {\r\n            return bigInt(0);\r\n        }\r\n        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));\r\n    };\r\n    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;\r\n\r\n    function max(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.greater(b) ? a : b;\r\n    }\r\n    function min(a, b) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        return a.lesser(b) ? a : b;\r\n    }\r\n    function gcd(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        if (a.equals(b)) return a;\r\n        if (a.isZero()) return b;\r\n        if (b.isZero()) return a;\r\n        var c = Integer[1], d, t;\r\n        while (a.isEven() && b.isEven()) {\r\n            d = min(roughLOB(a), roughLOB(b));\r\n            a = a.divide(d);\r\n            b = b.divide(d);\r\n            c = c.multiply(d);\r\n        }\r\n        while (a.isEven()) {\r\n            a = a.divide(roughLOB(a));\r\n        }\r\n        do {\r\n            while (b.isEven()) {\r\n                b = b.divide(roughLOB(b));\r\n            }\r\n            if (a.greater(b)) {\r\n                t = b; b = a; a = t;\r\n            }\r\n            b = b.subtract(a);\r\n        } while (!b.isZero());\r\n        return c.isUnit() ? a : a.multiply(c);\r\n    }\r\n    function lcm(a, b) {\r\n        a = parseValue(a).abs();\r\n        b = parseValue(b).abs();\r\n        return a.divide(gcd(a, b)).multiply(b);\r\n    }\r\n    function randBetween(a, b, rng) {\r\n        a = parseValue(a);\r\n        b = parseValue(b);\r\n        var usedRNG = rng || Math.random;\r\n        var low = min(a, b), high = max(a, b);\r\n        var range = high.subtract(low).add(1);\r\n        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));\r\n        var digits = toBase(range, BASE).value;\r\n        var result = [], restricted = true;\r\n        for (var i = 0; i < digits.length; i++) {\r\n            var top = restricted ? digits[i] : BASE;\r\n            var digit = truncate(usedRNG() * top);\r\n            result.push(digit);\r\n            if (digit < top) restricted = false;\r\n        }\r\n        return low.add(Integer.fromArray(result, BASE, false));\r\n    }\r\n\r\n    var parseBase = function (text, base, alphabet, caseSensitive) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        text = String(text);\r\n        if (!caseSensitive) {\r\n            text = text.toLowerCase();\r\n            alphabet = alphabet.toLowerCase();\r\n        }\r\n        var length = text.length;\r\n        var i;\r\n        var absBase = Math.abs(base);\r\n        var alphabetValues = {};\r\n        for (i = 0; i < alphabet.length; i++) {\r\n            alphabetValues[alphabet[i]] = i;\r\n        }\r\n        for (i = 0; i < length; i++) {\r\n            var c = text[i];\r\n            if (c === \"-\") continue;\r\n            if (c in alphabetValues) {\r\n                if (alphabetValues[c] >= absBase) {\r\n                    if (c === \"1\" && absBase === 1) continue;\r\n                    throw new Error(c + \" is not a valid digit in base \" + base + \".\");\r\n                }\r\n            }\r\n        }\r\n        base = parseValue(base);\r\n        var digits = [];\r\n        var isNegative = text[0] === \"-\";\r\n        for (i = isNegative ? 1 : 0; i < text.length; i++) {\r\n            var c = text[i];\r\n            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));\r\n            else if (c === \"<\") {\r\n                var start = i;\r\n                do { i++; } while (text[i] !== \">\" && i < text.length);\r\n                digits.push(parseValue(text.slice(start + 1, i)));\r\n            }\r\n            else throw new Error(c + \" is not a valid character\");\r\n        }\r\n        return parseBaseFromArray(digits, base, isNegative);\r\n    };\r\n\r\n    function parseBaseFromArray(digits, base, isNegative) {\r\n        var val = Integer[0], pow = Integer[1], i;\r\n        for (i = digits.length - 1; i >= 0; i--) {\r\n            val = val.add(digits[i].times(pow));\r\n            pow = pow.times(base);\r\n        }\r\n        return isNegative ? val.negate() : val;\r\n    }\r\n\r\n    function stringify(digit, alphabet) {\r\n        alphabet = alphabet || DEFAULT_ALPHABET;\r\n        if (digit < alphabet.length) {\r\n            return alphabet[digit];\r\n        }\r\n        return \"<\" + digit + \">\";\r\n    }\r\n\r\n    function toBase(n, base) {\r\n        base = bigInt(base);\r\n        if (base.isZero()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            throw new Error(\"Cannot convert nonzero numbers to base 0.\");\r\n        }\r\n        if (base.equals(-1)) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n            if (n.isNegative())\r\n                return {\r\n                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))\r\n                        .map(Array.prototype.valueOf, [1, 0])\r\n                    ),\r\n                    isNegative: false\r\n                };\r\n\r\n            var arr = Array.apply(null, Array(n.toJSNumber() - 1))\r\n                .map(Array.prototype.valueOf, [0, 1]);\r\n            arr.unshift([1]);\r\n            return {\r\n                value: [].concat.apply([], arr),\r\n                isNegative: false\r\n            };\r\n        }\r\n\r\n        var neg = false;\r\n        if (n.isNegative() && base.isPositive()) {\r\n            neg = true;\r\n            n = n.abs();\r\n        }\r\n        if (base.isUnit()) {\r\n            if (n.isZero()) return { value: [0], isNegative: false };\r\n\r\n            return {\r\n                value: Array.apply(null, Array(n.toJSNumber()))\r\n                    .map(Number.prototype.valueOf, 1),\r\n                isNegative: neg\r\n            };\r\n        }\r\n        var out = [];\r\n        var left = n, divmod;\r\n        while (left.isNegative() || left.compareAbs(base) >= 0) {\r\n            divmod = left.divmod(base);\r\n            left = divmod.quotient;\r\n            var digit = divmod.remainder;\r\n            if (digit.isNegative()) {\r\n                digit = base.minus(digit).abs();\r\n                left = left.next();\r\n            }\r\n            out.push(digit.toJSNumber());\r\n        }\r\n        out.push(left.toJSNumber());\r\n        return { value: out.reverse(), isNegative: neg };\r\n    }\r\n\r\n    function toBaseString(n, base, alphabet) {\r\n        var arr = toBase(n, base);\r\n        return (arr.isNegative ? \"-\" : \"\") + arr.value.map(function (x) {\r\n            return stringify(x, alphabet);\r\n        }).join('');\r\n    }\r\n\r\n    BigInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    SmallInteger.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    NativeBigInt.prototype.toArray = function (radix) {\r\n        return toBase(this, radix);\r\n    };\r\n\r\n    BigInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined$1) radix = 10;\r\n        if (radix !== 10) return toBaseString(this, radix, alphabet);\r\n        var v = this.value, l = v.length, str = String(v[--l]), zeros = \"0000000\", digit;\r\n        while (--l >= 0) {\r\n            digit = String(v[l]);\r\n            str += zeros.slice(digit.length) + digit;\r\n        }\r\n        var sign = this.sign ? \"-\" : \"\";\r\n        return sign + str;\r\n    };\r\n\r\n    SmallInteger.prototype.toString = function (radix, alphabet) {\r\n        if (radix === undefined$1) radix = 10;\r\n        if (radix != 10) return toBaseString(this, radix, alphabet);\r\n        return String(this.value);\r\n    };\r\n\r\n    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;\r\n\r\n    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); };\r\n\r\n    BigInteger.prototype.valueOf = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;\r\n\r\n    SmallInteger.prototype.valueOf = function () {\r\n        return this.value;\r\n    };\r\n    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;\r\n    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {\r\n        return parseInt(this.toString(), 10);\r\n    };\r\n\r\n    function parseStringValue(v) {\r\n        if (isPrecise(+v)) {\r\n            var x = +v;\r\n            if (x === truncate(x))\r\n                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);\r\n            throw new Error(\"Invalid integer: \" + v);\r\n        }\r\n        var sign = v[0] === \"-\";\r\n        if (sign) v = v.slice(1);\r\n        var split = v.split(/e/i);\r\n        if (split.length > 2) throw new Error(\"Invalid integer: \" + split.join(\"e\"));\r\n        if (split.length === 2) {\r\n            var exp = split[1];\r\n            if (exp[0] === \"+\") exp = exp.slice(1);\r\n            exp = +exp;\r\n            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error(\"Invalid integer: \" + exp + \" is not a valid exponent.\");\r\n            var text = split[0];\r\n            var decimalPlace = text.indexOf(\".\");\r\n            if (decimalPlace >= 0) {\r\n                exp -= text.length - decimalPlace - 1;\r\n                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);\r\n            }\r\n            if (exp < 0) throw new Error(\"Cannot include negative exponent part for integers\");\r\n            text += (new Array(exp + 1)).join(\"0\");\r\n            v = text;\r\n        }\r\n        var isValid = /^([0-9][0-9]*)$/.test(v);\r\n        if (!isValid) throw new Error(\"Invalid integer: \" + v);\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(sign ? \"-\" + v : v));\r\n        }\r\n        var r = [], max = v.length, l = LOG_BASE, min = max - l;\r\n        while (max > 0) {\r\n            r.push(+v.slice(min, max));\r\n            min -= l;\r\n            if (min < 0) min = 0;\r\n            max -= l;\r\n        }\r\n        trim(r);\r\n        return new BigInteger(r, sign);\r\n    }\r\n\r\n    function parseNumberValue(v) {\r\n        if (supportsNativeBigInt) {\r\n            return new NativeBigInt(BigInt(v));\r\n        }\r\n        if (isPrecise(v)) {\r\n            if (v !== truncate(v)) throw new Error(v + \" is not an integer.\");\r\n            return new SmallInteger(v);\r\n        }\r\n        return parseStringValue(v.toString());\r\n    }\r\n\r\n    function parseValue(v) {\r\n        if (typeof v === \"number\") {\r\n            return parseNumberValue(v);\r\n        }\r\n        if (typeof v === \"string\") {\r\n            return parseStringValue(v);\r\n        }\r\n        if (typeof v === \"bigint\") {\r\n            return new NativeBigInt(v);\r\n        }\r\n        return v;\r\n    }\r\n    // Pre-define numbers in range [-999,999]\r\n    for (var i = 0; i < 1000; i++) {\r\n        Integer[i] = parseValue(i);\r\n        if (i > 0) Integer[-i] = parseValue(-i);\r\n    }\r\n    // Backwards compatibility\r\n    Integer.one = Integer[1];\r\n    Integer.zero = Integer[0];\r\n    Integer.minusOne = Integer[-1];\r\n    Integer.max = max;\r\n    Integer.min = min;\r\n    Integer.gcd = gcd;\r\n    Integer.lcm = lcm;\r\n    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };\r\n    Integer.randBetween = randBetween;\r\n\r\n    Integer.fromArray = function (digits, base, isNegative) {\r\n        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);\r\n    };\r\n\r\n    return Integer;\r\n})();\r\n\r\n// Node.js check\r\nif ( module.hasOwnProperty(\"exports\")) {\r\n    module.exports = bigInt;\r\n}\r\n});\n\nvar wasm = {};\nvar rust = {}; // WebAssembly value types\n\nwasm['i32'] = solidity['int32'];\nwasm['i64'] = solidity['int64'];\nwasm['f32'] = solidity['int32'];\nwasm['f64'] = solidity['int32'];\nsanctuary.map(y => {\n  wasm['f' + y * 32] = sanctuaryDef.NullaryType('f' + y * 32)('f' + y * 32)([])(x => sanctuary.is(wasm['i' + y * 32])(x) || x === parseFloat(x.toString()) && sanctuary.is(wasm['i' + y * 32])(x.toString().split('.')[0]));\n})(sanctuary.range(1)(3)); // Rust value types\n\nsanctuary.map(y => {\n  var size = Math.pow(2, y) * 8;\n  rust['u' + size] = solidity['uint' + size * 8];\n  rust['i' + size] = solidity['int' + size * 8];\n})(sanctuary.range(0)(5));\nrust['isize'] = rust['i64'];\nrust['usize'] = rust['u64'];\nrust['f32'] = wasm['f32'];\nrust['f64'] = wasm['f64'];\nrust['bool'] = solidity['bool'];\nrust['tuple'] = sanctuaryDef.Any; // TODO: fixme\n// TODO: Rust arrays: [i32; 5], struct, enum\n\nvar wtypes = {\n  wasm,\n  rust\n};\n\nvar Sanct$2 = require('sanctuary');\n\nvar SDef$2 = require('sanctuary-def');\nvar javascript = {};\nvar types = [[\"string\", SDef$2.String], [\"bytes\", SDef$2.String], [\"number\", SDef$2.Number], [\"number[]\", SDef$2.Array(SDef$2.Number)], [\"string\", SDef$2.String], [\"string[]\", SDef$2.Array(SDef$2.String)], [\"object\", SDef$2.Object], [\"object[]\", SDef$2.Array(SDef$2.Object)], [\"function\", SDef$2.Any], [\"address\", solidity[\"bytes20\"]], [\"byte\", solidity[\"bytes1\"]], [\"uint\", solidity[\"uint256\"]], [\"int\", solidity[\"int256\"]], [\"bool\", solidity[\"uint8\"]], [\"tuple\", SDef$2.Any], // has to bbe better defined SDef.RecordType\n[\"any\", SDef$2.Any]];\ntypes.map(x => javascript[x[0]] = x[1]);\n\nclass ResolverRuntimeMulti {\n  constructor(resolvers) {\n    this.resolvers = resolvers;\n    this.runtime = {};\n    this.inputs = [];\n    this.outputs = [];\n  }\n\n  getRuntime() {\n    return this.runtime;\n  }\n\n  getRuntimeValue(key, index) {\n    if (!index) return this.runtime[key];\n    return this.runtime[key][index];\n  }\n\n  setRuntimeValue(key, value) {\n    this.runtime[key] = value;\n  }\n\n  setInput(key, value, typeobj) {\n    this.setRuntimeValue(key, value);\n  }\n\n  setOutput(key, typeobj) {\n    this.outputs.push(key);\n  } // inputKeys: [[3000, 1], [101, 1]]\n\n\n  onNodeCall(fcontext, inputKeys, outputKeys) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var {\n        pfunction,\n        pclass\n      } = fcontext;\n\n      if (!_this.resolvers[pclass.type]) {\n        throw new Error(\"There is no appropriate resolver for \".concat(pclass.type));\n      } // TODO multiple functions applied on a group of inputs?\n      // TODO inputKey can be a function\n      // if (io[2].type === 'function') {\n      //   argt  = new Function(\"return \" + this.runtime[io[0]][io[1]])();\n      // }\n\n\n      var inputs = inputKeys.map(io => _this.runtime[io[0]][io[1]]);\n      var response = yield _this.resolvers[pclass.type].onNodeCall(fcontext, inputs);\n      if (!(response instanceof Array)) response = [response];\n      _this.runtime[outputKeys[0][0]] = response;\n      return response;\n    })();\n  }\n\n  getOutput() {\n    console.log('Intermediary states: ', this.getRuntime());\n    return this.outputs.map(key => this.getRuntimeValue(key)[0]);\n  }\n\n}\n\nvar ioName = (io, node, port) => \"\".concat(io.name, \"_\").concat(node, \"_\").concat(port);\n\nclass ResolverSourceJs {\n  constructor(resolvers) {\n    this.resolvers = resolvers;\n    this.inputs = [];\n    this.outputs = [];\n    this.steps = [];\n    this.usedResolvers = [];\n  }\n\n  setInput(key, value, typeobj) {\n    this.inputs.push({\n      key,\n      value,\n      typeobj\n    });\n  }\n\n  setOutput(key, value, typeobj) {\n    this.outputs.push({\n      key,\n      value,\n      typeobj\n    });\n  }\n\n  onNodeCall(fcontext, inputKeys, outputKeys) {\n    var {\n      pclass\n    } = fcontext;\n    if (!this.resolvers[pclass.type]) return;\n\n    if (!this.usedResolvers.find(name => name === pclass.type)) {\n      this.usedResolvers.push(pclass.type);\n    }\n\n    var stepSource = this.resolvers[pclass.type].onNodeCall(fcontext, inputKeys, outputKeys);\n\n    if (stepSource) {\n      this.steps.push(stepSource);\n    }\n\n    return stepSource;\n  }\n\n  getOutput() {\n    var inputs = this.inputs.map((_ref) => {\n      var {\n        key,\n        typeobj\n      } = _ref;\n      return ioName(typeobj, key, 0);\n    });\n    var outputs = this.outputs.map((_ref2) => {\n      var {\n        key,\n        value,\n        typeobj\n      } = _ref2;\n      return ioName(typeobj, key, value);\n    });\n    var runContext = this.usedResolvers.map(name => this.resolvers[name].onRunContext()).reduce((accum, val) => accum.concat(val), []);\n    var imports = this.usedResolvers.map(name => this.resolvers[name].getImports()).reduce((accum, val) => accum.concat(val), []);\n    var outputString = outputs.length === 1 ? outputs[0] : \"[\".concat(outputs.join(', '), \"]\");\n    return \"async (\".concat(runContext.join(', '), \", \").concat(inputs.join(', '), \") => {\\n    \").concat(Object.values(imports).join('\\n'), \"\\n\\n    \").concat(this.steps.join('\\n'), \"\\n\\n  return \").concat(outputString, \";\\n}\");\n  }\n\n}\n\nvar ioName$1 = (io, node, port) => \"\".concat(io.name, \"_\").concat(node, \"_\").concat(port);\n\nclass ResolverSourceSolidity {\n  constructor(resolvers) {\n    this.resolvers = resolvers;\n    this.inputs = [];\n    this.outputs = [];\n    this.steps = [];\n    this.usedResolvers = [];\n    this.gapi = [];\n  }\n\n  setInput(key, value, typeobj) {\n    this.inputs.push({\n      key,\n      value,\n      typeobj\n    });\n  }\n\n  setOutput(key, value, typeobj) {\n    this.outputs.push({\n      key,\n      value,\n      typeobj\n    });\n  }\n\n  onNodeCall(fcontext, inputKeys, outputKeys) {\n    var {\n      pclass\n    } = fcontext;\n    if (!this.resolvers[pclass.type]) return;\n\n    if (!this.usedResolvers.find(name => name === pclass.type)) {\n      this.usedResolvers.push(pclass.type);\n    }\n\n    var stepSource = this.resolvers[pclass.type].onNodeCall(fcontext, inputKeys, outputKeys);\n\n    if (stepSource) {\n      this.steps.push(stepSource);\n    }\n\n    return stepSource;\n  }\n\n  getGapi() {\n    if (this.steps.length === 0) return [];\n    this.gapi = this.resolvers.solidity.getGapi(this.inputs, this.outputs);\n    return this.gapi;\n  }\n\n  getOutput() {\n    if (this.steps.length === 0) return '';\n    var inputs = this.inputs.map((_ref) => {\n      var {\n        key,\n        typeobj\n      } = _ref;\n      return ioName$1(typeobj, key, 0);\n    });\n    var outputs = this.outputs.map((_ref2) => {\n      var {\n        key,\n        value,\n        typeobj\n      } = _ref2;\n      return ioName$1(typeobj, key, value);\n    });\n    var runContext = this.usedResolvers.map(name => this.resolvers[name].onRunContext()).reduce((accum, val) => accum.concat(val), []);\n    var imports = this.usedResolvers.map(name => this.resolvers[name].getImports()).reduce((accum, val) => accum.concat(val), []);\n    var head = this.resolvers.solidity.getContractHead();\n    var fdef = this.resolvers.solidity.getFunctionDef(this.inputs, this.outputs);\n    var outputString = outputs.length === 1 ? outputs[0] : \"(\".concat(outputs.join(', '), \")\");\n    return \"\".concat(Object.values(imports).join('\\n'), \"\\n\\ncontract PipedContract {\\n  \").concat(head, \"\\n\\n  \").concat(fdef, \"\\n  {\\n    \").concat(this.steps.join('\\n'), \"\\n\\n    return \").concat(outputString, \";\\n  }\\n}\");\n  }\n\n}\n\nvar ioName$2 = (io, node, port) => \"\".concat(io.name, \"_\").concat(node, \"_\").concat(port);\n\nclass SourceWasmJavascript {\n  constructor() {\n    this.pclasses = {};\n  }\n\n  onNodeCall(fcontext, inputKeys, outputKeys) {\n    var {\n      pfunction,\n      pclass\n    } = fcontext;\n\n    if (!this.pclasses[pclass.name]) {\n      this.pclasses[pclass.name] = pclass;\n    }\n\n    var inputs = inputKeys.map(io => ioName$2(io[2], io[0], io[1]));\n    var outputs = outputKeys.map(io => ioName$2(io[2], io[0], io[1]));\n    var outputString = outputs.length === 1 ? outputs[0] : \"[\".concat(outputs.join(', '), \"]\");\n    return \"\\n  const \".concat(outputString, \" = await module_\").concat(pclass.name, \".instance.exports.\").concat(pfunction.gapi.name, \"(\\n    \").concat(inputs.join(', '), \"\\n  );\");\n  }\n\n  onRunContext() {\n    return ['fetch', 'WebAssembly'];\n  }\n\n  getImports() {\n    return Object.keys(this.pclasses).map(name => {\n      var pclass = this.pclasses[name]; // node.js does not support WebAssembly.instantiateStreaming\n      //   return `\n      // const module_${pclass.name} = await WebAssembly.instantiateStreaming(\n      //   fetch(\"${pclass.deployment}\")\n      // );`;\n\n      return \"\\n    const binary_\".concat(pclass.name, \" = await (await fetch(\\\"\").concat(pclass.deployment, \"\\\")).arrayBuffer();\\n    const module_\").concat(pclass.name, \" = await WebAssembly.instantiate(binary_\").concat(pclass.name, \");\\n      \");\n    });\n  }\n\n  onSubGraph() {}\n\n}\n\nclass RuntimeWasmJavascript {\n  constructor(fetch) {\n    this.fetch = fetch;\n    this.pclasses = {};\n  }\n\n  getModule(pclass) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this.pclasses[pclass.name]) {\n        // const wmodule = await WebAssembly.instantiateStreaming(this.fetch(pclass.deployment));\n        var binary = yield (yield _this.fetch(pclass.deployment)).arrayBuffer();\n        var wmodule = yield WebAssembly.instantiate(binary);\n        _this.pclasses[pclass.name] = wmodule;\n      }\n\n      return _this.pclasses[pclass.name];\n    })();\n  }\n\n  onNodeCall(fcontext, args) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      if (fcontext.pfunction.gapi.type !== \"function\") return;\n      var {\n        pfunction,\n        pclass\n      } = fcontext;\n      var wmodule = yield _this2.getModule(pclass);\n      return yield wmodule.instance.exports[pfunction.gapi.name](...args);\n    })();\n  }\n\n  onSubGraph() {// get graph context\n  }\n\n}\n\nvar ioName$3 = (io, node, port) => \"\".concat(io.name, \"_\").concat(node, \"_\").concat(port);\n\nclass SourceJavascript {\n  onNodeCall(fcontext, inputKeys, outputKeys) {\n    if (fcontext.pfunction.gapi.type !== \"function\") return;\n    if (fcontext.pclass.name === 'pipejs_identity') return;\n    if (fcontext.pclass.name === 'pipejs_common_input') return;\n    var {\n      pfunction,\n      pclass\n    } = fcontext;\n    var source = pfunction.sources.javascript;\n    var inputs = inputKeys.map(io => ioName$3(io[2], io[0], io[1]));\n    var outputs = outputKeys.map(io => ioName$3(io[2], io[0], io[1]));\n    var outputString = outputs.length === 1 ? outputs[0] : \"[\".concat(outputs.join(', '), \"]\");\n    return \"\\n    const \".concat(outputString, \" = (() => \").concat(source, \")()(\").concat(inputs.join(', '), \")\");\n  }\n\n  onRunContext() {\n    return [];\n  }\n\n  getImports() {\n    return [];\n  }\n\n  onSubGraph() {}\n\n}\n\nclass RuntimeJavascript {\n  onNodeCall(fcontext, args) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (fcontext.pfunction.gapi.type !== \"function\") return;\n      var {\n        pfunction,\n        pclass\n      } = fcontext;\n      var source = pfunction.sources.javascript;\n      var func = new Function(\"return \" + source)(); // TODO fixme for multiple functions applied on a group of inputs\n\n      return func.apply(_this, args);\n    })();\n  }\n\n  onSubGraph() {// get graph context\n  }\n\n}\n\nvar ioName$4 = (io, node, port) => \"\".concat(io.name, \"_\").concat(node, \"_\").concat(port);\n\nclass SourceWeb3Javascript {\n  constructor() {\n    this.pclasses = {};\n    this.pclassesAbis = {};\n  }\n\n  onNodeCall(fcontext, inputKeys, outputKeys) {\n    var {\n      pfunction,\n      pclass\n    } = fcontext;\n\n    if (!this.pclasses[pclass.name]) {\n      this.pclasses[pclass.name] = pclass;\n      this.pclassesAbis[pclass.name] = [pfunction.gapi];\n    } else {\n      this.pclassesAbis[pclass.name].push(pfunction.gapi);\n    }\n\n    var inputs = inputKeys.map(io => ioName$4(io[2], io[0], io[1]));\n    var outputs = outputKeys.map(io => ioName$4(io[2], io[0], io[1]));\n    var outputString = outputs.length === 1 ? outputs[0] : \"[\".concat(outputs.join(', '), \"]\");\n    var extraOptions = '';\n\n    if (pfunction.gapi.payable) {\n      extraOptions = \", {value: TODO}\";\n    }\n\n    return \"\\n    const \".concat(outputString, \" = await \").concat(pclass.name, \".\").concat(pfunction.gapi.name, \"(\\n      \").concat(inputs.join(', ')).concat(extraOptions, \"\\n    );\");\n  }\n\n  onRunContext() {\n    return ['provider', 'signer', 'ethers'];\n  }\n\n  getImports() {\n    return Object.keys(this.pclassesAbis).map(name => {\n      var abi = this.pclassesAbis[name];\n      var pclass = this.pclasses[name];\n      return \"\\n    const abi_\".concat(pclass.name, \" = \").concat(JSON.stringify(abi), \";\\n    const \").concat(pclass.name, \" = new ethers.Contract(\\\"\").concat(pclass.deployment, \"\\\", abi_\").concat(pclass.name, \", signer);\");\n    });\n  }\n\n}\n\nclass RuntimeWeb3Javascript {\n  constructor(provider, signer, ethers) {\n    this.provider = provider;\n    this.signer = signer;\n    this.ethers = ethers;\n    this.pclasses = {};\n    this.pclassesAbis = {};\n  }\n\n  getModule(pclass, pfunction) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (!_this.pclasses[pclass.name]) {\n        _this.pclassesAbis[pclass.name] = [pfunction.gapi];\n      } else {\n        _this.pclassesAbis[pclass.name].push(pfunction.gapi);\n      }\n\n      _this.pclasses[pclass.name] = new _this.ethers.Contract(pclass.deployment, _this.pclassesAbis[pclass.name], _this.signer);\n      return _this.pclasses[pclass.name];\n    })();\n  }\n\n  onNodeCall(fcontext, args) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // TODO EVENTS\n      var {\n        pfunction,\n        pclass\n      } = fcontext;\n      var contract = yield _this2.getModule(pclass, pfunction); // TODO payable value\n\n      return yield contract[pfunction.gapi.name](...args);\n    })();\n  }\n\n}\n\nvar ioName$5 = (io, node, port) => \"\".concat(io.name, \"_\").concat(node, \"_\").concat(port);\n\nvar finputs = inputs => inputs.map(inp => \"\".concat(inp.type, \" \").concat(inp.name));\n\nvar foutputs = outputs => outputs.map(out => out.type);\n\nvar mutability = gapi => gapi.stateMutability !== 'non-payable' ? gapi.stateMutability : '';\n\nvar stateMap = {\n  'pure': 0,\n  'view': 1,\n  'nonpayable': 2,\n  'payable': 3\n};\nvar stateMapR = {\n  0: 'pure',\n  1: 'view',\n  2: 'nonpayable',\n  3: 'payable'\n};\n\nclass SourceSolidity {\n  constructor() {\n    this.pclasses = {};\n    this.pclassesAbis = {};\n  }\n\n  onNodeCall(fcontext, inputKeys, outputKeys) {\n    var {\n      pfunction,\n      pclass\n    } = fcontext;\n\n    if (!this.pclasses[pclass.name]) {\n      this.pclasses[pclass.name] = pclass;\n      this.pclassesAbis[pclass.name] = [pfunction.gapi];\n    } else {\n      this.pclassesAbis[pclass.name].push(pfunction.gapi);\n    }\n\n    var inputs = inputKeys.map(io => ioName$5(io[2], io[0], io[1]));\n    var outputs = outputKeys.map(io => \"\".concat(io[2].type, \" \").concat(ioName$5(io[2], io[0], io[1])));\n    var outputString = outputs.length === 1 ? outputs[0] : \"(\".concat(outputs.join(', '), \")\");\n    var extraOptions = '';\n\n    if (pfunction.gapi.payable) {\n      extraOptions = \".value(TODO)\";\n    }\n\n    return \"\\n    \".concat(outputString, \" = \").concat(pclass.name, \".\").concat(pfunction.gapi.name).concat(extraOptions, \"(\\n      \").concat(inputs.join(', '), \"\\n    );\");\n  }\n\n  onRunContext() {\n    return ['provider', 'signer', 'ethers'];\n  }\n\n  getImports() {\n    var imports = [\"pragma solidity ^0.5.4;\"];\n    imports = imports.concat(Object.keys(this.pclassesAbis).map(name => {\n      var abi = this.pclassesAbis[name];\n      var pclass = this.pclasses[name];\n      var finterfaces = abi.map(fabi => {\n        var type = mutability(fabi);\n        var inputs = finputs(fabi.inputs).join(', ');\n        var outputs = foutputs(fabi.outputs).join(', ');\n        return \"\\n  function \".concat(fabi.name, \"(\").concat(inputs, \")\\n    external \").concat(type, \"\\n    returns (\").concat(outputs, \");\\n\");\n      });\n      return \"\\ninterface \".concat(pclass.name, \"Interface {\\n  \").concat(finterfaces.join(''), \"\\n}\");\n    }));\n    return imports;\n  }\n\n  getContractHead() {\n    var declarations = [],\n        constructorArgs = [],\n        constructorAssignments = [];\n    Object.keys(this.pclassesAbis).forEach(name => {\n      declarations.push(\"\".concat(name, \"Interface public \").concat(name, \";\"));\n      constructorArgs.push(\"address _\".concat(name, \"_address\"));\n      constructorAssignments.push(\"\".concat(name, \" = \").concat(name, \"Interface(_\").concat(name, \"_address);\"));\n    });\n    return \"\".concat(declarations.join('\\n  '), \"\\n\\n  constructor(\").concat(constructorArgs.join(', '), \") public {\\n    \").concat(constructorAssignments.join('\\n    '), \"\\n  }\\n    \");\n  }\n\n  getGapi(inputs, outputs) {\n    var ins = inputs.map((_ref) => {\n      var {\n        key,\n        typeobj\n      } = _ref;\n      return {\n        type: typeobj.type,\n        name: ioName$5(typeobj, key, 0)\n      };\n    });\n    var outs = outputs.map((_ref2) => {\n      var {\n        key,\n        typeobj\n      } = _ref2;\n      return {\n        type: typeobj.type,\n        name: ioName$5(typeobj, key, 0)\n      };\n    });\n    var stateIndex = Object.values(this.pclassesAbis).reduce((maxState, abi) => Math.max(maxState, abi.reduce((maxStateC, fabi) => Math.max(maxStateC, stateMap[fabi.stateMutability]), 0)), 0);\n    var stateMutability = stateMapR[stateIndex];\n    return {\n      name: 'function0',\n      type: 'function',\n      inputs: ins,\n      outputs: outs,\n      stateMutability,\n      constant: stateIndex < 2,\n      payable: stateIndex === 3\n    };\n  }\n\n  getFunctionDef(inputs, outputs) {\n    var gapi = this.getGapi(inputs, outputs);\n    var mutabilityFlag = mutability(gapi);\n    return \"\\n    function function0(\".concat(finputs(gapi.inputs).join(', '), \")\\n    public \").concat(mutabilityFlag, \"\\n    returns (\").concat(foutputs(gapi.outputs).join(', '), \")\");\n  }\n\n}\n\nvar pipetypes = [solidity, wtypes.rust, wtypes.wasm, javascript];\n\nexport { ResolverRuntimeMulti, ResolverSourceJs, ResolverSourceSolidity, RuntimeJavascript, RuntimeWasmJavascript, RuntimeWeb3Javascript, SourceJavascript, SourceSolidity, SourceWasmJavascript, SourceWeb3Javascript, javascript as jstypes, pipe as pipejs, pipetypes, solidity as soltypes, wtypes };\n//# sourceMappingURL=index.es.js.map\n","import { pipejs, pipetypes } from '@pipeos/pipejs';\nconst d3 = require(\"d3\");\n\nfunction pipecanvas(fcontext = {}, pipegraph = {}, options={}) {\n  const DEFAULT_GRAPH = {n: {}, e: [], r: []}\n  const DEFAULT_TARGETS = {\n    for_click: {},\n    for_click_edge: {},\n    for_drag: {},\n    end_drag:{},\n    for_drop: {}\n  }\n  let DEFAULT_OPTIONS = {\n    width: 600,\n    height: 600,\n    domid: '#pipegraph',\n    types: {\n      // \"number\": {color: \"#355\"},\n      // \"number[]\": {color: \"#463\"},\n      // \"function\": {color: \"#562\"},\n      // \"string\": {color: \"#662\"},\n    },\n    typecolors: {},\n    colors: {\n      nodeBody: \"#d8d8d8\",\n      nodeRemove: \"#fcc\",\n      portText: \"#aaaaaa\",\n      text: \"#000000\",\n    },\n    bodyColorFunction: null,\n    font: `Lato,-apple-system,system-ui,BlinkMacSystemFont,\"Segoe UI\",Roboto,\"Helvetica Neue\",Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\"`,\n  }\n  let COMMON_INPUT = (idpart, output) => {\n    // typing might contain other attributes, like payable\n    return {\n      \"_id\": pipe1.settings.id + idpart,\n      \"pclassid\":\"5dbaa731f18ff7488e9b108b\",\n      \"pfunction\":{\n        \"signature\":\"id(x)\",\n        \"gapi\":{\"constant\":true,\"inputs\":[],\"name\":\"id\",\"outputs\":[output],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},\n        \"graph\":{},\n        \"sources\":{\"javascript.rust\":\"() => rust.id()\",\"javascript\":\"(x)=>x\"}\n      },\n      // \"categories\":{\"languages\":[\"javascript.rust\",\"javascript\"]},\n      \"timestamp\":\"2019-11-06T19:22:53.807Z\",\n      pclass: {\n        _id: \"0x0\",\n        name: \"unknown\",\n        type: 'unknown',\n        deployment: 'unknown',\n      }\n    }\n  }\n\n  function getRandomColor() {\n    const letters = '0123456789ABCDEF';\n    const red = '56789ABC';\n    const green = '6789ABCD';\n    const blue = '6789ABCD';\n\n    const getPartial = (letters) => letters[Math.floor(Math.random() * letters.length)]\n\n    let color = '#';\n    color += getPartial(red);\n    color += getPartial(red);\n    color += getPartial(green);\n    color += getPartial(green);\n    color += getPartial(blue);\n    color += getPartial(blue);\n\n    return color;\n  }\n\n  function typeOptions(type) {\n    if (pipeopts.types[type]) return pipeopts.types[type];\n\n    const typedef = pipe1.types[type];\n    const similar = Object.keys(pipeopts.types).find(key => typedef === pipe1.types[key]);\n\n    if (similar) {\n      pipeopts.types[type] = pipeopts.types[similar];\n      return pipeopts.types[type];\n    }\n\n    const color = getRandomColor();\n    const end = 0;\n    while (pipeopts.typecolors[color] && end < 400) {\n      color = getRandomColor();\n      end += 1;\n    }\n\n    pipeopts.types[type] = {color};\n    pipeopts.typecolors[color] = type;\n    return pipeopts.types[type];\n  }\n\n  let coloropts = Object.assign({}, DEFAULT_OPTIONS.colors, options.colors || {});\n  let pipeopts = Object.assign({}, DEFAULT_OPTIONS, options, {colors: coloropts});\n  let graph1 = {}\n  let current_stage = ({settings:{transform:{}}})\n  let current_edge = ({pos:[], target: false})\n\n  let targets = JSON.parse(JSON.stringify(DEFAULT_TARGETS));\n  let pipe1 = new pipejs(pipetypes);\n\n  setGraph(pipegraph, fcontext);\n\n  function runnable(graph) {\n    console.log('runnable pipe1', pipe1);\n    console.log('runnable fcontext', pipe1.get_indexed_func());\n    console.log('runnable graph', graph);\n    let rich  = pipe1.enrich_graph (pipe1.get_indexed_func()) (graph)\n    console.log('runnable rich', rich)\n    let runtime = pipe1.make_runtime (pipe1.get_indexed_func())(rich)\n    current_stage.settings.r_graph = runtime\n    return runtime\n  }\n\n  function dstart() {\n    let coords= JSON.parse(JSON.stringify(d3.mouse(this)));\n    // d3.event.x, d3.event.y\n    const coordp = {x: coords[0], y: coords[1]};\n    let done = false\n    // console.log(\"srttt\", coords)\n    // console.log('targets', targets)\n    for (let key in targets.for_click_edge) {\n      let value = targets.for_click_edge[key]\n      if ( value.l <= coordp.x && value.r >= coordp.x) {\n        if ( value.t <= coordp.y && value.b >= coordp.y) {\n          console.log(\"edge-click\", value, key)\n          let new_gr = JSON.parse(JSON.stringify(current_stage.settings.r_graph.rich_graph.init))\n            new_gr = pipe1.remove_edge (new_gr) (JSON.parse(\"[\"+key+\"]\"))\n            new_gr = runnable(new_gr)\n            // console.log( \"dstart new_gryyy\", new_gr)\n            current_stage.settings.r_graph = new_gr\n            done = true;\n        }\n      }\n    }\n    if (done) return ;\n\n    for (let key in targets.for_click) {\n      let value = targets.for_click[key]\n      // console.log(\"sttt\", value, coordp.x, coordp.y);\n      if ( value.l <= coordp.x && value.r >= coordp.x) {\n        if ( value.t <= coordp.y && value.b >= coordp.y) {\n          //mutable current_edge = {pos:[coords[0], coords[1], coords[0], coords[1]]}\n          // console.log(\"starttt-click\", value, key)\n          let key1 = JSON.parse(\"[\"+key+\"]\")\n          if (key1[1] ===1) {\n            console.log(\"clicked node\", value, key1)\n            //return change_mode(key1[0]);\n          }\n          if (key1[1] ===0) {\n            //console.log( \"new_gr\",current_stage)\n            let new_gr = JSON.parse(JSON.stringify(current_stage.settings.r_graph.rich_graph.init))\n            new_gr = pipe1.remove_node (new_gr) (key1[0])\n            new_gr = runnable(new_gr)\n            // console.log(\"dstart new_gryyy\", new_gr)\n            current_stage.settings.r_graph = new_gr\n            graph1 = new_gr\n            done = true\n          }\n        }\n      }\n    }\n    if (done) return\n\n    for (let key in targets.for_drag) {\n      let value = targets.for_drag[key]\n      if ( value.l <= coordp.x && value.r >= coordp.x) {\n        if ( value.t <= coordp.y && value.b >= coordp.y) {\n          current_edge.pos = [(value.r+value.l)/2, (value.b+value.t)/2, coords[0], coords[1]]\n          current_edge.source = value.port\n          // console.log(\"dstart starttt-edge\", value)\n        }\n      }\n    }\n    // console.log(\"start\", d3.event, coords)\n  }\n\n  function change_mode(key){\n    console.log(key)\n    for (let x=0; x<1;x=x+1/30){\n      //let transform = current_stage.settings.transform\n      console.log(x)\n      current_stage.settings.transform = {i:key,  f:x}\n      graph_show(current_stage.settings.ctx, current_stage.settings.width, current_stage.settings.height, current_stage.settings.nodes, current_stage.settings.edges, current_stage.settings.matrix, current_stage.settings.transform, current_stage.settings.r_graph)\n    }\n  }\n\n  function ddrag(e){\n    let coords= d3.mouse(this);\n    if (current_edge.pos.length === 4){\n      let co = JSON.parse(JSON.stringify(current_edge.pos))\n      graph_show(current_stage.settings.ctx, current_stage.settings.width, current_stage.settings.height, current_stage.settings.nodes, current_stage.settings.edges, current_stage.settings.matrix, current_stage.settings.transform, current_stage.settings.r_graph)\n\n          let nearest = nearestf(coords)\n          if (nearest){\n            // console.log(\"ddrag neeear\", nearest)\n              current_edge.pos = [current_edge.pos[0], current_edge.pos[1], nearest.x, nearest.y]\n              current_edge.target = nearest\n          } else {\n              // console.log('ddrag', nearest)\n              current_edge.pos = [co[0], co[1], coords[0], coords[1]]\n              current_edge.target = false\n          }\n      drawExactArrow(current_stage.settings.ctx, current_edge.pos[0], current_edge.pos[1], current_edge.pos[2], current_edge.pos[3], current_edge.source.type, 1, true)\n      // console.log('ddrag current_edge', current_edge)\n    }\n  }\n\n  function nearestf(pos) {\n      let nearest = false, dx,dy,d2,d1, acc\n      for (let rec in targets.end_drag){\n        // console.log('nearestf', current_edge.source.type, targets.end_drag[rec], rec, current_stage.settings.r_graph.rich_graph.n[targets.end_drag[rec].port.i], targets.end_drag[rec].port.i)\n          const targetIns = current_stage.settings.r_graph.rich_graph.n[targets.end_drag[rec].port.i].in[targets.end_drag[rec].port.port];\n\n          if (\n            pipe1.types[current_edge.source.type] === pipe1.types[targets.end_drag[rec].port.type] &&\n            // don't connect to the same input port:\n            targetIns[0] !== current_edge.source.i &&\n            // only ports connected to input ports\n            targetIns[0] > 2999\n          ) {\n              acc = nearest? nearest : targets.end_drag[rec]\n\n              d1 = dist(acc, pos)\n              // console.log('nearestf', targets.end_drag[rec], pos)\n              d2 = dist(targets.end_drag[rec], pos)\n              // console.log('nearestf', d1,d2)\n              if (d1 >= d2) {\n                  if (d2 < 30000) {\n                      nearest = targets.end_drag[rec]\n                  } else {\n                      nearest = false\n                      // console.log('nearestf', d2)\n                  }\n              }\n          }\n      }\n      return nearest\n  }\n\n  function dist( xy, vec){\n      let dx,dy,d2\n      dx = xy.x - vec[0]\n      dy = xy.y -  vec[1]\n      d2 = dx*dx +dy*dy\n      return d2\n  }\n\n  function dend(){\n    // console.log(\"dend\", d3.event, d3.mouse,current_edge)\n    let new_gr;\n    if (current_edge.target !== false) {\n      // console.log(\"dend:   j . \", current_edge)\n      if (current_edge.source.i > 2999) {\n        new_gr = add_edge_to_input(current_edge)\n      } else {\n        new_gr = JSON.parse(JSON.stringify(current_stage.settings.r_graph.rich_graph.init))\n        new_gr = pipe1.add_edge (new_gr) ([current_edge.source.i, current_edge.source.port, current_edge.target.port.i, current_edge.target.port.port] )\n      }\n\n      new_gr = runnable(new_gr)\n      current_stage.settings.r_graph = new_gr\n      console.log( \"new_gryyy\", new_gr)\n    }\n\n    current_edge = {pos:[], target: false}\n    current_edge.target = false\n    redraw()\n  }\n\n  function add_edge_to_input(current_edge) {\n    const {r_graph} = current_stage.settings;\n    let n1 = r_graph.rich_graph.n[current_edge.source.i]\n    let new_gr = JSON.parse(JSON.stringify(r_graph.rich_graph.init))\n\n    const sourceid = r_graph.rich_graph.n[current_edge.source.i].id;\n    const inputIdx = current_edge.source.port - 1;\n    const sourceInput = r_graph.context[sourceid].pfunction.gapi.outputs[inputIdx];\n    const newnode = COMMON_INPUT(current_edge.source.i, {name: sourceInput.name, type: sourceInput.type});\n    pipe1.add_indexed_func(newnode);\n\n    new_gr  = pipe1.add_node(new_gr) ({i: current_edge.source.i, id: newnode._id})\n\n    for (let e in r_graph.rich_graph.e) {\n      if (r_graph.rich_graph.e[e][0] === current_edge.source.i)\n        new_gr = pipe1.add_edge (new_gr) (r_graph.rich_graph.e[e])\n    }\n    new_gr = pipe1.add_edge (new_gr) ([current_edge.source.i, current_edge.source.port, current_edge.target.port.i, current_edge.target.port.port] )\n    return new_gr\n  }\n\n  function graph_edit(ctx, r_graph) {\n    let dnodes = {}\n    let rows = r_graph.runnable_graph.length\n    let cols = 0\n\n    for (const nodes of r_graph.runnable_graph) {\n      for (const node of nodes) {\n        let node_i = r_graph.rich_graph.n[node]\n        let node_x = r_graph.context[node_i.id]\n        let len = Math.max(node_x.pfunction.gapi.inputs.length, node_x.pfunction.gapi.outputs.length)\n        dnodes[node] = {x: node_i.position.x, y: node_i.position.y, container: node_x.pclass.name, name: node_x.pfunction.gapi.name, len: len, context: node_x.pfunction.gapi, i:node}\n        if (cols < node_i.position.x  + len) {\n          cols = node_i.position.x  + len\n        }\n      }\n    }\n\n    current_stage.settings = {width: pipeopts.width, height: pipeopts.height, nodes: dnodes, edges: r_graph.rich_graph.e, matrix: [rows,cols], transform: {x:0, y:0, l:1, f:0.00}, r_graph: r_graph}\n\n    return graph_show(ctx, pipeopts.width, pipeopts.height, dnodes, r_graph.rich_graph.e, [rows,cols], current_stage.settings.transform, current_stage.settings.r_graph); // x:0, y:0, l:1, f:0.00\n\n  }\n\n  function pos_calculate(x, y, l, matrix, dims) {\n    let marginw = pipeopts.width / 30\n    let marginh = 0\n    let minh = 16\n    let stepw = (dims[0]-2*marginw)/(matrix[1]+0)\n    let steph = (dims[1]-2*marginh+minh)/(matrix[0]-1)//-minh/2\n    return {x: x*stepw+marginw+l*stepw/2, y: y*steph-minh/2, l: l*stepw, h: minh, steps: {w:stepw, h:steph}}\n  }\n\n  function graph_show(ctx2, width, height, nodes,  edges, matrix, transform, r_graph) {\n    //mutable\n    ctx2.clearRect(0, 0, width, height);\n    ctx2.fillStyle=\"#fff\"\n    rect1([ctx2, width / 2, height / 2, width, height])\n    current_stage.settings = {ctx: ctx2, width: width, height: height, nodes: nodes, edges:edges, matrix:matrix, transform:transform, r_graph: r_graph}\n\n    let ports_pos = {}\n    for (const node in nodes) {\n      let n = nodes[node]\n      node_show(ctx2, n, matrix, [width, height], ports_pos)\n    }\n\n    for (const edge of edges) {\n\n        let e = edge\n        let p1 = ports_pos[[e[0], e[1], 1]]\n        let p2 = ports_pos[[e[2], e[3], 0]]\n        let mid = [(p1.x+p2.x)/2,  (p1.y+p2.y)/2]\n        let r = 4\n        //console.log(edge, p1,p2)\n        drawExactArrow(ctx2, p1.x, p1.y, p2.x, p2.y, p1.type, 1)\n        targets.for_click_edge[e]= {t: mid[1]-r,  b: mid[1]+r , l:  mid[0]-r, r: mid[0]+r}\n      }\n  }\n\n  function node_show(ctx, node, matrix, dims, ports_pos) {\n    let scale=1\n    let x = node.x\n    let y = node.y\n    let pos = pos_calculate(x, y, node.len, matrix, dims)\n    let nw = pos.l\n    let nh = pos.h\n\n    ports_show(ctx, pos, node.context, ports_pos, node.i)\n    const bodycol = pipeopts.bodyColorFunction ? pipeopts.bodyColorFunction(node.context) : null;\n    ctx.fillStyle = bodycol ? bodycol : pipeopts.colors.nodeBody;\n\n    rect1([ctx,pos.x,pos.y,nw,pos.h,pos.h/2])\n    targets.for_click[[node.i, 1]] = {l: pos.x-nw/2, r:  pos.x+nw/2-16 , t: pos.y-pos.h/2 , b: pos.y+pos.h/2}\n    ctx.fillStyle = pipeopts.colors.nodeRemove\n\n    rect1([ctx,pos.x+nw/2-8,pos.y,16,16,8])\n    targets.for_click[[node.i, 0]] = {l: pos.x+nw/2-16, r:  pos.x+nw/2 , t: pos.y-pos.h/2 , b: pos.y+pos.h/2}\n    ctx.beginPath()\n    ctx.textAlign = \"center\";\n    //ctx.font = (18*scale-9)+\"px \"+pipeopts.font\n    //context.lineJoin = \"round\";\n    ctx.fillStyle = pipeopts.colors.text\n    //ctx.fillText(shorten(node.container,max*5+2), pos.x, pos.y-2 );\n    ctx.font = (9*scale+4)+\"px \" + pipeopts.font\n    ctx.fillText(shorten(node.container,node.len*2+2)+\": \"+shorten(node.name,node.len*10+4), pos.x, pos.y+6 );\n    ctx.fill()\n  }\n\n  function ports_show(ctx, pos, node_x, ports_pos,i){\n    let ndx=0, nw=20\n    for (let port1 of node_x.inputs){\n      //console.log(port1, pos.x+pos.l+50*ndx, pos.y-20)\n      ctx.fillStyle = typeOptions(port1.type).color\n      let x = pos.x-pos.l/2+pos.steps.w*(ndx+0.5)\n      let y = pos.y-pos.h/2\n      rect1([ctx,x, y,nw,nw,10,10,0,0])\n      ctx.save();\n      ctx.translate( x, y);\n      ctx.rotate( -Math.PI / 4 );\n      ctx.font = (8/1+4)+\"px \" + pipeopts.font;\n      ctx.fillStyle = pipeopts.colors.portText;\n      ctx.textAlign = \"left\";\n      ctx.fillText( port1.name, 0,0 );\n      ctx.restore();\n\n      let xt = pos.x-pos.l/2+pos.steps.w*(ndx+0.5)\n      let yt = pos.y-pos.h/2\n      ctx.save();\n      ctx.translate( xt, yt);\n      ctx.rotate( -Math.PI / 4 );\n      ctx.font = (8/1+4)+\"px \" + pipeopts.font;\n      ctx.fillStyle = pipeopts.colors.portText;\n      ctx.textAlign = \"left\";\n      ctx.fillText( port1.type, 10,10 );\n      ctx.restore();\n\n      ports_pos[[i,ndx+1,0]]={x: x,y: y, type: port1.type}\n      // console.log(i)\n      if (parseInt(i) < 3000) targets.end_drag[[i,ndx+1]] = {x: x,  y: y, port: {i:i, port:ndx+1, type:port1.type}}\n      ndx++\n    }\n    ndx=0\n    for (let port1 of node_x.outputs){\n      //console.log(port1)\n      ctx.fillStyle = typeOptions(port1.type).color\n      let x = pos.x-pos.l/2+pos.steps.w*(ndx+0.5)\n      let y = pos.y+pos.h/2\n      rect1([ctx, x, y,nw,nw,0,0,10,10])\n      ports_pos[[i,ndx+1,1]]={x: x, y: y, type: port1.type}\n      targets.for_drag[[i,ndx+1]] = {l: x-10,  r: x+10 ,t: y,b: y+10, port: {i:i, port:ndx+1, type:port1.type}}\n      ndx++\n    }\n  }\n\n  function shorten(txt, noChar){\n    let len = txt.length\n    if ( len < noChar) return txt;\n    let half = Math.floor(noChar/2)\n    return txt.slice(0, half)+ \"..\" +txt.slice(-half)\n  }\n\n  function drawExactArrow(ctx2, x1, y1, x2, y2, type, scale, temporary = false){\n      var midx = (x2+x1)/2\n      var midy = (y2+y1)/2\n      let context = ctx2\n      //let color  = types[type].color\n      let srt  = \"M\"+x1+\",\"+y1+\"C\"+x1+\",\" +midy+\",\" +\n      midx+\",\"+ midy+\",\"+ midx+\",\"+ midy+\n      \"C\"+midx+\",\" +midy+\",\"+ x2+\",\"+ midy+\",\" +x2+\",\"+ y2\n      //let scale = 1\n      //context.moveTo(x1, y1)\n      context.lineCap = \"round\"\n      context.strokeStyle  =  typeOptions(type).color\n      context.lineWidth = !temporary ? 1*scale : 2*scale;\n      context.stroke(new Path2D(srt));\n      context.closePath();\n      //context.moveTo(midx, midy)\n      context.beginPath()\n      context.arc(midx, midy, 3, 0, Math.PI*2, false);\n      context.fillStyle = '#DDAAAA';\n      context.fill();\n      context.closePath();\n\n  }\n\n  function rect1(args) {\n    const ctx = args[0];\n    const x = args[1];\n    const y = args[2];\n    const w = args[3];\n    const h = args[4];\n    let tl = args[5];\n    let tr = args[6];\n    let br = args[7];\n    let bl = args[8];\n\n    //console.log(ctx)\n\n    ctx.beginPath();\n\n    if (typeof tl === 'undefined') {\n      // No rounded corners\n      ctx.rect(x-w/2, y-h/2, w, h);\n    } else {\n      // At least one rounded corner\n      // Set defaults when not specified\n      if (typeof tr === 'undefined') {\n        tr = tl;\n      }\n      if (typeof br === 'undefined') {\n        br = tr;\n      }\n      if (typeof bl === 'undefined') {\n        bl = br;\n      }\n\n      // corner rounding must always be positive\n      const absW = Math.abs(w);\n      const absH = Math.abs(h);\n      const hw = absW / 2;\n      const hh = absH / 2;\n\n      // Clip radii\n      if (absW < 2 * tl) {\n        tl = hw;\n      }\n      if (absH < 2 * tl) {\n        tl = hh;\n      }\n      if (absW < 2 * tr) {\n        tr = hw;\n      }\n      if (absH < 2 * tr) {\n        tr = hh;\n      }\n      if (absW < 2 * br) {\n        br = hw;\n      }\n      if (absH < 2 * br) {\n        br = hh;\n      }\n      if (absW < 2 * bl) {\n        bl = hw;\n      }\n      if (absH < 2 * bl) {\n        bl = hh;\n      }\n\n      // Draw shape\n      ctx.beginPath();\n      ctx.moveTo(x + tl-w/2, y- h/2);\n      ctx.arcTo(x + w/2, y-h/2, x + w/2, y + h/2, tr);\n      ctx.arcTo(x + w/2, y + h/2, x-w/2, y + h/2, br);\n      ctx.arcTo(x-w/2, y + h/2, x-w/2, y-h/2, bl);\n      ctx.arcTo(x-w/2, y-h/2, x + w/2, y-h/2, tl);\n      ctx.closePath();\n    }\n\n    ctx.fill();\n\n    return ctx;\n  };\n\n  function redraw() {\n    targets = JSON.parse(JSON.stringify(DEFAULT_TARGETS));\n    graph_edit(current_stage.settings.ctx, current_stage.settings.r_graph)\n    if (onchangeCallb) {\n      const graph = JSON.parse(JSON.stringify(current_stage.settings.r_graph));\n      onchangeCallb(graph);\n    }\n  }\n\n  function setOptions(newoptions) {\n    Object.assign(pipeopts, newoptions);\n  }\n\n  function showGraph() {\n    let canvas1 = d3.select(pipeopts.domid).attr('width', pipeopts.width).attr('height', pipeopts.height);\n    const ctx1 = canvas1.node().getContext('2d');\n    d3.select(ctx1.canvas).call(d3.drag().on(\"start\", dstart).on(\"drag\", ddrag).on(\"end\", dend));\n    current_stage.settings.ctx = ctx1;\n    graph_edit(current_stage.settings.ctx, current_stage.settings.r_graph)\n  }\n\n  function addFunction(pfunction, index) {\n    // console.log('addFunction pfunction', pfunction);\n    pipe1.add_indexed_func(pfunction);\n    // console.log(current_stage.settings.r_graph);\n    const lastIndex = Math.max(100,\n      ...Object.keys(current_stage.settings.r_graph.rich_graph.init.n).filter(key => key < 3000)\n    );\n    // console.log('lastIndex', lastIndex);\n    let new_gr = JSON.parse(JSON.stringify(current_stage.settings.r_graph.rich_graph.init))\n\n    new_gr = pipe1.add_node(new_gr) ({i: lastIndex + 1, id: pfunction._id})\n    new_gr = runnable(new_gr)\n\n    console.log( \"new_gryyy\", new_gr)\n    current_stage.settings.r_graph = new_gr\n\n    redraw()\n  }\n\n  function clearGraph() {\n    const graph = Object.assign({}, DEFAULT_GRAPH);\n    current_stage.settings.r_graph = runnable(graph);\n    showGraph();\n  }\n\n  function setGraph(pipegraph, fcontext = {}) {\n    if (!pipegraph || !(pipegraph instanceof Object) || Object.keys(pipegraph).length === 0) {\n      pipegraph = Object.assign({}, DEFAULT_GRAPH);\n    }\n    const mergedContext = Object.assign({}, pipe1.get_indexed_func(), fcontext);\n    pipe1.set_indexed_func(mergedContext);\n\n\n    pipegraph.e.forEach(edge => {\n      if (edge[0] > 2999) {\n        const sourceOutput = pipe1.get_indexed_func()[pipegraph.n[edge[2]].id].pfunction.gapi.inputs[edge[3] - 1];\n        const newnode = COMMON_INPUT(edge[0], {name: sourceOutput.name, type: sourceOutput.type});\n\n        pipe1.add_indexed_func(newnode);\n\n        if(!pipegraph.n[edge[0]]) {\n          pipegraph  = pipe1.add_node(pipegraph) ({i: edge[0], id: newnode._id})\n        }\n      }\n    });\n\n    current_stage.settings.r_graph = runnable(pipegraph);\n  }\n\n  let onchangeCallb;\n  function onChange(cb) {\n    onchangeCallb = cb;\n  }\n\n  function getGraph() {\n    return current_stage.settings.r_graph;\n  }\n\n  return {\n    show: showGraph,\n    setOptions,\n    getGraph,\n    setGraph,\n    pipe: pipe1,\n    addFunction,\n    clear: clearGraph,\n    onChange,\n  }\n}\n\nexport default pipecanvas;\n"],"names":["Sanct","require","SDef","bigInt","window","pipejs","types","rtypes","Object","settings","id","baseurl","PFUNC_IO","_id","name","type","deployment","COMMON_INPUT","pclass","env","def","checkTypes","pl","x","Number","String","r","init","Boolean","y","fcontext","added_func","db_funcs","obj_funcs","graph","edge","variable","graph2","JSON","i","array","item","index","node","node_id","ndx","na","max","Math","e","g","second","first","visited","level","u","defined","unvisited","row","visitedNow","only_outputs","n","gf","context","indexed_func","added_nodes","added_edges","step_out","step_in","grf","output","targetPort","no","svg_id","in","out","position","edges","typing","on","graph1","visitors","graph3","rich_graph","rows","rich_graph2","parseInt","runtime_graph","resolver","arr_ins","ins","runnable","rich","key","nodeContext","contxt","inputKeys","x1","source","outs","sourcePort","d3","pipecanvas","pipegraph","options","DEFAULT_GRAPH","DEFAULT_TARGETS","for_click","for_click_edge","for_drag","end_drag","for_drop","DEFAULT_OPTIONS","width","height","domid","typecolors","colors","nodeBody","nodeRemove","portText","text","bodyColorFunction","font","idpart","pipe1","getRandomColor","red","green","blue","getPartial","letters","floor","random","length","color","typeOptions","pipeopts","typedef","similar","keys","find","end","coloropts","assign","current_stage","transform","current_edge","pos","target","targets","parse","stringify","pipetypes","setGraph","console","log","get_indexed_func","enrich_graph","runtime","make_runtime","r_graph","dstart","coords","mouse","coordp","done","value","l","t","b","new_gr","remove_edge","key1","remove_node","port","ddrag","co","graph_show","ctx","nodes","matrix","nearest","nearestf","drawExactArrow","d2","d1","acc","rec","targetIns","dist","xy","vec","dx","dy","dend","add_edge_to_input","add_edge","redraw","n1","sourceid","inputIdx","sourceInput","pfunction","gapi","outputs","newnode","add_indexed_func","add_node","graph_edit","dnodes","runnable_graph","cols","node_i","node_x","len","inputs","container","f","pos_calculate","dims","marginw","marginh","minh","stepw","steph","h","steps","w","ctx2","clearRect","fillStyle","rect1","ports_pos","node_show","p1","p2","mid","scale","nw","ports_show","bodycol","beginPath","textAlign","fillText","shorten","fill","port1","save","translate","rotate","PI","restore","xt","yt","txt","noChar","half","slice","y1","x2","y2","temporary","midx","midy","srt","lineCap","strokeStyle","lineWidth","stroke","Path2D","closePath","arc","args","tl","tr","br","bl","rect","absW","abs","absH","hw","hh","moveTo","arcTo","onchangeCallb","setOptions","newoptions","showGraph","canvas1","select","attr","ctx1","getContext","canvas","call","drag","addFunction","lastIndex","filter","clearGraph","mergedContext","set_indexed_func","forEach","sourceOutput","onChange","cb","getGraph","show","pipe","clear"],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3lBD,IAAMgG,EAAE,GAAGpG,OAAO,CAAC,IAAD,CAAlB;;AAEA,SAASqG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"}